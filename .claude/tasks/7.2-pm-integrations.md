# Epic 7.2: Project Management Integrations

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Build integration framework with OAuth flows and bidirectional sync for Jira, Linear, Asana, and GitHub Issues.

## Wave Context
**Wave 7**: Advanced Features (Roadmaps, PM Integrations, AI Features)
**Dependencies**: Wave 1 (Core API), Wave 2 (AI for linking)
**Unlocks**: Two-way sync, automatic issue creation, status synchronization

## Quality Requirements
- OAuth 2.0 with secure token storage
- Bidirectional status sync with conflict resolution
- Rate limit handling for external APIs
- Webhook receivers for real-time updates

---

## Tasks

### Task 7.2.1: Integration Framework (2h)

Build reusable integration framework with OAuth, token management, and sync tracking.

**Subtasks**:
- [ ] OAuth flow handler for multiple providers
- [ ] Encrypted token storage
- [ ] Token refresh handling
- [ ] Sync status tracking

**Schema**:
```sql
-- Integration configurations
CREATE TABLE IF NOT EXISTS integrations (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  type TEXT NOT NULL, -- 'jira', 'linear', 'asana', 'github'
  name TEXT NOT NULL, -- User-friendly name
  config TEXT NOT NULL, -- Encrypted JSON: project/repo selection, field mappings
  credentials TEXT NOT NULL, -- Encrypted JSON: access_token, refresh_token, etc.
  status TEXT DEFAULT 'connected', -- 'connected', 'disconnected', 'error'
  last_sync_at TEXT,
  sync_frequency INTEGER DEFAULT 3600, -- Seconds between syncs
  error_message TEXT,
  error_count INTEGER DEFAULT 0,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  UNIQUE(workspace_id, type, name)
);

CREATE INDEX idx_integrations_workspace ON integrations(workspace_id, type);
CREATE INDEX idx_integrations_status ON integrations(status);

-- Mapping between feedback and external items
CREATE TABLE IF NOT EXISTS integration_mappings (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  integration_id TEXT NOT NULL REFERENCES integrations(id) ON DELETE CASCADE,
  feedback_id TEXT NOT NULL REFERENCES feedback_items(id) ON DELETE CASCADE,
  external_id TEXT NOT NULL, -- Jira issue key, Linear ID, etc.
  external_key TEXT, -- Human-readable key (PROJ-123)
  external_url TEXT,
  external_status TEXT, -- Last known external status
  local_status TEXT, -- Last synced local status
  sync_direction TEXT DEFAULT 'both', -- 'to_external', 'from_external', 'both'
  last_sync_at TEXT DEFAULT (datetime('now')),
  sync_error TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  UNIQUE(integration_id, feedback_id),
  UNIQUE(integration_id, external_id)
);

CREATE INDEX idx_mappings_integration ON integration_mappings(integration_id);
CREATE INDEX idx_mappings_feedback ON integration_mappings(feedback_id);

-- Sync log for debugging
CREATE TABLE IF NOT EXISTS integration_sync_log (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  integration_id TEXT NOT NULL REFERENCES integrations(id) ON DELETE CASCADE,
  mapping_id TEXT REFERENCES integration_mappings(id),
  direction TEXT NOT NULL, -- 'push', 'pull'
  action TEXT NOT NULL, -- 'create', 'update', 'delete'
  payload TEXT, -- JSON of what was synced
  result TEXT, -- 'success', 'error'
  error_message TEXT,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_sync_log ON integration_sync_log(integration_id, created_at DESC);
```

**Implementation**:
```typescript
// src/services/integrations/framework.ts
import { encrypt, decrypt } from '../crypto';

interface OAuthConfig {
  client_id: string;
  client_secret: string;
  authorize_url: string;
  token_url: string;
  scopes: string[];
  redirect_uri: string;
}

interface TokenSet {
  access_token: string;
  refresh_token?: string;
  expires_at?: number;
  token_type: string;
}

interface IntegrationProvider {
  type: string;
  oauth_config: OAuthConfig;
  getAuthorizationUrl(state: string): string;
  exchangeCode(code: string): Promise<TokenSet>;
  refreshToken(refresh_token: string): Promise<TokenSet>;
  validateConnection(tokens: TokenSet): Promise<boolean>;
}

// OAuth flow handler
export async function initiateOAuth(
  env: Env,
  workspaceId: string,
  providerType: string,
  returnUrl: string
): Promise<{ authorization_url: string; state: string }> {
  const provider = getProvider(providerType);
  const state = crypto.randomUUID();

  // Store state for verification
  await env.OAUTH_KV.put(`oauth_state:${state}`, JSON.stringify({
    workspace_id: workspaceId,
    provider: providerType,
    return_url: returnUrl,
    created_at: Date.now()
  }), { expirationTtl: 600 }); // 10 min expiry

  return {
    authorization_url: provider.getAuthorizationUrl(state),
    state
  };
}

export async function handleOAuthCallback(
  env: Env,
  code: string,
  state: string
): Promise<{ success: boolean; integration_id?: string; error?: string }> {
  // Verify state
  const stateData = await env.OAUTH_KV.get(`oauth_state:${state}`, 'json') as {
    workspace_id: string;
    provider: string;
    return_url: string;
  } | null;

  if (!stateData) {
    return { success: false, error: 'Invalid or expired state' };
  }

  await env.OAUTH_KV.delete(`oauth_state:${state}`);

  const provider = getProvider(stateData.provider);

  try {
    const tokens = await provider.exchangeCode(code);

    // Validate connection
    const valid = await provider.validateConnection(tokens);
    if (!valid) {
      return { success: false, error: 'Failed to validate connection' };
    }

    // Store integration
    const integrationId = crypto.randomUUID();
    const encryptedCredentials = await encrypt(env, JSON.stringify(tokens));

    await env.DB.prepare(`
      INSERT INTO integrations (id, workspace_id, type, name, config, credentials, status)
      VALUES (?, ?, ?, ?, ?, ?, 'connected')
    `).bind(
      integrationId,
      stateData.workspace_id,
      stateData.provider,
      `${stateData.provider} Integration`,
      '{}',
      encryptedCredentials
    ).run();

    return { success: true, integration_id: integrationId };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}

// Token refresh with retry
export async function getValidTokens(
  env: Env,
  integration: { id: string; credentials: string; type: string }
): Promise<TokenSet> {
  const tokens = JSON.parse(await decrypt(env, integration.credentials)) as TokenSet;

  // Check if expired
  if (tokens.expires_at && tokens.expires_at < Date.now() / 1000) {
    if (!tokens.refresh_token) {
      throw new Error('Token expired and no refresh token available');
    }

    const provider = getProvider(integration.type);
    const newTokens = await provider.refreshToken(tokens.refresh_token);

    // Update stored tokens
    const encryptedCredentials = await encrypt(env, JSON.stringify(newTokens));
    await env.DB.prepare(`
      UPDATE integrations SET credentials = ?, updated_at = datetime('now')
      WHERE id = ?
    `).bind(encryptedCredentials, integration.id).run();

    return newTokens;
  }

  return tokens;
}

// Sync status tracking
export async function logSync(
  env: Env,
  integrationId: string,
  mappingId: string | null,
  direction: 'push' | 'pull',
  action: 'create' | 'update' | 'delete',
  payload: Record<string, unknown>,
  result: 'success' | 'error',
  errorMessage?: string
): Promise<void> {
  await env.DB.prepare(`
    INSERT INTO integration_sync_log (
      integration_id, mapping_id, direction, action, payload, result, error_message
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
  `).bind(
    integrationId, mappingId, direction, action,
    JSON.stringify(payload), result, errorMessage || null
  ).run();

  // Update last sync time
  await env.DB.prepare(`
    UPDATE integrations SET last_sync_at = datetime('now') WHERE id = ?
  `).bind(integrationId).run();
}

function getProvider(type: string): IntegrationProvider {
  switch (type) {
    case 'jira': return new JiraProvider();
    case 'linear': return new LinearProvider();
    case 'asana': return new AsanaProvider();
    case 'github': return new GitHubProvider();
    default: throw new Error(`Unknown provider: ${type}`);
  }
}
```

**Acceptance Criteria**:
- [ ] OAuth flow for all providers
- [ ] Tokens encrypted at rest
- [ ] Token refresh automatic
- [ ] Sync logging complete

---

### Task 7.2.2: Jira Integration (3h)

Implement Jira Cloud integration with bidirectional status sync.

**Subtasks**:
- [ ] Jira OAuth 2.0 flow
- [ ] Project and issue type selection
- [ ] Create Jira issue from feedback
- [ ] Bidirectional status sync

**Implementation**:
```typescript
// src/services/integrations/jira.ts
class JiraProvider implements IntegrationProvider {
  type = 'jira';

  oauth_config: OAuthConfig = {
    client_id: '',  // From env
    client_secret: '', // From env
    authorize_url: 'https://auth.atlassian.com/authorize',
    token_url: 'https://auth.atlassian.com/oauth/token',
    scopes: ['read:jira-work', 'write:jira-work', 'offline_access'],
    redirect_uri: ''
  };

  getAuthorizationUrl(state: string): string {
    const params = new URLSearchParams({
      audience: 'api.atlassian.com',
      client_id: this.oauth_config.client_id,
      scope: this.oauth_config.scopes.join(' '),
      redirect_uri: this.oauth_config.redirect_uri,
      state,
      response_type: 'code',
      prompt: 'consent'
    });
    return `${this.oauth_config.authorize_url}?${params}`;
  }

  async exchangeCode(code: string): Promise<TokenSet> {
    const response = await fetch(this.oauth_config.token_url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        client_id: this.oauth_config.client_id,
        client_secret: this.oauth_config.client_secret,
        code,
        redirect_uri: this.oauth_config.redirect_uri
      })
    });
    return await response.json();
  }

  async refreshToken(refresh_token: string): Promise<TokenSet> {
    const response = await fetch(this.oauth_config.token_url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        client_id: this.oauth_config.client_id,
        client_secret: this.oauth_config.client_secret,
        refresh_token
      })
    });
    return await response.json();
  }

  async validateConnection(tokens: TokenSet): Promise<boolean> {
    const response = await fetch('https://api.atlassian.com/oauth/token/accessible-resources', {
      headers: { 'Authorization': `Bearer ${tokens.access_token}` }
    });
    return response.ok;
  }
}

// Jira API client
class JiraClient {
  constructor(
    private cloudId: string,
    private accessToken: string
  ) {}

  private get baseUrl() {
    return `https://api.atlassian.com/ex/jira/${this.cloudId}/rest/api/3`;
  }

  private async request<T>(path: string, options: RequestInit = {}): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });

    if (!response.ok) {
      throw new Error(`Jira API error: ${response.status}`);
    }

    return response.json();
  }

  async getProjects(): Promise<Array<{ id: string; key: string; name: string }>> {
    return this.request('/project');
  }

  async getIssueTypes(projectKey: string): Promise<Array<{ id: string; name: string }>> {
    const project = await this.request<{ issueTypes: Array<{ id: string; name: string }> }>(
      `/project/${projectKey}`
    );
    return project.issueTypes;
  }

  async createIssue(input: {
    projectKey: string;
    issueType: string;
    summary: string;
    description: string;
    labels?: string[];
  }): Promise<{ id: string; key: string; self: string }> {
    return this.request('/issue', {
      method: 'POST',
      body: JSON.stringify({
        fields: {
          project: { key: input.projectKey },
          issuetype: { name: input.issueType },
          summary: input.summary,
          description: {
            type: 'doc',
            version: 1,
            content: [{
              type: 'paragraph',
              content: [{ type: 'text', text: input.description }]
            }]
          },
          labels: input.labels || []
        }
      })
    });
  }

  async getIssue(issueKey: string): Promise<{
    id: string;
    key: string;
    fields: { status: { name: string }; summary: string };
  }> {
    return this.request(`/issue/${issueKey}`);
  }

  async transitionIssue(issueKey: string, transitionName: string): Promise<void> {
    // Get available transitions
    const { transitions } = await this.request<{
      transitions: Array<{ id: string; name: string }>
    }>(`/issue/${issueKey}/transitions`);

    const transition = transitions.find(t =>
      t.name.toLowerCase() === transitionName.toLowerCase()
    );

    if (!transition) {
      throw new Error(`Transition '${transitionName}' not available`);
    }

    await this.request(`/issue/${issueKey}/transitions`, {
      method: 'POST',
      body: JSON.stringify({ transition: { id: transition.id } })
    });
  }
}

// Status mapping
const JIRA_STATUS_MAP: Record<string, string> = {
  'open': 'To Do',
  'planned': 'To Do',
  'in_progress': 'In Progress',
  'under_review': 'In Review',
  'done': 'Done',
  'closed': 'Done',
  'wont_fix': 'Won\'t Do'
};

const JIRA_REVERSE_STATUS_MAP: Record<string, string> = {
  'to do': 'open',
  'backlog': 'open',
  'in progress': 'in_progress',
  'in review': 'under_review',
  'done': 'done',
  'closed': 'closed',
  'won\'t do': 'wont_fix'
};

// Sync feedback to Jira
export async function syncFeedbackToJira(
  env: Env,
  integrationId: string,
  feedbackId: string
): Promise<{ success: boolean; issue_key?: string; error?: string }> {
  const integration = await env.DB.prepare(`
    SELECT * FROM integrations WHERE id = ?
  `).bind(integrationId).first();

  if (!integration) return { success: false, error: 'Integration not found' };

  const feedback = await env.DB.prepare(`
    SELECT * FROM feedback_items WHERE id = ?
  `).bind(feedbackId).first();

  if (!feedback) return { success: false, error: 'Feedback not found' };

  const tokens = await getValidTokens(env, integration);
  const config = JSON.parse(integration.config);

  const client = new JiraClient(config.cloud_id, tokens.access_token);

  try {
    // Check if already mapped
    const existing = await env.DB.prepare(`
      SELECT * FROM integration_mappings
      WHERE integration_id = ? AND feedback_id = ?
    `).bind(integrationId, feedbackId).first();

    if (existing) {
      // Update existing issue status
      const targetStatus = JIRA_STATUS_MAP[feedback.status] || 'To Do';
      await client.transitionIssue(existing.external_key, targetStatus);

      await env.DB.prepare(`
        UPDATE integration_mappings
        SET local_status = ?, last_sync_at = datetime('now')
        WHERE id = ?
      `).bind(feedback.status, existing.id).run();

      await logSync(env, integrationId, existing.id, 'push', 'update', { status: feedback.status }, 'success');

      return { success: true, issue_key: existing.external_key };
    }

    // Create new issue
    const issue = await client.createIssue({
      projectKey: config.project_key,
      issueType: config.issue_type || 'Task',
      summary: feedback.title,
      description: `${feedback.description || ''}\n\n---\nSource: Collective Vision Feedback\nVotes: ${feedback.vote_count || 0}`,
      labels: ['collective-vision', `cv-${feedbackId.slice(0, 8)}`]
    });

    // Create mapping
    await env.DB.prepare(`
      INSERT INTO integration_mappings (
        integration_id, feedback_id, external_id, external_key, external_url,
        external_status, local_status
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      integrationId, feedbackId, issue.id, issue.key,
      `https://${config.domain}/browse/${issue.key}`,
      'To Do', feedback.status
    ).run();

    await logSync(env, integrationId, null, 'push', 'create', { issue_key: issue.key }, 'success');

    return { success: true, issue_key: issue.key };
  } catch (error) {
    await logSync(env, integrationId, null, 'push', 'create', { feedback_id: feedbackId }, 'error', String(error));
    return { success: false, error: String(error) };
  }
}

// Webhook handler for Jira updates
export async function handleJiraWebhook(
  env: Env,
  payload: {
    webhookEvent: string;
    issue: { id: string; key: string; fields: { status: { name: string } } };
  }
): Promise<void> {
  if (payload.webhookEvent !== 'jira:issue_updated') return;

  // Find mapping
  const mapping = await env.DB.prepare(`
    SELECT m.*, i.workspace_id FROM integration_mappings m
    JOIN integrations i ON i.id = m.integration_id
    WHERE m.external_id = ?
  `).bind(payload.issue.id).first();

  if (!mapping) return;

  // Map Jira status to local status
  const jiraStatus = payload.issue.fields.status.name.toLowerCase();
  const localStatus = JIRA_REVERSE_STATUS_MAP[jiraStatus];

  if (localStatus && localStatus !== mapping.local_status) {
    // Update feedback status
    await env.DB.prepare(`
      UPDATE feedback_items SET status = ?, updated_at = datetime('now')
      WHERE id = ?
    `).bind(localStatus, mapping.feedback_id).run();

    // Update mapping
    await env.DB.prepare(`
      UPDATE integration_mappings
      SET external_status = ?, local_status = ?, last_sync_at = datetime('now')
      WHERE id = ?
    `).bind(jiraStatus, localStatus, mapping.id).run();

    await logSync(env, mapping.integration_id, mapping.id, 'pull', 'update', {
      from_status: mapping.local_status,
      to_status: localStatus
    }, 'success');
  }
}
```

**Acceptance Criteria**:
- [ ] Jira OAuth working
- [ ] Issues created from feedback
- [ ] Status synced bidirectionally
- [ ] Webhook updates handled

---

### Task 7.2.3: Linear Integration (2.5h)

Implement Linear integration with GraphQL API.

**Subtasks**:
- [ ] Linear OAuth flow
- [ ] Team/project selection
- [ ] Issue creation
- [ ] Status sync

**Implementation**:
```typescript
// src/services/integrations/linear.ts
class LinearProvider implements IntegrationProvider {
  type = 'linear';

  oauth_config: OAuthConfig = {
    client_id: '',
    client_secret: '',
    authorize_url: 'https://linear.app/oauth/authorize',
    token_url: 'https://api.linear.app/oauth/token',
    scopes: ['read', 'write', 'issues:create'],
    redirect_uri: ''
  };

  // Similar OAuth methods as Jira...
}

class LinearClient {
  private endpoint = 'https://api.linear.app/graphql';

  constructor(private accessToken: string) {}

  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': this.accessToken,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ query, variables })
    });

    const result = await response.json();
    if (result.errors) {
      throw new Error(result.errors[0].message);
    }
    return result.data;
  }

  async getTeams(): Promise<Array<{ id: string; name: string; key: string }>> {
    const result = await this.query<{ teams: { nodes: Array<{ id: string; name: string; key: string }> } }>(`
      query { teams { nodes { id name key } } }
    `);
    return result.teams.nodes;
  }

  async getProjects(teamId: string): Promise<Array<{ id: string; name: string }>> {
    const result = await this.query<{ team: { projects: { nodes: Array<{ id: string; name: string }> } } }>(`
      query($teamId: String!) {
        team(id: $teamId) { projects { nodes { id name } } }
      }
    `, { teamId });
    return result.team.projects.nodes;
  }

  async getWorkflowStates(teamId: string): Promise<Array<{ id: string; name: string; type: string }>> {
    const result = await this.query<{ workflowStates: { nodes: Array<{ id: string; name: string; type: string }> } }>(`
      query($teamId: ID!) {
        workflowStates(filter: { team: { id: { eq: $teamId } } }) {
          nodes { id name type }
        }
      }
    `, { teamId });
    return result.workflowStates.nodes;
  }

  async createIssue(input: {
    teamId: string;
    title: string;
    description?: string;
    projectId?: string;
    labelIds?: string[];
  }): Promise<{ id: string; identifier: string; url: string }> {
    const result = await this.query<{ issueCreate: { success: boolean; issue: { id: string; identifier: string; url: string } } }>(`
      mutation($input: IssueCreateInput!) {
        issueCreate(input: $input) {
          success
          issue { id identifier url }
        }
      }
    `, {
      input: {
        teamId: input.teamId,
        title: input.title,
        description: input.description,
        projectId: input.projectId,
        labelIds: input.labelIds
      }
    });
    return result.issueCreate.issue;
  }

  async updateIssueState(issueId: string, stateId: string): Promise<void> {
    await this.query(`
      mutation($id: String!, $stateId: String!) {
        issueUpdate(id: $id, input: { stateId: $stateId }) { success }
      }
    `, { id: issueId, stateId });
  }
}

// Linear status mapping
const LINEAR_STATUS_MAP: Record<string, string> = {
  'open': 'Backlog',
  'planned': 'Todo',
  'in_progress': 'In Progress',
  'under_review': 'In Review',
  'done': 'Done',
  'closed': 'Done',
  'wont_fix': 'Canceled'
};

export async function syncFeedbackToLinear(
  env: Env,
  integrationId: string,
  feedbackId: string
): Promise<{ success: boolean; identifier?: string; error?: string }> {
  // Similar pattern to Jira sync...
  const integration = await env.DB.prepare(`SELECT * FROM integrations WHERE id = ?`)
    .bind(integrationId).first();

  if (!integration) return { success: false, error: 'Integration not found' };

  const feedback = await env.DB.prepare(`SELECT * FROM feedback_items WHERE id = ?`)
    .bind(feedbackId).first();

  if (!feedback) return { success: false, error: 'Feedback not found' };

  const tokens = await getValidTokens(env, integration);
  const config = JSON.parse(integration.config);
  const client = new LinearClient(tokens.access_token);

  try {
    const existing = await env.DB.prepare(`
      SELECT * FROM integration_mappings WHERE integration_id = ? AND feedback_id = ?
    `).bind(integrationId, feedbackId).first();

    if (existing) {
      // Get state ID for target status
      const states = await client.getWorkflowStates(config.team_id);
      const targetState = states.find(s =>
        s.name.toLowerCase() === LINEAR_STATUS_MAP[feedback.status]?.toLowerCase()
      );

      if (targetState) {
        await client.updateIssueState(existing.external_id, targetState.id);
      }

      await logSync(env, integrationId, existing.id, 'push', 'update', { status: feedback.status }, 'success');
      return { success: true, identifier: existing.external_key };
    }

    // Create new issue
    const issue = await client.createIssue({
      teamId: config.team_id,
      title: feedback.title,
      description: `${feedback.description || ''}\n\n---\nSource: Collective Vision\nVotes: ${feedback.vote_count || 0}`,
      projectId: config.project_id
    });

    await env.DB.prepare(`
      INSERT INTO integration_mappings (
        integration_id, feedback_id, external_id, external_key, external_url, local_status
      ) VALUES (?, ?, ?, ?, ?, ?)
    `).bind(integrationId, feedbackId, issue.id, issue.identifier, issue.url, feedback.status).run();

    await logSync(env, integrationId, null, 'push', 'create', { identifier: issue.identifier }, 'success');
    return { success: true, identifier: issue.identifier };
  } catch (error) {
    await logSync(env, integrationId, null, 'push', 'create', {}, 'error', String(error));
    return { success: false, error: String(error) };
  }
}
```

**Acceptance Criteria**:
- [ ] Linear OAuth working
- [ ] Issues created with descriptions
- [ ] Status mapped correctly
- [ ] Webhook sync implemented

---

### Task 7.2.4: Asana Integration (2.5h)

Implement Asana integration with section-based status tracking.

**Subtasks**:
- [ ] Asana OAuth flow
- [ ] Project selection
- [ ] Task creation
- [ ] Section-based status sync

**Implementation**:
```typescript
// src/services/integrations/asana.ts
class AsanaClient {
  private baseUrl = 'https://app.asana.com/api/1.0';

  constructor(private accessToken: string) {}

  private async request<T>(path: string, options: RequestInit = {}): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });

    const result = await response.json();
    if (result.errors) {
      throw new Error(result.errors[0].message);
    }
    return result.data;
  }

  async getWorkspaces(): Promise<Array<{ gid: string; name: string }>> {
    return this.request('/workspaces');
  }

  async getProjects(workspaceGid: string): Promise<Array<{ gid: string; name: string }>> {
    return this.request(`/workspaces/${workspaceGid}/projects`);
  }

  async getSections(projectGid: string): Promise<Array<{ gid: string; name: string }>> {
    return this.request(`/projects/${projectGid}/sections`);
  }

  async createTask(input: {
    projectGid: string;
    sectionGid?: string;
    name: string;
    notes?: string;
  }): Promise<{ gid: string; permalink_url: string }> {
    return this.request('/tasks', {
      method: 'POST',
      body: JSON.stringify({
        data: {
          projects: [input.projectGid],
          name: input.name,
          notes: input.notes
        }
      })
    });
  }

  async moveTaskToSection(taskGid: string, sectionGid: string): Promise<void> {
    await this.request(`/sections/${sectionGid}/addTask`, {
      method: 'POST',
      body: JSON.stringify({ data: { task: taskGid } })
    });
  }

  async getTask(taskGid: string): Promise<{ gid: string; memberships: Array<{ section: { name: string } }> }> {
    return this.request(`/tasks/${taskGid}?opt_fields=memberships.section.name`);
  }
}

// Section name mapping
const ASANA_SECTION_MAP: Record<string, string> = {
  'open': 'Backlog',
  'planned': 'To Do',
  'in_progress': 'In Progress',
  'done': 'Done'
};

export async function syncFeedbackToAsana(
  env: Env,
  integrationId: string,
  feedbackId: string
): Promise<{ success: boolean; task_gid?: string; error?: string }> {
  // Implementation follows same pattern as Jira/Linear...
  // Create task in project, move to section based on status
}
```

**Acceptance Criteria**:
- [ ] Asana OAuth working
- [ ] Tasks created in projects
- [ ] Sections mapped to status
- [ ] Webhook updates handled

---

### Task 7.2.5: GitHub Issues Integration (2h)

Implement GitHub Issues with label-based status tracking.

**Subtasks**:
- [ ] GitHub OAuth flow
- [ ] Repository selection
- [ ] Issue creation with labels
- [ ] Close on completion

**Implementation**:
```typescript
// src/services/integrations/github.ts
class GitHubClient {
  private baseUrl = 'https://api.github.com';

  constructor(private accessToken: string) {}

  private async request<T>(path: string, options: RequestInit = {}): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      headers: {
        'Authorization': `token ${this.accessToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Collective-Vision',
        ...options.headers
      }
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || `GitHub API error: ${response.status}`);
    }

    return response.json();
  }

  async getRepos(): Promise<Array<{ id: number; full_name: string; private: boolean }>> {
    return this.request('/user/repos?per_page=100&sort=updated');
  }

  async createIssue(owner: string, repo: string, input: {
    title: string;
    body?: string;
    labels?: string[];
  }): Promise<{ id: number; number: number; html_url: string }> {
    return this.request(`/repos/${owner}/${repo}/issues`, {
      method: 'POST',
      body: JSON.stringify(input)
    });
  }

  async updateIssue(owner: string, repo: string, issueNumber: number, input: {
    state?: 'open' | 'closed';
    labels?: string[];
  }): Promise<void> {
    await this.request(`/repos/${owner}/${repo}/issues/${issueNumber}`, {
      method: 'PATCH',
      body: JSON.stringify(input)
    });
  }

  async addLabels(owner: string, repo: string, issueNumber: number, labels: string[]): Promise<void> {
    await this.request(`/repos/${owner}/${repo}/issues/${issueNumber}/labels`, {
      method: 'POST',
      body: JSON.stringify({ labels })
    });
  }

  async removeLabel(owner: string, repo: string, issueNumber: number, label: string): Promise<void> {
    await this.request(`/repos/${owner}/${repo}/issues/${issueNumber}/labels/${encodeURIComponent(label)}`, {
      method: 'DELETE'
    });
  }
}

// Label-based status
const GITHUB_LABELS: Record<string, { name: string; color: string }> = {
  'open': { name: 'cv:open', color: 'e5e5e5' },
  'planned': { name: 'cv:planned', color: '0052cc' },
  'in_progress': { name: 'cv:in-progress', color: 'fbca04' },
  'done': { name: 'cv:done', color: '0e8a16' },
  'wont_fix': { name: 'cv:wont-fix', color: 'cb2431' }
};

export async function syncFeedbackToGitHub(
  env: Env,
  integrationId: string,
  feedbackId: string
): Promise<{ success: boolean; issue_number?: number; error?: string }> {
  const integration = await env.DB.prepare(`SELECT * FROM integrations WHERE id = ?`)
    .bind(integrationId).first();

  if (!integration) return { success: false, error: 'Integration not found' };

  const feedback = await env.DB.prepare(`SELECT * FROM feedback_items WHERE id = ?`)
    .bind(feedbackId).first();

  if (!feedback) return { success: false, error: 'Feedback not found' };

  const tokens = await getValidTokens(env, integration);
  const config = JSON.parse(integration.config);
  const [owner, repo] = config.repository.split('/');

  const client = new GitHubClient(tokens.access_token);

  try {
    const existing = await env.DB.prepare(`
      SELECT * FROM integration_mappings WHERE integration_id = ? AND feedback_id = ?
    `).bind(integrationId, feedbackId).first();

    const statusLabel = GITHUB_LABELS[feedback.status];

    if (existing) {
      const issueNumber = parseInt(existing.external_key);

      // Update labels for status
      const oldLabel = GITHUB_LABELS[existing.local_status];
      if (oldLabel && oldLabel.name !== statusLabel?.name) {
        await client.removeLabel(owner, repo, issueNumber, oldLabel.name);
      }
      if (statusLabel) {
        await client.addLabels(owner, repo, issueNumber, [statusLabel.name]);
      }

      // Close if done
      if (feedback.status === 'done' || feedback.status === 'closed') {
        await client.updateIssue(owner, repo, issueNumber, { state: 'closed' });
      }

      await env.DB.prepare(`
        UPDATE integration_mappings SET local_status = ?, last_sync_at = datetime('now')
        WHERE id = ?
      `).bind(feedback.status, existing.id).run();

      await logSync(env, integrationId, existing.id, 'push', 'update', { status: feedback.status }, 'success');
      return { success: true, issue_number: issueNumber };
    }

    // Create new issue
    const labels = [
      'collective-vision',
      `cv-feedback:${feedbackId.slice(0, 8)}`,
      statusLabel?.name
    ].filter(Boolean) as string[];

    const issue = await client.createIssue(owner, repo, {
      title: feedback.title,
      body: `${feedback.description || ''}\n\n---\n**Source:** Collective Vision Feedback\n**Votes:** ${feedback.vote_count || 0}\n**Feedback ID:** ${feedbackId}`,
      labels
    });

    await env.DB.prepare(`
      INSERT INTO integration_mappings (
        integration_id, feedback_id, external_id, external_key, external_url, local_status
      ) VALUES (?, ?, ?, ?, ?, ?)
    `).bind(integrationId, feedbackId, String(issue.id), String(issue.number), issue.html_url, feedback.status).run();

    await logSync(env, integrationId, null, 'push', 'create', { issue_number: issue.number }, 'success');
    return { success: true, issue_number: issue.number };
  } catch (error) {
    await logSync(env, integrationId, null, 'push', 'create', {}, 'error', String(error));
    return { success: false, error: String(error) };
  }
}
```

**Acceptance Criteria**:
- [ ] GitHub OAuth working
- [ ] Issues created with labels
- [ ] Labels updated on status change
- [ ] Issues closed when done

---

## Definition of Done
- [ ] All four integrations working
- [ ] OAuth flows secure
- [ ] Bidirectional sync functional
- [ ] Webhook handlers complete
- [ ] Sync logging for debugging

## Technical Notes
- Tokens encrypted with workspace-specific keys
- Rate limiting respected for each API
- Webhooks verified with signatures
- Conflict resolution favors manual changes

## Related Files
- `src/services/integrations/framework.ts` - Core framework
- `src/services/integrations/jira.ts` - Jira integration
- `src/services/integrations/linear.ts` - Linear integration
- `src/services/integrations/asana.ts` - Asana integration
- `src/services/integrations/github.ts` - GitHub integration
- `src/routes/webhooks/integrations.ts` - Webhook handlers
