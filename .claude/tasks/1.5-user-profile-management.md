# Epic 1.5: User Profile Management

## Methodology Guidance
**SPECTRA Phase**: Implementation/User Experience
**Approach**: Self-service profile management with avatar uploads
**Tools**: R2 for avatar storage, Resend for email changes

## Wave Context
**Wave**: 1 - Authentication & User Management
**Priority**: Medium (user convenience feature)
**Dependencies**: Epic 1.2 (auth)
**Estimated Duration**: 3 hours

## Quality Requirements
- Users can only modify their own profiles
- Email changes require verification
- Avatar uploads properly validated and sized
- Account deletion is complete and irreversible

---

## Tasks

### 1.5.1 Profile Endpoints (1h)
**Objective**: Get and update current user profile

**Steps**:
1. Get current user endpoint:
   ```typescript
   // GET /api/v1/me
   async function handleGetProfile(request: Request, env: Env) {
     const user = await requireAuth(request, env);

     // Get user with workspace memberships
     const memberships = await env.DB.prepare(`
       SELECT tm.role, w.id, w.name, w.slug
       FROM team_memberships tm
       JOIN workspaces w ON tm.workspace_id = w.id
       WHERE tm.user_id = ?
       ORDER BY tm.created_at DESC
     `).bind(user.id).all();

     // Get linked OAuth accounts (without tokens)
     const oauthAccounts = await env.DB.prepare(`
       SELECT provider, provider_email, created_at
       FROM oauth_accounts
       WHERE user_id = ?
     `).bind(user.id).all();

     return jsonResponse({
       user: {
         id: user.id,
         email: user.email,
         name: user.name,
         avatar_url: user.avatar_url,
         email_verified: Boolean(user.email_verified),
         created_at: user.created_at,
         updated_at: user.updated_at
       },
       workspaces: memberships.results,
       oauth_accounts: oauthAccounts.results
     });
   }
   ```

2. Update profile endpoint:
   ```typescript
   // PATCH /api/v1/me
   const updateProfileSchema = z.object({
     name: z.string().min(1).max(100).optional(),
     notification_preferences: z.object({
       email_feedback_updates: z.boolean().optional(),
       email_weekly_digest: z.boolean().optional(),
       email_marketing: z.boolean().optional()
     }).optional()
   });

   async function handleUpdateProfile(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const updates = await validateBody(request, updateProfileSchema);

     const setClauses: string[] = [];
     const values: any[] = [];

     if (updates.name !== undefined) {
       setClauses.push('name = ?');
       values.push(updates.name);
     }

     if (updates.notification_preferences) {
       setClauses.push('notification_preferences = ?');
       values.push(JSON.stringify(updates.notification_preferences));
     }

     if (setClauses.length === 0) {
       return errorResponse('NO_CHANGES', 'No fields to update', 400);
     }

     setClauses.push('updated_at = datetime(\'now\')');
     values.push(user.id);

     await env.DB.prepare(`
       UPDATE users SET ${setClauses.join(', ')} WHERE id = ?
     `).bind(...values).run();

     return jsonResponse({ message: 'Profile updated' });
   }
   ```

3. Change email endpoint (requires verification):
   ```typescript
   // POST /api/v1/me/email
   async function handleChangeEmail(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const { new_email, password } = await validateBody(request, changeEmailSchema);

     // Verify current password (if password auth)
     if (user.password_hash) {
       const valid = await verifyPassword(password, user.password_hash);
       if (!valid) {
         return errorResponse('INVALID_PASSWORD', 'Current password is incorrect', 401);
       }
     }

     // Check if email already in use
     const existing = await env.DB.prepare(
       'SELECT id FROM users WHERE email = ? AND id != ?'
     ).bind(new_email.toLowerCase(), user.id).first();

     if (existing) {
       return errorResponse('EMAIL_EXISTS', 'Email already in use', 409);
     }

     // Generate verification token for new email
     const token = generateSecureToken();
     await storeEmailChangeToken(user.id, new_email, token, env);
     await sendEmailChangeVerification(new_email, token, env);

     return jsonResponse({
       message: 'Verification email sent to new address'
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Users can update their own profile
- [ ] Email change requires password confirmation
- [ ] Email change requires verification of new address
- [ ] Notification preferences persist

---

### 1.5.2 Avatar Upload (1.5h)
**Objective**: Allow users to upload profile avatars

**Steps**:
1. Configure R2 bucket for avatars:
   ```toml
   # wrangler.toml
   [[r2_buckets]]
   binding = "AVATARS"
   bucket_name = "collective-vision-avatars"
   ```

2. Create avatar upload endpoint:
   ```typescript
   // POST /api/v1/me/avatar
   async function handleUploadAvatar(request: Request, env: Env) {
     const user = await requireAuth(request, env);

     // Check content type
     const contentType = request.headers.get('Content-Type');
     if (!contentType?.startsWith('image/')) {
       return errorResponse('INVALID_TYPE', 'Must be an image file', 400);
     }

     // Validate file type
     const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
     if (!allowedTypes.includes(contentType)) {
       return errorResponse('INVALID_TYPE', 'Must be JPEG, PNG, or WebP', 400);
     }

     // Check file size (max 2MB)
     const contentLength = parseInt(request.headers.get('Content-Length') || '0');
     if (contentLength > 2 * 1024 * 1024) {
       return errorResponse('FILE_TOO_LARGE', 'Maximum file size is 2MB', 400);
     }

     // Generate unique filename
     const ext = contentType.split('/')[1];
     const filename = `${user.id}/${Date.now()}.${ext}`;

     // Upload to R2
     const body = await request.arrayBuffer();
     await env.AVATARS.put(filename, body, {
       httpMetadata: { contentType }
     });

     // Generate public URL
     const avatarUrl = `${env.R2_PUBLIC_URL}/avatars/${filename}`;

     // Delete old avatar if exists
     if (user.avatar_url?.includes(env.R2_PUBLIC_URL)) {
       const oldKey = user.avatar_url.replace(`${env.R2_PUBLIC_URL}/avatars/`, '');
       await env.AVATARS.delete(oldKey);
     }

     // Update user record
     await env.DB.prepare(
       'UPDATE users SET avatar_url = ?, updated_at = datetime(\'now\') WHERE id = ?'
     ).bind(avatarUrl, user.id).run();

     return jsonResponse({ avatar_url: avatarUrl });
   }
   ```

3. Alternative: Presigned URL approach:
   ```typescript
   // GET /api/v1/me/avatar/upload-url
   async function handleGetUploadUrl(request: Request, env: Env) {
     const user = await requireAuth(request, env);

     // Generate presigned URL for direct upload
     // Note: Requires R2 presigned URL support

     return jsonResponse({
       upload_url: presignedUrl,
       expires_in: 300  // 5 minutes
     });
   }
   ```

4. Delete avatar endpoint:
   ```typescript
   // DELETE /api/v1/me/avatar
   async function handleDeleteAvatar(request: Request, env: Env) {
     const user = await requireAuth(request, env);

     if (!user.avatar_url) {
       return jsonResponse({ message: 'No avatar to delete' });
     }

     // Delete from R2
     if (user.avatar_url.includes(env.R2_PUBLIC_URL)) {
       const key = user.avatar_url.replace(`${env.R2_PUBLIC_URL}/avatars/`, '');
       await env.AVATARS.delete(key);
     }

     // Clear avatar URL
     await env.DB.prepare(
       'UPDATE users SET avatar_url = NULL, updated_at = datetime(\'now\') WHERE id = ?'
     ).bind(user.id).run();

     return jsonResponse({ message: 'Avatar deleted' });
   }
   ```

**Acceptance Criteria**:
- [ ] Max file size 2MB enforced
- [ ] Supports JPG, PNG, WebP
- [ ] Old avatar deleted on update
- [ ] Avatar URL stored in user record

---

### 1.5.3 Account Deletion (0.5h)
**Objective**: Allow users to delete their own accounts

**Steps**:
1. Create account deletion endpoint:
   ```typescript
   // DELETE /api/v1/me
   const deleteAccountSchema = z.object({
     password: z.string().optional(),
     confirmation: z.literal('DELETE MY ACCOUNT')
   });

   async function handleDeleteAccount(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const { password, confirmation } = await validateBody(request, deleteAccountSchema);

     // Require password if set
     if (user.password_hash) {
       if (!password) {
         return errorResponse('PASSWORD_REQUIRED', 'Password required', 400);
       }
       const valid = await verifyPassword(password, user.password_hash);
       if (!valid) {
         return errorResponse('INVALID_PASSWORD', 'Password is incorrect', 401);
       }
     }

     // Check for owned workspaces
     const ownedWorkspaces = await env.DB.prepare(`
       SELECT w.id, w.name FROM team_memberships tm
       JOIN workspaces w ON tm.workspace_id = w.id
       WHERE tm.user_id = ? AND tm.role = 'owner'
     `).bind(user.id).all();

     if (ownedWorkspaces.results.length > 0) {
       return errorResponse(
         'TRANSFER_REQUIRED',
         'You must transfer or delete owned workspaces first',
         400,
         { owned_workspaces: ownedWorkspaces.results }
       );
     }

     // Delete user data
     await env.DB.batch([
       // Delete sessions
       env.DB.prepare('DELETE FROM sessions WHERE user_id = ?').bind(user.id),
       // Delete API keys
       env.DB.prepare('DELETE FROM api_keys WHERE user_id = ?').bind(user.id),
       // Delete OAuth accounts
       env.DB.prepare('DELETE FROM oauth_accounts WHERE user_id = ?').bind(user.id),
       // Delete team memberships
       env.DB.prepare('DELETE FROM team_memberships WHERE user_id = ?').bind(user.id),
       // Delete user
       env.DB.prepare('DELETE FROM users WHERE id = ?').bind(user.id)
     ]);

     // Delete avatar from R2
     if (user.avatar_url?.includes(env.R2_PUBLIC_URL)) {
       const key = user.avatar_url.replace(`${env.R2_PUBLIC_URL}/avatars/`, '');
       await env.AVATARS.delete(key);
     }

     // Log deletion
     await logAuditEvent('user.deleted', user.id, null, {
       email: user.email,
       deleted_at: new Date().toISOString()
     }, env);

     return jsonResponse({ message: 'Account deleted' });
   }
   ```

**Acceptance Criteria**:
- [ ] All user data removed
- [ ] Workspace transfer required for owners
- [ ] Password confirmation required
- [ ] Deletion is complete (CASCADE)

---

## Definition of Done
- [ ] Profile viewing and updating works
- [ ] Avatar upload/delete works
- [ ] Email change with verification works
- [ ] Account deletion complete and safe
- [ ] All actions logged to audit

## Technical Notes
- Consider soft-delete for account deletion (30-day recovery)
- Avatar processing/resizing would require external service
- R2 public access may need Cloudflare configuration

## Related Files
- `src/routes/profile.ts` - Profile endpoints
- `src/lib/storage/avatars.ts` - Avatar handling
