# Epic 8.2: Performance & Scalability

**Wave**: 8 - Enterprise Polish
**Epic**: Performance & Scalability
**Estimated Hours**: 8h
**Priority**: P0 (Launch Critical)
**Dependencies**: Core API (0.x), Database (1.x)

---

## Overview

Optimize the platform for production scale with edge caching, query optimization, CDN configuration, and load testing to handle enterprise traffic patterns.

---

## Methodology Guidance

### SPECTRA Phase: Refine + Assure
This epic focuses on optimization and validation:
- **Refine**: Optimize existing implementations for performance
- **Assure**: Validate through load testing and monitoring

### Quality Bar
- P95 API response time < 100ms for cached endpoints
- P95 API response time < 500ms for uncached endpoints
- Support 1000 concurrent users per workspace
- 99.9% uptime target

---

## Wave Context

Wave 8 prepares the platform for enterprise deployment. Performance optimization ensures:
- Fast widget loading for end-user experience
- Scalable API for high-traffic workspaces
- Efficient database queries for analytics
- CDN edge delivery for global users

---

## Tasks

### Task 8.2.1: Edge Caching Strategy (2h)

Implement Cloudflare Cache API for hot endpoints.

#### Subtask 8.2.1.1: Cache API Integration (1h)

```typescript
// src/lib/cache.ts
interface CacheConfig {
  ttl: number;
  staleWhileRevalidate?: number;
  tags?: string[];
}

const CACHE_CONFIG: Record<string, CacheConfig> = {
  'feedback-list': { ttl: 60, staleWhileRevalidate: 300, tags: ['feedback'] },
  'feedback-item': { ttl: 300, staleWhileRevalidate: 600, tags: ['feedback'] },
  'roadmap-public': { ttl: 300, staleWhileRevalidate: 900, tags: ['roadmap'] },
  'widget-config': { ttl: 3600, staleWhileRevalidate: 7200, tags: ['config'] },
  'workspace-branding': { ttl: 3600, tags: ['branding'] },
};

export async function withCache<T>(
  request: Request,
  cacheKey: string,
  configName: string,
  fetcher: () => Promise<T>,
  ctx: ExecutionContext
): Promise<Response> {
  const cache = caches.default;
  const config = CACHE_CONFIG[configName];

  if (!config) {
    const data = await fetcher();
    return jsonResponse(data);
  }

  // Construct cache key URL
  const cacheUrl = new URL(request.url);
  cacheUrl.pathname = `/cache/${cacheKey}`;
  const cacheRequest = new Request(cacheUrl.toString());

  // Check cache
  let response = await cache.match(cacheRequest);

  if (response) {
    // Add cache hit header for debugging
    const headers = new Headers(response.headers);
    headers.set('X-Cache', 'HIT');
    headers.set('X-Cache-Age', response.headers.get('Age') || '0');
    return new Response(response.body, { headers });
  }

  // Cache miss - fetch fresh data
  const data = await fetcher();
  response = jsonResponse(data);

  // Set cache headers
  const cacheHeaders = new Headers(response.headers);
  cacheHeaders.set('Cache-Control',
    `public, max-age=${config.ttl}` +
    (config.staleWhileRevalidate ? `, stale-while-revalidate=${config.staleWhileRevalidate}` : '')
  );
  cacheHeaders.set('X-Cache', 'MISS');

  if (config.tags) {
    cacheHeaders.set('Cache-Tag', config.tags.join(','));
  }

  const cacheResponse = new Response(response.body, {
    status: response.status,
    headers: cacheHeaders,
  });

  // Store in cache (non-blocking)
  ctx.waitUntil(cache.put(cacheRequest, cacheResponse.clone()));

  return cacheResponse;
}

// Cache invalidation helper
export async function invalidateCache(tags: string[]): Promise<void> {
  // Cloudflare Cache API doesn't support tag-based purge directly
  // Use Cloudflare API for cache purge by tag
  const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/purge_cache`;

  await fetch(purgeUrl, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${CF_API_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ tags }),
  });
}
```

#### Subtask 8.2.1.2: Apply Caching to Endpoints (1h)

```typescript
// src/routes/feedback.ts
export async function listFeedback(
  request: Request,
  env: Env,
  ctx: ExecutionContext,
  workspaceSlug: string,
  boardSlug: string
): Promise<Response> {
  const url = new URL(request.url);
  const page = url.searchParams.get('page') || '1';
  const limit = url.searchParams.get('limit') || '20';
  const sort = url.searchParams.get('sort') || 'vote_count';

  const cacheKey = `feedback:${workspaceSlug}:${boardSlug}:${page}:${limit}:${sort}`;

  return withCache(
    request,
    cacheKey,
    'feedback-list',
    async () => {
      // Existing fetch logic
      const { workspace, board } = await getOrCreateWorkspaceAndBoard(
        env.DB, workspaceSlug, boardSlug
      );
      return fetchFeedbackItems(env.DB, board.id, parseInt(page), parseInt(limit), sort);
    },
    ctx
  );
}

// Invalidate on mutations
export async function createFeedback(
  request: Request,
  env: Env,
  ctx: ExecutionContext,
  workspaceSlug: string,
  boardSlug: string
): Promise<Response> {
  const result = await insertFeedback(/* ... */);

  // Invalidate cache for this board
  ctx.waitUntil(invalidateCache([`feedback:${workspaceSlug}:${boardSlug}`]));

  return jsonResponse(result, 201);
}
```

**Acceptance Criteria**:
- [ ] Cache API integration working
- [ ] Feedback list cached with 60s TTL
- [ ] Cache headers visible in responses
- [ ] Cache invalidation on mutations

---

### Task 8.2.2: Query Optimization (2h)

Optimize D1 queries for performance at scale.

#### Subtask 8.2.2.1: Index Analysis and Creation (1h)

```sql
-- Additional indexes for common query patterns

-- Feedback listing with filters
CREATE INDEX IF NOT EXISTS idx_feedback_workspace_status
ON feedback_items(workspace_id, status, moderation_state, is_hidden);

-- Feedback by category for analytics
CREATE INDEX IF NOT EXISTS idx_feedback_category
ON feedback_items(board_id, category, created_at DESC);

-- Vote aggregation
CREATE INDEX IF NOT EXISTS idx_votes_feedback_weight
ON feedback_votes(feedback_id, weight);

-- User activity lookup
CREATE INDEX IF NOT EXISTS idx_feedback_user
ON feedback_items(user_id, created_at DESC);

-- Theme clustering
CREATE INDEX IF NOT EXISTS idx_themes_workspace_active
ON themes(workspace_id, is_active, item_count DESC);

-- Roadmap public access
CREATE INDEX IF NOT EXISTS idx_roadmap_items_public
ON roadmap_items(roadmap_id, is_public, phase_id, priority DESC);

-- Comments threading
CREATE INDEX IF NOT EXISTS idx_comments_thread
ON feedback_comments(feedback_id, parent_id, created_at);

-- Analytics time series
CREATE INDEX IF NOT EXISTS idx_feedback_analytics
ON feedback_items(workspace_id, created_at, status, category);

-- Deduplication lookups
CREATE INDEX IF NOT EXISTS idx_duplicates_parent
ON duplicate_groups(parent_id, is_active);
```

#### Subtask 8.2.2.2: Query Optimization Patterns (1h)

```typescript
// src/lib/queries.ts

// Optimized feedback list with single query
export async function getFeedbackWithVotes(
  db: D1Database,
  boardId: number,
  page: number,
  limit: number,
  sort: 'vote_count' | 'created_at' | 'updated_at'
): Promise<FeedbackWithVotes[]> {
  const offset = (page - 1) * limit;

  // Use CTE for better query planning
  const query = `
    WITH vote_counts AS (
      SELECT
        feedback_id,
        COALESCE(SUM(weight), 0) as vote_count
      FROM feedback_votes
      GROUP BY feedback_id
    )
    SELECT
      f.id,
      f.title,
      f.description,
      f.status,
      f.category,
      f.created_at,
      f.updated_at,
      COALESCE(v.vote_count, 0) as vote_count,
      u.name as author_name,
      u.email as author_email,
      (
        SELECT COUNT(*)
        FROM feedback_comments c
        WHERE c.feedback_id = f.id AND c.is_internal = 0
      ) as comment_count
    FROM feedback_items f
    LEFT JOIN vote_counts v ON v.feedback_id = f.id
    LEFT JOIN end_users u ON u.id = f.user_id
    WHERE f.board_id = ?
      AND f.is_hidden = 0
      AND f.moderation_state = 'approved'
    ORDER BY ${sort === 'vote_count' ? 'COALESCE(v.vote_count, 0) DESC' : `f.${sort} DESC`}
    LIMIT ? OFFSET ?
  `;

  const result = await db.prepare(query)
    .bind(boardId, limit, offset)
    .all();

  return result.results as FeedbackWithVotes[];
}

// Batch vote check for multiple items
export async function getUserVotesForItems(
  db: D1Database,
  userId: number,
  feedbackIds: number[]
): Promise<Map<number, number>> {
  if (feedbackIds.length === 0) return new Map();

  const placeholders = feedbackIds.map(() => '?').join(',');
  const query = `
    SELECT feedback_id, weight
    FROM feedback_votes
    WHERE user_id = ?
      AND feedback_id IN (${placeholders})
  `;

  const result = await db.prepare(query)
    .bind(userId, ...feedbackIds)
    .all();

  return new Map(
    result.results.map((r: any) => [r.feedback_id, r.weight])
  );
}

// Pagination with cursor for large datasets
export async function getFeedbackCursor(
  db: D1Database,
  boardId: number,
  cursor: string | null,
  limit: number
): Promise<{ items: FeedbackItem[]; nextCursor: string | null }> {
  let query = `
    SELECT id, title, description, status, created_at, vote_count
    FROM feedback_items_view
    WHERE board_id = ?
      AND is_hidden = 0
      AND moderation_state = 'approved'
  `;

  const params: any[] = [boardId];

  if (cursor) {
    // Cursor format: "vote_count:id" for vote-sorted pagination
    const [voteCount, id] = cursor.split(':');
    query += ` AND (vote_count < ? OR (vote_count = ? AND id < ?))`;
    params.push(parseInt(voteCount), parseInt(voteCount), parseInt(id));
  }

  query += ` ORDER BY vote_count DESC, id DESC LIMIT ?`;
  params.push(limit + 1); // Fetch one extra to detect next page

  const result = await db.prepare(query).bind(...params).all();
  const items = result.results as FeedbackItem[];

  let nextCursor: string | null = null;
  if (items.length > limit) {
    const lastItem = items.pop()!;
    nextCursor = `${lastItem.vote_count}:${lastItem.id}`;
  }

  return { items, nextCursor };
}
```

**Acceptance Criteria**:
- [ ] All critical indexes created
- [ ] Query execution plans reviewed
- [ ] Batch queries for related data
- [ ] Cursor pagination for large lists

---

### Task 8.2.3: CDN Configuration (2h)

Configure Cloudflare CDN for optimal global delivery.

#### Subtask 8.2.3.1: Page Rules and Caching (1h)

```typescript
// wrangler.toml additions for caching
// Note: Actual page rules configured in Cloudflare dashboard

// src/lib/cdn.ts
export function getCdnHeaders(
  contentType: 'static' | 'api' | 'dynamic',
  options?: { private?: boolean; maxAge?: number }
): Headers {
  const headers = new Headers();

  switch (contentType) {
    case 'static':
      // Widget JS, CSS - long cache with immutable
      headers.set('Cache-Control', 'public, max-age=31536000, immutable');
      headers.set('CDN-Cache-Control', 'max-age=31536000');
      break;

    case 'api':
      // API responses - short cache, revalidate
      const maxAge = options?.maxAge ?? 60;
      if (options?.private) {
        headers.set('Cache-Control', `private, max-age=${maxAge}`);
      } else {
        headers.set('Cache-Control', `public, max-age=${maxAge}, stale-while-revalidate=300`);
        headers.set('CDN-Cache-Control', `max-age=${maxAge}`);
      }
      break;

    case 'dynamic':
      // User-specific content - no cache
      headers.set('Cache-Control', 'private, no-cache, no-store, must-revalidate');
      break;
  }

  return headers;
}

// Widget script with versioned URL for cache busting
export function getWidgetUrl(version: string): string {
  return `/widget.${version}.js`;
}

// Serve widget with proper caching
export async function serveWidget(
  request: Request,
  env: Env
): Promise<Response> {
  const url = new URL(request.url);
  const isVersioned = /widget\.\w+\.js$/.test(url.pathname);

  const response = new Response(WIDGET_JS, {
    headers: {
      'Content-Type': 'application/javascript',
      ...Object.fromEntries(getCdnHeaders(isVersioned ? 'static' : 'api', { maxAge: 3600 })),
    },
  });

  return response;
}
```

#### Subtask 8.2.3.2: Asset Optimization (1h)

```typescript
// src/lib/assets.ts
import { gzip } from 'pako';

// Pre-compress static assets at build time
const WIDGET_JS_GZIP = gzip(WIDGET_JS);
const WIDGET_JS_BROTLI = await compress(WIDGET_JS, 'br');

export async function serveCompressedAsset(
  request: Request,
  asset: { raw: string; gzip: Uint8Array; brotli?: Uint8Array },
  contentType: string
): Promise<Response> {
  const acceptEncoding = request.headers.get('Accept-Encoding') || '';

  let body: string | Uint8Array;
  let encoding: string | null = null;

  if (asset.brotli && acceptEncoding.includes('br')) {
    body = asset.brotli;
    encoding = 'br';
  } else if (acceptEncoding.includes('gzip')) {
    body = asset.gzip;
    encoding = 'gzip';
  } else {
    body = asset.raw;
  }

  const headers = new Headers(getCdnHeaders('static'));
  headers.set('Content-Type', contentType);
  if (encoding) {
    headers.set('Content-Encoding', encoding);
  }
  headers.set('Vary', 'Accept-Encoding');

  return new Response(body, { headers });
}

// Image optimization via Cloudflare Images
export function getOptimizedImageUrl(
  imageUrl: string,
  options: { width?: number; height?: number; format?: 'auto' | 'webp' | 'avif' }
): string {
  const params = new URLSearchParams();
  if (options.width) params.set('width', options.width.toString());
  if (options.height) params.set('height', options.height.toString());
  if (options.format) params.set('format', options.format);

  // Cloudflare Image Resizing URL format
  return `/cdn-cgi/image/${params.toString()}/${imageUrl}`;
}
```

**Acceptance Criteria**:
- [ ] Static assets cached for 1 year
- [ ] Brotli/gzip compression enabled
- [ ] CDN headers properly set
- [ ] Image optimization configured

---

### Task 8.2.4: Load Testing (2h)

Validate performance under load with comprehensive testing.

#### Subtask 8.2.4.1: Load Test Scripts (1h)

```typescript
// tests/load/k6-feedback.ts
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

const errorRate = new Rate('errors');
const feedbackListTrend = new Trend('feedback_list_duration');
const feedbackCreateTrend = new Trend('feedback_create_duration');
const voteTrend = new Trend('vote_duration');

export const options = {
  stages: [
    { duration: '1m', target: 50 },   // Ramp up
    { duration: '3m', target: 100 },  // Sustained load
    { duration: '1m', target: 200 },  // Peak load
    { duration: '1m', target: 0 },    // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95% under 500ms
    errors: ['rate<0.01'],              // Error rate under 1%
    feedback_list_duration: ['p(95)<100'],
    feedback_create_duration: ['p(95)<300'],
    vote_duration: ['p(95)<200'],
  },
};

const BASE_URL = __ENV.API_URL || 'https://feedback.example.com';
const WORKSPACE = 'load-test';
const BOARD = 'main';

export function setup() {
  // Create test workspace/board
  const res = http.post(
    `${BASE_URL}/api/v1/${WORKSPACE}/${BOARD}/feedback`,
    JSON.stringify({
      title: 'Setup item',
      description: 'Created during load test setup',
      externalUserId: 'setup-user',
    }),
    { headers: { 'Content-Type': 'application/json' } }
  );

  return { feedbackId: JSON.parse(res.body as string).id };
}

export default function (data: { feedbackId: number }) {
  const userId = `user-${__VU}-${__ITER}`;

  // Scenario 1: List feedback (most common)
  const listRes = http.get(
    `${BASE_URL}/api/v1/${WORKSPACE}/${BOARD}/feedback`
  );
  feedbackListTrend.add(listRes.timings.duration);
  check(listRes, {
    'list status 200': (r) => r.status === 200,
    'list has items': (r) => JSON.parse(r.body as string).length > 0,
  }) || errorRate.add(1);

  sleep(1);

  // Scenario 2: Create feedback (less common)
  if (Math.random() < 0.1) { // 10% of users create feedback
    const createRes = http.post(
      `${BASE_URL}/api/v1/${WORKSPACE}/${BOARD}/feedback`,
      JSON.stringify({
        title: `Load test feedback from ${userId}`,
        description: 'This is a load test submission',
        externalUserId: userId,
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
    feedbackCreateTrend.add(createRes.timings.duration);
    check(createRes, {
      'create status 201': (r) => r.status === 201,
    }) || errorRate.add(1);
  }

  sleep(0.5);

  // Scenario 3: Vote on feedback
  if (Math.random() < 0.3) { // 30% of users vote
    const voteRes = http.post(
      `${BASE_URL}/api/v1/${WORKSPACE}/${BOARD}/feedback/${data.feedbackId}/votes`,
      JSON.stringify({ externalUserId: userId }),
      { headers: { 'Content-Type': 'application/json' } }
    );
    voteTrend.add(voteRes.timings.duration);
    check(voteRes, {
      'vote status 2xx': (r) => r.status >= 200 && r.status < 300,
    }) || errorRate.add(1);
  }

  sleep(1);
}

export function teardown(data: { feedbackId: number }) {
  // Cleanup could be added here
  console.log('Load test completed');
}
```

#### Subtask 8.2.4.2: Performance Monitoring Dashboard (1h)

```typescript
// src/lib/metrics.ts
interface PerformanceMetric {
  endpoint: string;
  method: string;
  duration: number;
  status: number;
  timestamp: number;
  colo: string;
  cached: boolean;
}

export async function recordMetric(
  env: Env,
  metric: PerformanceMetric
): Promise<void> {
  // Send to analytics endpoint (Cloudflare Analytics Engine)
  const datapoint = {
    blobs: [metric.endpoint, metric.method, metric.colo],
    doubles: [metric.duration, metric.status],
    indexes: [metric.cached ? 'cached' : 'uncached'],
  };

  env.ANALYTICS?.writeDataPoint(datapoint);
}

// Middleware to track request performance
export function withMetrics(
  handler: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>
) {
  return async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {
    const start = Date.now();
    const url = new URL(request.url);

    try {
      const response = await handler(request, env, ctx);

      const metric: PerformanceMetric = {
        endpoint: url.pathname,
        method: request.method,
        duration: Date.now() - start,
        status: response.status,
        timestamp: start,
        colo: request.cf?.colo as string || 'unknown',
        cached: response.headers.get('X-Cache') === 'HIT',
      };

      ctx.waitUntil(recordMetric(env, metric));

      // Add timing header
      const headers = new Headers(response.headers);
      headers.set('Server-Timing', `total;dur=${metric.duration}`);

      return new Response(response.body, {
        status: response.status,
        headers,
      });
    } catch (error) {
      const duration = Date.now() - start;
      ctx.waitUntil(recordMetric(env, {
        endpoint: url.pathname,
        method: request.method,
        duration,
        status: 500,
        timestamp: start,
        colo: request.cf?.colo as string || 'unknown',
        cached: false,
      }));
      throw error;
    }
  };
}

// Performance query for dashboard
export async function getPerformanceStats(
  env: Env,
  timeRange: '1h' | '24h' | '7d'
): Promise<{
  p50: number;
  p95: number;
  p99: number;
  errorRate: number;
  cacheHitRate: number;
  requestCount: number;
}> {
  // Query Cloudflare Analytics Engine
  const query = `
    SELECT
      quantile(0.5, double1) as p50,
      quantile(0.95, double1) as p95,
      quantile(0.99, double1) as p99,
      countIf(double2 >= 500) / count() as error_rate,
      countIf(index1 = 'cached') / count() as cache_hit_rate,
      count() as request_count
    FROM performance_metrics
    WHERE timestamp >= now() - interval '${timeRange}'
  `;

  // Execute query against Analytics Engine
  const result = await env.ANALYTICS?.query(query);
  return result?.data?.[0] || {
    p50: 0, p95: 0, p99: 0, errorRate: 0, cacheHitRate: 0, requestCount: 0
  };
}
```

**Acceptance Criteria**:
- [ ] k6 load test scripts created
- [ ] P95 < 500ms under 200 concurrent users
- [ ] Error rate < 1% under load
- [ ] Performance metrics collected

---

## Definition of Done

- [ ] Edge caching implemented for hot endpoints
- [ ] All critical database indexes created
- [ ] CDN properly configured with compression
- [ ] Load tests passing performance thresholds
- [ ] Performance monitoring dashboard functional
- [ ] Documentation updated with performance guidelines

---

## Technical Notes

### Cache Invalidation Strategy
- Use cache tags for targeted invalidation
- Invalidate on write operations (create, update, delete, vote)
- Consider TTL-based expiration for less critical data

### D1 Performance Considerations
- D1 is optimized for read-heavy workloads
- Use prepared statements for all queries
- Batch related queries when possible
- Monitor query execution times

### Load Testing Environment
- Use dedicated load test workspace
- Run tests during off-peak hours
- Monitor Cloudflare dashboard during tests
- Compare results across regions

---

## Related Files

- `src/lib/cache.ts` - Cache utilities
- `src/lib/cdn.ts` - CDN headers
- `src/lib/metrics.ts` - Performance metrics
- `tests/load/` - Load test scripts
- `wrangler.toml` - Worker configuration
