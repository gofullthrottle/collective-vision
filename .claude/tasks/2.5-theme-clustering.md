# Epic 2.5: Theme Clustering

## Methodology Guidance
**SPECTRA Phase**: Implementation/AI Feature
**Approach**: Group similar feedback into themes using clustering
**Tools**: Cloudflare Vectorize, Workers, Claude API for naming

## Wave Context
**Wave**: 2 - AI Infrastructure + P0 Capabilities
**Priority**: P0 (enables insight discovery)
**Dependencies**: Epic 2.1 (vectors), Epic 2.2 (embeddings)
**Estimated Duration**: 8 hours

## Quality Requirements
- Themes meaningful and actionable
- 5-20 themes per active workspace
- Theme names descriptive and concise
- New feedback assigned quickly

---

## Tasks

### 2.5.1 Clustering Algorithm (2.5h)
**Objective**: Group feedback embeddings into coherent clusters

**Steps**:
1. Create themes table:
   ```sql
   CREATE TABLE feedback_themes (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     description TEXT,
     centroid TEXT,  -- JSON array of centroid vector
     item_count INTEGER DEFAULT 0,
     trend TEXT DEFAULT 'stable',  -- rising, falling, stable, new
     created_at TEXT DEFAULT (datetime('now')),
     updated_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   ALTER TABLE feedback_items ADD COLUMN theme_id TEXT REFERENCES feedback_themes(id);
   CREATE INDEX idx_feedback_theme ON feedback_items(theme_id);
   ```

2. Implement k-means clustering:
   ```typescript
   // src/lib/ai/clustering.ts

   interface ClusterResult {
     clusters: Array<{
       centroid: number[];
       memberIds: string[];
     }>;
     unclustered: string[];
   }

   export async function clusterFeedback(
     workspaceId: string,
     env: Env,
     options: { minClusters?: number; maxClusters?: number } = {}
   ): Promise<ClusterResult> {
     const { minClusters = 3, maxClusters = 15 } = options;

     // Fetch all embeddings for workspace
     const feedback = await env.DB.prepare(`
       SELECT fi.id, fi.ai_embedding_id
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?
         AND fi.ai_embedding_id IS NOT NULL
         AND fi.is_hidden = 0
     `).bind(workspaceId).all();

     if (feedback.results.length < minClusters * 2) {
       return { clusters: [], unclustered: feedback.results.map(f => f.id) };
     }

     // Get vectors from Vectorize
     const vectors: Map<string, number[]> = new Map();
     for (const item of feedback.results) {
       const result = await env.VECTORIZE.getByIds([item.id]);
       if (result[0]) {
         vectors.set(item.id, result[0].values);
       }
     }

     // Determine optimal k using elbow method (simplified)
     const k = Math.min(
       maxClusters,
       Math.max(minClusters, Math.floor(vectors.size / 10))
     );

     // Run k-means
     const clusters = kMeans(Array.from(vectors.entries()), k);

     return {
       clusters: clusters.map(c => ({
         centroid: c.centroid,
         memberIds: c.members.map(m => m[0])
       })),
       unclustered: []
     };
   }

   function kMeans(
     data: Array<[string, number[]]>,
     k: number,
     maxIterations = 50
   ): Array<{ centroid: number[]; members: Array<[string, number[]]> }> {
     const dimensions = data[0][1].length;

     // Initialize centroids randomly
     let centroids = data
       .sort(() => Math.random() - 0.5)
       .slice(0, k)
       .map(d => [...d[1]]);

     let clusters: Array<{ centroid: number[]; members: Array<[string, number[]]> }> = [];

     for (let iter = 0; iter < maxIterations; iter++) {
       // Assign points to nearest centroid
       clusters = centroids.map(c => ({ centroid: c, members: [] }));

       for (const [id, vector] of data) {
         let nearestIdx = 0;
         let nearestDist = Infinity;

         for (let i = 0; i < centroids.length; i++) {
           const dist = cosineSimilarity(vector, centroids[i]);
           if (dist < nearestDist) {
             nearestDist = dist;
             nearestIdx = i;
           }
         }

         clusters[nearestIdx].members.push([id, vector]);
       }

       // Update centroids
       const newCentroids = clusters.map(c => {
         if (c.members.length === 0) return c.centroid;
         return c.members[0][1].map((_, dim) =>
           c.members.reduce((sum, m) => sum + m[1][dim], 0) / c.members.length
         );
       });

       // Check convergence
       const converged = centroids.every((c, i) =>
         c.every((v, j) => Math.abs(v - newCentroids[i][j]) < 0.0001)
       );

       centroids = newCentroids;
       if (converged) break;
     }

     return clusters.filter(c => c.members.length > 0);
   }
   ```

3. Handle incremental updates:
   ```typescript
   export async function assignToExistingTheme(
     feedbackId: string,
     embedding: number[],
     workspaceId: string,
     env: Env
   ): Promise<string | null> {
     const SIMILARITY_THRESHOLD = 0.75;

     // Get existing theme centroids
     const themes = await env.DB.prepare(`
       SELECT id, centroid FROM feedback_themes
       WHERE workspace_id = ?
     `).bind(workspaceId).all();

     if (themes.results.length === 0) return null;

     let bestTheme: { id: string; score: number } | null = null;

     for (const theme of themes.results) {
       const centroid = JSON.parse(theme.centroid as string) as number[];
       const similarity = cosineSimilarity(embedding, centroid);

       if (similarity >= SIMILARITY_THRESHOLD &&
           (!bestTheme || similarity > bestTheme.score)) {
         bestTheme = { id: theme.id, score: similarity };
       }
     }

     if (bestTheme) {
       await env.DB.prepare(`
         UPDATE feedback_items SET theme_id = ? WHERE id = ?
       `).bind(bestTheme.id, feedbackId).run();

       await updateThemeStats(bestTheme.id, env);
       return bestTheme.id;
     }

     return null;
   }
   ```

**Acceptance Criteria**:
- [ ] K-means generates meaningful clusters
- [ ] 5-15 themes for typical workspace
- [ ] Handles 1000+ items efficiently
- [ ] Incremental assignment for new items

---

### 2.5.2 Theme Naming with LLM (1.5h)
**Objective**: Generate descriptive names for clusters

**Steps**:
1. Create theme naming prompt:
   ```typescript
   // src/lib/ai/prompts/theme-naming.ts

   export const THEME_NAMING_PROMPT = `Generate a theme name and description for this group of user feedback.

   ## Sample Feedback Items
   {samples}

   ## Requirements
   - Name: 3-5 words, descriptive, action-oriented
   - Description: 1 sentence explaining the common thread

   ## Response Format
   Return ONLY valid JSON:
   {
     "name": "Short Theme Name",
     "description": "One sentence describing what users in this group want or are experiencing."
   }`;

   export function buildThemeNamingPrompt(samples: string[]): string {
     const sampleText = samples
       .slice(0, 5)
       .map((s, i) => `${i + 1}. ${s}`)
       .join('\n');

     return THEME_NAMING_PROMPT.replace('{samples}', sampleText);
   }
   ```

2. Generate theme names:
   ```typescript
   // src/lib/ai/theme-naming.ts

   interface ThemeNaming {
     name: string;
     description: string;
   }

   export async function generateThemeName(
     memberIds: string[],
     env: Env
   ): Promise<ThemeNaming> {
     // Get sample titles from cluster members
     const samples = await env.DB.prepare(`
       SELECT title FROM feedback_items
       WHERE id IN (${memberIds.slice(0, 10).map(() => '?').join(',')})
     `).bind(...memberIds.slice(0, 10)).all();

     const sampleTitles = samples.results.map(s => s.title as string);
     const prompt = buildThemeNamingPrompt(sampleTitles);

     const result = await callClaudeAPI(prompt, env);

     try {
       return JSON.parse(result) as ThemeNaming;
     } catch (e) {
       // Fallback to generic name
       return {
         name: `Theme ${Date.now().toString(36)}`,
         description: 'Automatically generated theme'
       };
     }
   }
   ```

3. Create themes from clusters:
   ```typescript
   export async function createThemesFromClusters(
     workspaceId: string,
     clusterResult: ClusterResult,
     env: Env
   ): Promise<void> {
     for (const cluster of clusterResult.clusters) {
       if (cluster.memberIds.length < 2) continue;

       // Generate name
       const naming = await generateThemeName(cluster.memberIds, env);
       const themeId = generateId('theme');

       // Create theme
       await env.DB.prepare(`
         INSERT INTO feedback_themes
           (id, workspace_id, name, description, centroid, item_count)
         VALUES (?, ?, ?, ?, ?, ?)
       `).bind(
         themeId,
         workspaceId,
         naming.name,
         naming.description,
         JSON.stringify(cluster.centroid),
         cluster.memberIds.length
       ).run();

       // Assign members
       for (const memberId of cluster.memberIds) {
         await env.DB.prepare(`
           UPDATE feedback_items SET theme_id = ? WHERE id = ?
         `).bind(themeId, memberId).run();
       }

       await incrementUsage(env.DB, workspaceId, 'llm_calls');
     }
   }
   ```

4. Auto-regenerate on significant changes:
   ```typescript
   export async function shouldRenameTheme(
     themeId: string,
     env: Env
   ): Promise<boolean> {
     const theme = await env.DB.prepare(`
       SELECT item_count, updated_at FROM feedback_themes WHERE id = ?
     `).bind(themeId).first();

     if (!theme) return false;

     const currentCount = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM feedback_items WHERE theme_id = ?
     `).bind(themeId).first();

     // Regenerate if count changed by 50%+
     const countChange = Math.abs(currentCount!.count - theme.item_count) / theme.item_count;
     return countChange > 0.5;
   }
   ```

**Acceptance Criteria**:
- [ ] Theme names are descriptive (3-5 words)
- [ ] Descriptions explain the theme
- [ ] Names regenerated on significant changes
- [ ] Fallback for parse failures

---

### 2.5.3 Theme Management (2h)
**Objective**: CRUD operations for themes

**Steps**:
1. List themes endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/themes
   async function handleListThemes(request: Request, env: Env) {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'feedback:view');

     const themes = await env.DB.prepare(`
       SELECT
         ft.*,
         COUNT(fi.id) as current_item_count,
         MAX(fi.created_at) as latest_item_at
       FROM feedback_themes ft
       LEFT JOIN feedback_items fi ON ft.id = fi.theme_id AND fi.is_hidden = 0
       WHERE ft.workspace_id = ?
       GROUP BY ft.id
       ORDER BY current_item_count DESC
     `).bind(workspaceId).all();

     return jsonResponse({ themes: themes.results });
   }
   ```

2. Get theme details:
   ```typescript
   // GET /api/v1/themes/:id
   async function handleGetTheme(request: Request, env: Env) {
     const { themeId } = parseParams(request);

     const theme = await env.DB.prepare(`
       SELECT * FROM feedback_themes WHERE id = ?
     `).bind(themeId).first();

     if (!theme) return errorResponse('NOT_FOUND', 'Theme not found', 404);

     await requirePermission(request, env, theme.workspace_id as string, 'feedback:view');

     // Get theme items
     const items = await env.DB.prepare(`
       SELECT fi.*, COALESCE(fi.vote_count, 0) as vote_count
       FROM feedback_items fi
       WHERE fi.theme_id = ? AND fi.is_hidden = 0
       ORDER BY fi.priority_score DESC
       LIMIT 50
     `).bind(themeId).all();

     return jsonResponse({
       theme,
       items: items.results
     });
   }
   ```

3. Update theme:
   ```typescript
   // PATCH /api/v1/themes/:id
   async function handleUpdateTheme(request: Request, env: Env) {
     const { themeId } = parseParams(request);
     const { name, description } = await validateBody(request, z.object({
       name: z.string().min(1).max(100).optional(),
       description: z.string().max(500).optional()
     }));

     const theme = await env.DB.prepare(
       'SELECT workspace_id FROM feedback_themes WHERE id = ?'
     ).bind(themeId).first();

     if (!theme) return errorResponse('NOT_FOUND', 'Theme not found', 404);

     await requirePermission(request, env, theme.workspace_id as string, 'feedback:moderate');

     await env.DB.prepare(`
       UPDATE feedback_themes
       SET name = COALESCE(?, name), description = COALESCE(?, description),
           updated_at = datetime('now')
       WHERE id = ?
     `).bind(name, description, themeId).run();

     return jsonResponse({ message: 'Theme updated' });
   }
   ```

4. Merge themes:
   ```typescript
   // POST /api/v1/themes/:id/merge
   async function handleMergeThemes(request: Request, env: Env) {
     const { themeId } = parseParams(request);
     const { merge_into } = await validateBody(request, z.object({
       merge_into: z.string()
     }));

     const sourceTheme = await getTheme(themeId, env);
     const targetTheme = await getTheme(merge_into, env);

     if (!sourceTheme || !targetTheme) {
       return errorResponse('NOT_FOUND', 'Theme not found', 404);
     }

     await requirePermission(request, env, sourceTheme.workspace_id, 'feedback:moderate');

     // Move all items to target theme
     await env.DB.prepare(`
       UPDATE feedback_items SET theme_id = ? WHERE theme_id = ?
     `).bind(merge_into, themeId).run();

     // Delete source theme
     await env.DB.prepare(
       'DELETE FROM feedback_themes WHERE id = ?'
     ).bind(themeId).run();

     // Update target theme stats
     await updateThemeStats(merge_into, env);

     return jsonResponse({ merged_into: merge_into });
   }
   ```

5. Delete theme:
   ```typescript
   // DELETE /api/v1/themes/:id
   async function handleDeleteTheme(request: Request, env: Env) {
     const { themeId } = parseParams(request);

     const theme = await getTheme(themeId, env);
     if (!theme) return errorResponse('NOT_FOUND', 'Theme not found', 404);

     await requirePermission(request, env, theme.workspace_id, 'feedback:moderate');

     // Unassign items (they become unthemed)
     await env.DB.prepare(`
       UPDATE feedback_items SET theme_id = NULL WHERE theme_id = ?
     `).bind(themeId).run();

     // Delete theme
     await env.DB.prepare(
       'DELETE FROM feedback_themes WHERE id = ?'
     ).bind(themeId).run();

     return jsonResponse({ message: 'Theme deleted' });
   }
   ```

**Acceptance Criteria**:
- [ ] List all themes with item counts
- [ ] View theme with associated items
- [ ] Rename and update descriptions
- [ ] Merge themes preserves items
- [ ] Delete unassigns items

---

### 2.5.4 Theme UI in Admin (1.5h)
**Objective**: Visualize themes and trends

**Steps**:
1. Theme overview data:
   ```typescript
   // GET /api/v1/workspaces/:id/themes/overview
   async function handleThemesOverview(request: Request, env: Env) {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     // Theme distribution
     const distribution = await env.DB.prepare(`
       SELECT
         ft.id,
         ft.name,
         COUNT(fi.id) as count,
         ft.trend
       FROM feedback_themes ft
       LEFT JOIN feedback_items fi ON ft.id = fi.theme_id AND fi.is_hidden = 0
       WHERE ft.workspace_id = ?
       GROUP BY ft.id
       ORDER BY count DESC
     `).bind(workspaceId).all();

     // Unthemed count
     const unthemed = await env.DB.prepare(`
       SELECT COUNT(*) as count
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND fi.theme_id IS NULL AND fi.is_hidden = 0
     `).bind(workspaceId).first();

     // Theme trends (last 7 days vs previous 7)
     const trendData = await calculateThemeTrends(workspaceId, env);

     return jsonResponse({
       distribution: distribution.results,
       unthemed_count: unthemed?.count || 0,
       trends: trendData
     });
   }
   ```

2. Calculate theme trends:
   ```typescript
   async function calculateThemeTrends(
     workspaceId: string,
     env: Env
   ): Promise<Array<{ theme_id: string; trend: 'rising' | 'falling' | 'stable' | 'new' }>> {
     const trends = await env.DB.prepare(`
       WITH recent AS (
         SELECT theme_id, COUNT(*) as count
         FROM feedback_items fi
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND fi.created_at >= datetime('now', '-7 days')
           AND fi.theme_id IS NOT NULL
         GROUP BY theme_id
       ),
       previous AS (
         SELECT theme_id, COUNT(*) as count
         FROM feedback_items fi
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND fi.created_at >= datetime('now', '-14 days')
           AND fi.created_at < datetime('now', '-7 days')
           AND fi.theme_id IS NOT NULL
         GROUP BY theme_id
       )
       SELECT
         ft.id as theme_id,
         COALESCE(r.count, 0) as recent_count,
         COALESCE(p.count, 0) as previous_count
       FROM feedback_themes ft
       LEFT JOIN recent r ON ft.id = r.theme_id
       LEFT JOIN previous p ON ft.id = p.theme_id
       WHERE ft.workspace_id = ?
     `).bind(workspaceId, workspaceId, workspaceId).all();

     return trends.results.map(t => {
       const recent = t.recent_count as number;
       const previous = t.previous_count as number;

       let trend: 'rising' | 'falling' | 'stable' | 'new';
       if (previous === 0 && recent > 0) {
         trend = 'new';
       } else if (recent > previous * 1.25) {
         trend = 'rising';
       } else if (recent < previous * 0.75) {
         trend = 'falling';
       } else {
         trend = 'stable';
       }

       return { theme_id: t.theme_id as string, trend };
     });
   }
   ```

3. Update theme trends in database:
   ```typescript
   export async function updateAllThemeTrends(
     workspaceId: string,
     env: Env
   ): Promise<void> {
     const trends = await calculateThemeTrends(workspaceId, env);

     for (const { theme_id, trend } of trends) {
       await env.DB.prepare(`
         UPDATE feedback_themes SET trend = ?, updated_at = datetime('now')
         WHERE id = ?
       `).bind(trend, theme_id).run();
     }
   }
   ```

**Acceptance Criteria**:
- [ ] Theme distribution chart data
- [ ] Unthemed items count
- [ ] Trend indicators (rising/falling/stable/new)
- [ ] Drill-down to theme items

---

### 2.5.5 Incremental Theme Assignment (0.5h)
**Objective**: Assign new feedback to themes quickly

**Steps**:
1. Integrate into AI processing pipeline:
   ```typescript
   // src/lib/ai/processors/theme.ts

   export async function processThemeAssignment(
     feedbackId: string,
     env: Env
   ): Promise<void> {
     const feedback = await getFeedbackById(feedbackId, env);
     if (!feedback || !feedback.ai_embedding_id) return;

     // Get embedding
     const vectors = await env.VECTORIZE.getByIds([feedbackId]);
     if (!vectors[0]) return;

     // Try to assign to existing theme
     const themeId = await assignToExistingTheme(
       feedbackId,
       vectors[0].values,
       feedback.workspace_id,
       env
     );

     if (!themeId) {
       // Mark as unthemed for next clustering run
       await env.DB.prepare(`
         UPDATE feedback_items
         SET theme_id = NULL, needs_theme_assignment = 1
         WHERE id = ?
       `).bind(feedbackId).run();
     }
   }
   ```

2. Schedule periodic re-clustering:
   ```typescript
   // Run weekly via cron trigger
   export async function scheduledReclustering(
     env: Env
   ): Promise<void> {
     // Get all workspaces with feedback
     const workspaces = await env.DB.prepare(`
       SELECT DISTINCT b.workspace_id
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE fi.created_at >= datetime('now', '-7 days')
     `).all();

     for (const ws of workspaces.results) {
       const workspaceId = ws.workspace_id as string;

       // Check if reclustering needed (significant unthemed items)
       const unthemed = await env.DB.prepare(`
         SELECT COUNT(*) as count
         FROM feedback_items fi
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ? AND fi.theme_id IS NULL AND fi.is_hidden = 0
       `).bind(workspaceId).first();

       if ((unthemed?.count || 0) > 10) {
         // Queue reclustering job
         await env.AI_QUEUE.send({
           type: 'recluster',
           workspaceId
         });
       }

       // Update trends
       await updateAllThemeTrends(workspaceId, env);
     }
   }
   ```

**Acceptance Criteria**:
- [ ] New items assigned to themes within seconds
- [ ] Unthemed items marked for next clustering
- [ ] Weekly reclustering scheduled
- [ ] Trends updated regularly

---

## Definition of Done
- [ ] Clustering generates 5-15 meaningful themes
- [ ] Themes have descriptive names and descriptions
- [ ] CRUD operations for theme management
- [ ] New feedback assigned incrementally
- [ ] Trends calculated and displayed
- [ ] Weekly reclustering scheduled

## Technical Notes
- K-means runs in Worker (limited CPU time)
- Consider moving clustering to Durable Object for long-running
- Centroid stored for incremental assignment
- Reclustering merges close themes automatically

## Related Files
- `src/lib/ai/clustering.ts` - Clustering algorithm
- `src/lib/ai/theme-naming.ts` - LLM naming
- `src/lib/ai/processors/theme.ts` - Theme assignment
- `src/routes/themes.ts` - Theme API endpoints
