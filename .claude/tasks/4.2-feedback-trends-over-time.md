# Epic 4.2: Feedback Trends Over Time

## Methodology Guidance
**SPECTRA Phase**: Implementation/Analytics
**Approach**: Build time-series analytics with trend detection
**Tools**: D1 aggregations, statistical algorithms

## Wave Context
**Wave**: 4 - Analytics & Integrations
**Priority**: P2 (enhances value prop)
**Dependencies**: Wave 1 (auth), Wave 2 (AI classification)
**Estimated Duration**: 5 hours

## Quality Requirements
- Daily aggregates computed reliably
- Trend detection statistically meaningful
- Comparison views accurate
- Charts render correctly

---

## Tasks

### 4.2.1 Time-Series Data Collection (1.5h)
**Objective**: Collect and store daily metrics

**Steps**:
1. Create metrics table:
   ```sql
   CREATE TABLE daily_metrics (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     board_id TEXT,  -- NULL for workspace-wide
     date TEXT NOT NULL,  -- YYYY-MM-DD
     -- Volume metrics
     new_feedback INTEGER DEFAULT 0,
     votes_cast INTEGER DEFAULT 0,
     comments_added INTEGER DEFAULT 0,
     -- Status distribution
     status_open INTEGER DEFAULT 0,
     status_under_review INTEGER DEFAULT 0,
     status_planned INTEGER DEFAULT 0,
     status_in_progress INTEGER DEFAULT 0,
     status_done INTEGER DEFAULT 0,
     status_declined INTEGER DEFAULT 0,
     -- Sentiment aggregates
     avg_sentiment REAL,
     sentiment_negative INTEGER DEFAULT 0,
     sentiment_neutral INTEGER DEFAULT 0,
     sentiment_positive INTEGER DEFAULT 0,
     -- Source distribution
     source_widget INTEGER DEFAULT 0,
     source_api INTEGER DEFAULT 0,
     source_mcp INTEGER DEFAULT 0,
     source_import INTEGER DEFAULT 0,
     -- Engagement
     unique_voters INTEGER DEFAULT 0,
     unique_submitters INTEGER DEFAULT 0,
     UNIQUE(workspace_id, board_id, date),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
     FOREIGN KEY (board_id) REFERENCES boards(id)
   );

   CREATE INDEX idx_daily_metrics_lookup ON daily_metrics(workspace_id, date);
   CREATE INDEX idx_daily_metrics_board ON daily_metrics(board_id, date);
   ```

2. Create metrics aggregation:
   ```typescript
   // src/lib/analytics/daily-metrics.ts

   export async function aggregateDailyMetrics(
     workspaceId: string,
     boardId: string | null,
     date: string,
     env: Env
   ): Promise<void> {
     const boardFilter = boardId ? 'AND fi.board_id = ?' : '';
     const params = boardId
       ? [workspaceId, date, boardId]
       : [workspaceId, date];

     // Volume metrics
     const volume = await env.DB.prepare(`
       SELECT
         COUNT(DISTINCT CASE WHEN DATE(fi.created_at) = ? THEN fi.id END) as new_feedback,
         COUNT(DISTINCT CASE WHEN DATE(fv.created_at) = ? THEN fv.id END) as votes_cast,
         COUNT(DISTINCT CASE WHEN DATE(fc.created_at) = ? THEN fc.id END) as comments_added
       FROM feedback_items fi
       LEFT JOIN feedback_votes fv ON fi.id = fv.feedback_id
       LEFT JOIN feedback_comments fc ON fi.id = fc.feedback_id
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? ${boardFilter}
     `).bind(date, date, date, ...params).first();

     // Status distribution (snapshot at end of day)
     const status = await env.DB.prepare(`
       SELECT
         SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as status_open,
         SUM(CASE WHEN status = 'under_review' THEN 1 ELSE 0 END) as status_under_review,
         SUM(CASE WHEN status = 'planned' THEN 1 ELSE 0 END) as status_planned,
         SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as status_in_progress,
         SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as status_done,
         SUM(CASE WHEN status = 'declined' THEN 1 ELSE 0 END) as status_declined
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND DATE(fi.created_at) <= ? ${boardFilter}
     `).bind(workspaceId, date, ...(boardId ? [boardId] : [])).first();

     // Sentiment for items created on date
     const sentiment = await env.DB.prepare(`
       SELECT
         AVG(fi.sentiment_score) as avg_sentiment,
         SUM(CASE WHEN fi.sentiment_score < -0.3 THEN 1 ELSE 0 END) as sentiment_negative,
         SUM(CASE WHEN fi.sentiment_score BETWEEN -0.3 AND 0.3 THEN 1 ELSE 0 END) as sentiment_neutral,
         SUM(CASE WHEN fi.sentiment_score > 0.3 THEN 1 ELSE 0 END) as sentiment_positive
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND DATE(fi.created_at) = ?
         AND fi.sentiment_score IS NOT NULL ${boardFilter}
     `).bind(workspaceId, date, ...(boardId ? [boardId] : [])).first();

     // Source distribution
     const sources = await env.DB.prepare(`
       SELECT
         SUM(CASE WHEN source = 'widget' THEN 1 ELSE 0 END) as source_widget,
         SUM(CASE WHEN source = 'api' THEN 1 ELSE 0 END) as source_api,
         SUM(CASE WHEN source = 'mcp' THEN 1 ELSE 0 END) as source_mcp,
         SUM(CASE WHEN source = 'import' THEN 1 ELSE 0 END) as source_import
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND DATE(fi.created_at) = ? ${boardFilter}
     `).bind(workspaceId, date, ...(boardId ? [boardId] : [])).first();

     // Unique engagement
     const engagement = await env.DB.prepare(`
       SELECT
         COUNT(DISTINCT fv.user_id) as unique_voters,
         COUNT(DISTINCT fi.user_id) as unique_submitters
       FROM feedback_items fi
       LEFT JOIN feedback_votes fv ON fi.id = fv.feedback_id AND DATE(fv.created_at) = ?
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND DATE(fi.created_at) = ? ${boardFilter}
     `).bind(date, workspaceId, date, ...(boardId ? [boardId] : [])).first();

     // Upsert metrics
     await env.DB.prepare(`
       INSERT INTO daily_metrics (
         id, workspace_id, board_id, date,
         new_feedback, votes_cast, comments_added,
         status_open, status_under_review, status_planned,
         status_in_progress, status_done, status_declined,
         avg_sentiment, sentiment_negative, sentiment_neutral, sentiment_positive,
         source_widget, source_api, source_mcp, source_import,
         unique_voters, unique_submitters
       ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(workspace_id, board_id, date) DO UPDATE SET
         new_feedback = excluded.new_feedback,
         votes_cast = excluded.votes_cast,
         comments_added = excluded.comments_added,
         status_open = excluded.status_open,
         status_under_review = excluded.status_under_review,
         status_planned = excluded.status_planned,
         status_in_progress = excluded.status_in_progress,
         status_done = excluded.status_done,
         status_declined = excluded.status_declined,
         avg_sentiment = excluded.avg_sentiment,
         sentiment_negative = excluded.sentiment_negative,
         sentiment_neutral = excluded.sentiment_neutral,
         sentiment_positive = excluded.sentiment_positive,
         source_widget = excluded.source_widget,
         source_api = excluded.source_api,
         source_mcp = excluded.source_mcp,
         source_import = excluded.source_import,
         unique_voters = excluded.unique_voters,
         unique_submitters = excluded.unique_submitters
     `).bind(
       generateId('dm'),
       workspaceId,
       boardId,
       date,
       volume?.new_feedback || 0,
       volume?.votes_cast || 0,
       volume?.comments_added || 0,
       status?.status_open || 0,
       status?.status_under_review || 0,
       status?.status_planned || 0,
       status?.status_in_progress || 0,
       status?.status_done || 0,
       status?.status_declined || 0,
       sentiment?.avg_sentiment,
       sentiment?.sentiment_negative || 0,
       sentiment?.sentiment_neutral || 0,
       sentiment?.sentiment_positive || 0,
       sources?.source_widget || 0,
       sources?.source_api || 0,
       sources?.source_mcp || 0,
       sources?.source_import || 0,
       engagement?.unique_voters || 0,
       engagement?.unique_submitters || 0
     ).run();
   }
   ```

**Acceptance Criteria**:
- [ ] Metrics computed daily
- [ ] Both workspace and board level
- [ ] Historical data preserved

---

### 4.2.2 Trend Detection Algorithm (1.5h)
**Objective**: Detect statistically significant trends

**Steps**:
1. Implement trend detection:
   ```typescript
   // src/lib/analytics/trends.ts

   interface TrendResult {
     direction: 'rising' | 'stable' | 'falling';
     change_percent: number;
     is_significant: boolean;
     z_score: number;
   }

   function calculateMean(values: number[]): number {
     if (values.length === 0) return 0;
     return values.reduce((a, b) => a + b, 0) / values.length;
   }

   function calculateStdDev(values: number[]): number {
     if (values.length < 2) return 0;
     const mean = calculateMean(values);
     const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
     return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / (values.length - 1));
   }

   export function detectTrend(
     currentPeriod: number[],
     previousPeriod: number[]
   ): TrendResult {
     const currentMean = calculateMean(currentPeriod);
     const previousMean = calculateMean(previousPeriod);

     // Calculate change
     let changePercent = 0;
     if (previousMean > 0) {
       changePercent = ((currentMean - previousMean) / previousMean) * 100;
     } else if (currentMean > 0) {
       changePercent = 100;  // From zero to something
     }

     // Calculate z-score for significance
     const allValues = [...currentPeriod, ...previousPeriod];
     const overallStdDev = calculateStdDev(allValues);

     let zScore = 0;
     if (overallStdDev > 0) {
       const seDiff = overallStdDev * Math.sqrt(
         1 / currentPeriod.length + 1 / previousPeriod.length
       );
       zScore = (currentMean - previousMean) / seDiff;
     }

     const isSignificant = Math.abs(zScore) > 1.96;  // 95% confidence

     let direction: 'rising' | 'stable' | 'falling' = 'stable';
     if (changePercent > 20 || (isSignificant && changePercent > 0)) {
       direction = 'rising';
     } else if (changePercent < -20 || (isSignificant && changePercent < 0)) {
       direction = 'falling';
     }

     return {
       direction,
       change_percent: Math.round(changePercent * 10) / 10,
       is_significant: isSignificant,
       z_score: Math.round(zScore * 100) / 100
     };
   }

   export function detectAnomaly(
     value: number,
     historicalValues: number[]
   ): { is_anomaly: boolean; z_score: number; severity: 'low' | 'medium' | 'high' } {
     const mean = calculateMean(historicalValues);
     const stdDev = calculateStdDev(historicalValues);

     if (stdDev === 0) {
       return { is_anomaly: false, z_score: 0, severity: 'low' };
     }

     const zScore = (value - mean) / stdDev;
     const absZ = Math.abs(zScore);

     let severity: 'low' | 'medium' | 'high' = 'low';
     if (absZ > 3) severity = 'high';
     else if (absZ > 2) severity = 'medium';

     return {
       is_anomaly: absZ > 2,
       z_score: Math.round(zScore * 100) / 100,
       severity
     };
   }
   ```

2. Create trends endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/analytics/trends
   async function handleGetTrends(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     const url = new URL(request.url);
     const boardId = url.searchParams.get('board_id');
     const metric = url.searchParams.get('metric') || 'new_feedback';

     // Get last 14 days of data
     const metrics = await env.DB.prepare(`
       SELECT date, ${metric} as value
       FROM daily_metrics
       WHERE workspace_id = ? AND (board_id = ? OR (? IS NULL AND board_id IS NULL))
       ORDER BY date DESC
       LIMIT 14
     `).bind(workspaceId, boardId, boardId).all();

     const values = metrics.results.map(r => r.value as number).reverse();
     const currentPeriod = values.slice(-7);
     const previousPeriod = values.slice(0, 7);

     const trend = detectTrend(currentPeriod, previousPeriod);

     // Check for anomalies in recent data
     const todayValue = currentPeriod[currentPeriod.length - 1];
     const historicalForAnomaly = values.slice(0, -1);
     const anomaly = detectAnomaly(todayValue, historicalForAnomaly);

     return jsonResponse({
       metric,
       trend,
       anomaly,
       data_points: metrics.results.map(r => ({
         date: r.date,
         value: r.value
       })).reverse()
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Trend detection statistically valid
- [ ] Anomalies flagged with z-score
- [ ] False positives minimized

---

### 4.2.3 Comparison Views (1h)
**Objective**: Compare metrics across time periods

**Steps**:
1. Create comparison endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/analytics/compare
   async function handleCompare(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     const url = new URL(request.url);
     const period = url.searchParams.get('period') || 'week';
     const boardId = url.searchParams.get('board_id');

     let currentStart: string, currentEnd: string;
     let previousStart: string, previousEnd: string;

     const today = new Date();

     if (period === 'week') {
       const weekAgo = new Date(today);
       weekAgo.setDate(weekAgo.getDate() - 7);
       const twoWeeksAgo = new Date(today);
       twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

       currentEnd = today.toISOString().split('T')[0];
       currentStart = weekAgo.toISOString().split('T')[0];
       previousEnd = weekAgo.toISOString().split('T')[0];
       previousStart = twoWeeksAgo.toISOString().split('T')[0];
     } else if (period === 'month') {
       const monthAgo = new Date(today);
       monthAgo.setMonth(monthAgo.getMonth() - 1);
       const twoMonthsAgo = new Date(today);
       twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);

       currentEnd = today.toISOString().split('T')[0];
       currentStart = monthAgo.toISOString().split('T')[0];
       previousEnd = monthAgo.toISOString().split('T')[0];
       previousStart = twoMonthsAgo.toISOString().split('T')[0];
     } else {
       return errorResponse('INVALID_PARAMETER', 'Invalid period', 400);
     }

     const boardFilter = boardId
       ? 'AND board_id = ?'
       : 'AND board_id IS NULL';
     const params = boardId ? [boardId] : [];

     const current = await env.DB.prepare(`
       SELECT
         SUM(new_feedback) as feedback,
         SUM(votes_cast) as votes,
         SUM(comments_added) as comments,
         AVG(avg_sentiment) as sentiment
       FROM daily_metrics
       WHERE workspace_id = ? AND date BETWEEN ? AND ? ${boardFilter}
     `).bind(workspaceId, currentStart, currentEnd, ...params).first();

     const previous = await env.DB.prepare(`
       SELECT
         SUM(new_feedback) as feedback,
         SUM(votes_cast) as votes,
         SUM(comments_added) as comments,
         AVG(avg_sentiment) as sentiment
       FROM daily_metrics
       WHERE workspace_id = ? AND date BETWEEN ? AND ? ${boardFilter}
     `).bind(workspaceId, previousStart, previousEnd, ...params).first();

     const calculateChange = (curr: number, prev: number): string => {
       if (prev === 0) return curr > 0 ? '+100%' : '0%';
       const change = ((curr - prev) / prev) * 100;
       return `${change >= 0 ? '+' : ''}${Math.round(change)}%`;
     };

     return jsonResponse({
       period,
       current: {
         period: { start: currentStart, end: currentEnd },
         feedback: current?.feedback || 0,
         votes: current?.votes || 0,
         comments: current?.comments || 0,
         sentiment: current?.sentiment ? Math.round(current.sentiment * 100) / 100 : null
       },
       previous: {
         period: { start: previousStart, end: previousEnd },
         feedback: previous?.feedback || 0,
         votes: previous?.votes || 0,
         comments: previous?.comments || 0,
         sentiment: previous?.sentiment ? Math.round(previous.sentiment * 100) / 100 : null
       },
       change: {
         feedback: calculateChange(current?.feedback || 0, previous?.feedback || 0),
         votes: calculateChange(current?.votes || 0, previous?.votes || 0),
         comments: calculateChange(current?.comments || 0, previous?.comments || 0)
       }
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Week-over-week comparison
- [ ] Month-over-month comparison
- [ ] Percentage changes accurate

---

### 4.2.4 Trend Visualization Data (1h)
**Objective**: Provide data formatted for charts

**Steps**:
1. Create time series endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/analytics/timeseries
   async function handleTimeSeries(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     const url = new URL(request.url);
     const boardId = url.searchParams.get('board_id');
     const metrics = url.searchParams.get('metrics')?.split(',') ||
       ['new_feedback', 'votes_cast'];
     const days = Math.min(parseInt(url.searchParams.get('days') || '30'), 90);

     // Validate metric names
     const validMetrics = [
       'new_feedback', 'votes_cast', 'comments_added',
       'status_open', 'status_planned', 'status_done',
       'avg_sentiment', 'unique_voters', 'unique_submitters'
     ];

     const selectedMetrics = metrics.filter(m => validMetrics.includes(m));
     if (selectedMetrics.length === 0) {
       return errorResponse('INVALID_PARAMETER', 'No valid metrics specified', 400);
     }

     const metricColumns = selectedMetrics.join(', ');
     const boardFilter = boardId
       ? 'AND board_id = ?'
       : 'AND board_id IS NULL';
     const params = boardId ? [boardId] : [];

     const data = await env.DB.prepare(`
       SELECT date, ${metricColumns}
       FROM daily_metrics
       WHERE workspace_id = ?
         AND date > date('now', '-' || ? || ' days')
         ${boardFilter}
       ORDER BY date ASC
     `).bind(workspaceId, days, ...params).all();

     // Format for charting libraries
     const series: Record<string, { date: string; value: number }[]> = {};
     for (const metric of selectedMetrics) {
       series[metric] = data.results.map(row => ({
         date: row.date as string,
         value: row[metric] as number || 0
       }));
     }

     // Calculate sparkline data (last 7 days, normalized)
     const sparklines: Record<string, number[]> = {};
     for (const metric of selectedMetrics) {
       const last7 = series[metric].slice(-7).map(d => d.value);
       const max = Math.max(...last7, 1);
       sparklines[metric] = last7.map(v => Math.round((v / max) * 100));
     }

     return jsonResponse({
       metrics: selectedMetrics,
       days,
       series,
       sparklines
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Time series data properly formatted
- [ ] Multiple metrics supported
- [ ] Sparkline data normalized

---

## Definition of Done
- [ ] Daily metrics aggregation running
- [ ] Trend detection working
- [ ] Comparison views accurate
- [ ] Visualization data available
- [ ] Anomaly detection functional

## Technical Notes
- Aggregation runs daily at 1 AM
- Z-score > 2 for anomaly detection (95% confidence)
- >20% change or statistical significance for trends
- Maximum 90 days for time series queries

## Related Files
- `src/lib/analytics/daily-metrics.ts` - Aggregation
- `src/lib/analytics/trends.ts` - Trend algorithms
- `src/routes/analytics.ts` - API endpoints
