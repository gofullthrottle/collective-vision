# Epic 3.2: MCP Query Tools

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Build read-only MCP tools for agent queries
**Tools**: MCP SDK, D1 queries, Vectorize for search

## Wave Context
**Wave**: 3 - MCP Server + Agent Integration
**Priority**: P1 (enables agent ecosystem)
**Dependencies**: Epic 3.1 (MCP core), Epic 2.1-2.5 (AI features)
**Estimated Duration**: 6 hours

## Quality Requirements
- All query tools respond in < 500ms
- Semantic search results relevant and scored
- Pagination handles large datasets
- Filters combine correctly

---

## Tasks

### 3.2.1 list_feedback Tool (1.5h)
**Objective**: List feedback with comprehensive filters

**Steps**:
1. Define input schema:
   ```typescript
   // src/mcp/tools/list-feedback.ts

   import { z } from 'zod';
   import { registerTool } from './registry';

   const ListFeedbackInput = z.object({
     board_slug: z.string(),
     status: z.array(z.enum(['open', 'under_review', 'planned', 'in_progress', 'done', 'declined'])).optional(),
     tags: z.array(z.string()).optional(),
     theme_id: z.string().optional(),
     sentiment_min: z.number().min(-1).max(1).optional(),
     sentiment_max: z.number().min(-1).max(1).optional(),
     urgency_min: z.number().min(0).max(1).optional(),
     priority_min: z.number().min(0).max(100).optional(),
     created_after: z.string().datetime().optional(),
     created_before: z.string().datetime().optional(),
     limit: z.number().min(1).max(100).default(20),
     offset: z.number().min(0).default(0),
     sort_by: z.enum(['votes', 'created_at', 'priority', 'sentiment', 'urgency']).default('created_at'),
     sort_order: z.enum(['asc', 'desc']).default('desc')
   });

   type ListFeedbackInputType = z.infer<typeof ListFeedbackInput>;
   ```

2. Implement handler:
   ```typescript
   interface ListFeedbackOutput {
     items: FeedbackItem[];
     total: number;
     has_more: boolean;
   }

   async function listFeedbackHandler(
     input: ListFeedbackInputType,
     context: MCPContext
   ): Promise<ListFeedbackOutput> {
     // Get board
     const board = await context.env.DB.prepare(`
       SELECT b.id FROM boards b
       JOIN workspaces w ON b.workspace_id = w.id
       WHERE w.id = ? AND b.slug = ?
     `).bind(context.workspaceId, input.board_slug).first();

     if (!board) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, `Board not found: ${input.board_slug}`);
     }

     // Build query with filters
     let query = `
       SELECT
         fi.*,
         COALESCE(SUM(v.weight), 0) as vote_count,
         ft.theme_id,
         ft.theme_name
       FROM feedback_items fi
       LEFT JOIN feedback_votes v ON v.feedback_id = fi.id
       LEFT JOIN (
         SELECT fit.feedback_id, t.id as theme_id, t.name as theme_name
         FROM feedback_item_themes fit
         JOIN themes t ON fit.theme_id = t.id
         WHERE fit.is_primary = 1
       ) ft ON ft.feedback_id = fi.id
       WHERE fi.board_id = ? AND fi.is_hidden = 0 AND fi.moderation_state = 'approved'
     `;
     const params: unknown[] = [board.id];

     // Apply filters
     if (input.status?.length) {
       query += ` AND fi.status IN (${input.status.map(() => '?').join(',')})`;
       params.push(...input.status);
     }

     if (input.tags?.length) {
       query += ` AND EXISTS (
         SELECT 1 FROM feedback_item_tags fit2
         JOIN feedback_tags ft2 ON fit2.tag_id = ft2.id
         WHERE fit2.feedback_id = fi.id AND ft2.slug IN (${input.tags.map(() => '?').join(',')})
       )`;
       params.push(...input.tags);
     }

     if (input.theme_id) {
       query += ` AND EXISTS (
         SELECT 1 FROM feedback_item_themes fit3
         WHERE fit3.feedback_id = fi.id AND fit3.theme_id = ?
       )`;
       params.push(input.theme_id);
     }

     if (input.sentiment_min !== undefined) {
       query += ` AND fi.sentiment_score >= ?`;
       params.push(input.sentiment_min);
     }

     if (input.sentiment_max !== undefined) {
       query += ` AND fi.sentiment_score <= ?`;
       params.push(input.sentiment_max);
     }

     if (input.urgency_min !== undefined) {
       query += ` AND fi.urgency_score >= ?`;
       params.push(input.urgency_min);
     }

     if (input.priority_min !== undefined) {
       query += ` AND fi.priority_score >= ?`;
       params.push(input.priority_min);
     }

     if (input.created_after) {
       query += ` AND fi.created_at >= ?`;
       params.push(input.created_after);
     }

     if (input.created_before) {
       query += ` AND fi.created_at <= ?`;
       params.push(input.created_before);
     }

     query += ` GROUP BY fi.id`;

     // Count total
     const countQuery = `SELECT COUNT(*) as total FROM (${query})`;
     const total = await context.env.DB.prepare(countQuery).bind(...params).first();

     // Apply sort and pagination
     const sortColumn = {
       votes: 'vote_count',
       created_at: 'fi.created_at',
       priority: 'fi.priority_score',
       sentiment: 'fi.sentiment_score',
       urgency: 'fi.urgency_score'
     }[input.sort_by];

     query += ` ORDER BY ${sortColumn} ${input.sort_order.toUpperCase()}`;
     query += ` LIMIT ? OFFSET ?`;
     params.push(input.limit, input.offset);

     const items = await context.env.DB.prepare(query).bind(...params).all();

     return {
       items: items.results.map(formatFeedbackItem),
       total: total?.total as number || 0,
       has_more: input.offset + items.results.length < (total?.total as number || 0)
     };
   }
   ```

3. Register tool:
   ```typescript
   export function registerListFeedbackTool(): void {
     registerTool({
       name: 'list_feedback',
       description: 'List feedback items with filters, pagination, and sorting. Returns approved, visible feedback.',
       inputSchema: ListFeedbackInput,
       requiredScope: 'read',
       handler: listFeedbackHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] All filters work correctly
- [ ] Pagination handles large datasets
- [ ] Response time < 500ms
- [ ] Vote counts included

---

### 3.2.2 get_feedback Tool (0.5h)
**Objective**: Get single feedback item with full details

**Steps**:
1. Define and implement:
   ```typescript
   // src/mcp/tools/get-feedback.ts

   const GetFeedbackInput = z.object({
     feedback_id: z.string()
   });

   async function getFeedbackHandler(
     input: z.infer<typeof GetFeedbackInput>,
     context: MCPContext
   ): Promise<FeedbackDetail> {
     const feedback = await context.env.DB.prepare(`
       SELECT fi.*,
         COALESCE(SUM(v.weight), 0) as vote_count,
         b.slug as board_slug,
         b.name as board_name
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       LEFT JOIN feedback_votes v ON v.feedback_id = fi.id
       WHERE fi.id = ? AND b.workspace_id = ?
       GROUP BY fi.id
     `).bind(input.feedback_id, context.workspaceId).first();

     if (!feedback) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, 'Feedback not found');
     }

     // Get tags
     const tags = await context.env.DB.prepare(`
       SELECT ft.slug, ft.name, fit.source
       FROM feedback_item_tags fit
       JOIN feedback_tags ft ON fit.tag_id = ft.id
       WHERE fit.feedback_id = ?
     `).bind(input.feedback_id).all();

     // Get themes
     const themes = await context.env.DB.prepare(`
       SELECT t.id, t.name, t.description, fit.is_primary
       FROM feedback_item_themes fit
       JOIN themes t ON fit.theme_id = t.id
       WHERE fit.feedback_id = ?
     `).bind(input.feedback_id).all();

     // Get recent comments
     const comments = await context.env.DB.prepare(`
       SELECT fc.*, eu.name as author_name
       FROM feedback_comments fc
       LEFT JOIN end_users eu ON fc.user_id = eu.id
       WHERE fc.feedback_id = ? AND fc.is_internal = 0
       ORDER BY fc.created_at DESC
       LIMIT 10
     `).bind(input.feedback_id).all();

     // Get duplicate suggestions if any
     const duplicates = await context.env.DB.prepare(`
       SELECT ds.target_feedback_id, ds.similarity_score, fi.title
       FROM duplicate_suggestions ds
       JOIN feedback_items fi ON ds.target_feedback_id = fi.id
       WHERE ds.source_feedback_id = ? AND ds.status = 'pending'
     `).bind(input.feedback_id).all();

     return {
       ...formatFeedbackItem(feedback),
       tags: tags.results,
       themes: themes.results,
       comments: comments.results,
       duplicate_suggestions: duplicates.results,
       ai_analysis: {
         sentiment_score: feedback.sentiment_score,
         sentiment_label: feedback.sentiment_label,
         urgency_score: feedback.urgency_score,
         priority_score: feedback.priority_score,
         ai_classification: feedback.ai_classification ? JSON.parse(feedback.ai_classification) : null
       }
     };
   }

   export function registerGetFeedbackTool(): void {
     registerTool({
       name: 'get_feedback',
       description: 'Get full details of a single feedback item including tags, themes, comments, and AI analysis.',
       inputSchema: GetFeedbackInput,
       requiredScope: 'read',
       handler: getFeedbackHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Full item details returned
- [ ] 404 for non-existent items
- [ ] Workspace isolation enforced

---

### 3.2.3 search_feedback Tool (1.5h)
**Objective**: Semantic search across feedback using vector similarity

**Steps**:
1. Implement semantic search:
   ```typescript
   // src/mcp/tools/search-feedback.ts

   const SearchFeedbackInput = z.object({
     query: z.string().min(3),
     board_slug: z.string().optional(),
     status: z.array(z.string()).optional(),
     limit: z.number().min(1).max(50).default(10)
   });

   interface SearchResult {
     feedback: FeedbackItem;
     similarity_score: number;
   }

   async function searchFeedbackHandler(
     input: z.infer<typeof SearchFeedbackInput>,
     context: MCPContext
   ): Promise<{ items: SearchResult[] }> {
     // Generate embedding for query
     const queryEmbedding = await generateEmbedding(context.env.AI, input.query);

     // Search Vectorize
     const vectorResults = await queryVectors(context.env.VECTORIZE, queryEmbedding, {
       topK: input.limit * 2,  // Get extra to filter
       filter: { workspace_id: context.workspaceId }
     });

     if (vectorResults.matches.length === 0) {
       return { items: [] };
     }

     // Get feedback IDs
     const feedbackIds = vectorResults.matches.map(m => m.id);

     // Fetch feedback items with filters
     let query = `
       SELECT fi.*,
         COALESCE(SUM(v.weight), 0) as vote_count,
         b.slug as board_slug
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       LEFT JOIN feedback_votes v ON v.feedback_id = fi.id
       WHERE fi.id IN (${feedbackIds.map(() => '?').join(',')})
         AND fi.is_hidden = 0 AND fi.moderation_state = 'approved'
     `;
     const params: unknown[] = [...feedbackIds];

     if (input.board_slug) {
       query += ` AND b.slug = ?`;
       params.push(input.board_slug);
     }

     if (input.status?.length) {
       query += ` AND fi.status IN (${input.status.map(() => '?').join(',')})`;
       params.push(...input.status);
     }

     query += ` GROUP BY fi.id`;

     const feedbackItems = await context.env.DB.prepare(query).bind(...params).all();

     // Create lookup for scores
     const scoreMap = new Map(vectorResults.matches.map(m => [m.id, m.score]));

     // Combine and sort by similarity
     const results: SearchResult[] = feedbackItems.results
       .map(item => ({
         feedback: formatFeedbackItem(item),
         similarity_score: scoreMap.get(item.id as string) || 0
       }))
       .sort((a, b) => b.similarity_score - a.similarity_score)
       .slice(0, input.limit);

     return { items: results };
   }

   export function registerSearchFeedbackTool(): void {
     registerTool({
       name: 'search_feedback',
       description: 'Semantic search across feedback using natural language. Returns items ranked by relevance.',
       inputSchema: SearchFeedbackInput,
       requiredScope: 'read',
       handler: searchFeedbackHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Semantic search returns relevant results
- [ ] Similarity scores meaningful (0-1)
- [ ] Fast response (< 1s including embedding)
- [ ] Filters combine with search

---

### 3.2.4 get_themes Tool (1h)
**Objective**: List all themes with item counts and trends

**Steps**:
1. Implement theme listing:
   ```typescript
   // src/mcp/tools/get-themes.ts

   const GetThemesInput = z.object({
     board_slug: z.string().optional(),
     include_inactive: z.boolean().default(false)
   });

   interface ThemeOutput {
     id: string;
     name: string;
     description: string;
     item_count: number;
     trend: 'rising' | 'stable' | 'declining';
     trend_percentage: number;
     top_items: Array<{ id: string; title: string; votes: number }>;
   }

   async function getThemesHandler(
     input: z.infer<typeof GetThemesInput>,
     context: MCPContext
   ): Promise<{ themes: ThemeOutput[] }> {
     // Get themes with current counts
     let query = `
       SELECT t.*,
         COUNT(DISTINCT fit.feedback_id) as item_count
       FROM themes t
       LEFT JOIN feedback_item_themes fit ON t.id = fit.theme_id
       LEFT JOIN feedback_items fi ON fit.feedback_id = fi.id
       LEFT JOIN boards b ON fi.board_id = b.id
       WHERE t.workspace_id = ?
         AND (fi.is_hidden = 0 OR fi.is_hidden IS NULL)
     `;
     const params: unknown[] = [context.workspaceId];

     if (input.board_slug) {
       query += ` AND b.slug = ?`;
       params.push(input.board_slug);
     }

     if (!input.include_inactive) {
       query += ` AND t.is_active = 1`;
     }

     query += ` GROUP BY t.id ORDER BY item_count DESC`;

     const themes = await context.env.DB.prepare(query).bind(...params).all();

     // Calculate trends (compare last 7 days vs previous 7 days)
     const themesWithTrends: ThemeOutput[] = [];

     for (const theme of themes.results) {
       const recentCount = await context.env.DB.prepare(`
         SELECT COUNT(*) as count FROM feedback_item_themes fit
         JOIN feedback_items fi ON fit.feedback_id = fi.id
         WHERE fit.theme_id = ? AND fi.created_at > datetime('now', '-7 days')
       `).bind(theme.id).first();

       const previousCount = await context.env.DB.prepare(`
         SELECT COUNT(*) as count FROM feedback_item_themes fit
         JOIN feedback_items fi ON fit.feedback_id = fi.id
         WHERE fit.theme_id = ?
           AND fi.created_at BETWEEN datetime('now', '-14 days') AND datetime('now', '-7 days')
       `).bind(theme.id).first();

       const recent = (recentCount?.count as number) || 0;
       const previous = (previousCount?.count as number) || 0;

       let trend: 'rising' | 'stable' | 'declining' = 'stable';
       let trendPercentage = 0;

       if (previous > 0) {
         trendPercentage = ((recent - previous) / previous) * 100;
         if (trendPercentage > 20) trend = 'rising';
         else if (trendPercentage < -20) trend = 'declining';
       } else if (recent > 0) {
         trend = 'rising';
         trendPercentage = 100;
       }

       // Get top items for this theme
       const topItems = await context.env.DB.prepare(`
         SELECT fi.id, fi.title, COALESCE(SUM(v.weight), 0) as votes
         FROM feedback_items fi
         JOIN feedback_item_themes fit ON fi.id = fit.feedback_id
         LEFT JOIN feedback_votes v ON fi.id = v.feedback_id
         WHERE fit.theme_id = ? AND fi.is_hidden = 0
         GROUP BY fi.id
         ORDER BY votes DESC
         LIMIT 3
       `).bind(theme.id).all();

       themesWithTrends.push({
         id: theme.id as string,
         name: theme.name as string,
         description: theme.description as string,
         item_count: theme.item_count as number,
         trend,
         trend_percentage: Math.round(trendPercentage),
         top_items: topItems.results.map(i => ({
           id: i.id as string,
           title: i.title as string,
           votes: i.votes as number
         }))
       });
     }

     return { themes: themesWithTrends };
   }

   export function registerGetThemesTool(): void {
     registerTool({
       name: 'get_themes',
       description: 'Get all feedback themes with item counts, trend direction, and top items per theme.',
       inputSchema: GetThemesInput,
       requiredScope: 'read',
       handler: getThemesHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] All themes returned with counts
- [ ] Trend calculation accurate (7-day comparison)
- [ ] Top items per theme included

---

### 3.2.5 get_trends Tool (1h)
**Objective**: Detect trending topics and anomalies

**Steps**:
1. Implement trend detection:
   ```typescript
   // src/mcp/tools/get-trends.ts

   const GetTrendsInput = z.object({
     timeframe: z.enum(['7d', '30d', '90d']).default('7d'),
     board_slug: z.string().optional()
   });

   interface Anomaly {
     type: 'spike' | 'drop' | 'new_theme';
     description: string;
     severity: 'low' | 'medium' | 'high';
     theme_id?: string;
     theme_name?: string;
     data: Record<string, unknown>;
   }

   interface TrendsOutput {
     trending_themes: Array<{
       id: string;
       name: string;
       growth_rate: number;
       new_items_count: number;
     }>;
     anomalies: Anomaly[];
     summary: string;
     period: { start: string; end: string };
   }

   async function getTrendsHandler(
     input: z.infer<typeof GetTrendsInput>,
     context: MCPContext
   ): Promise<TrendsOutput> {
     const days = { '7d': 7, '30d': 30, '90d': 90 }[input.timeframe];
     const halfDays = Math.floor(days / 2);

     // Get themes with growth rates
     let themeQuery = `
       SELECT t.id, t.name,
         COUNT(DISTINCT CASE WHEN fi.created_at > datetime('now', '-${halfDays} days') THEN fit.feedback_id END) as recent,
         COUNT(DISTINCT CASE WHEN fi.created_at BETWEEN datetime('now', '-${days} days') AND datetime('now', '-${halfDays} days') THEN fit.feedback_id END) as previous
       FROM themes t
       LEFT JOIN feedback_item_themes fit ON t.id = fit.theme_id
       LEFT JOIN feedback_items fi ON fit.feedback_id = fi.id
       LEFT JOIN boards b ON fi.board_id = b.id
       WHERE t.workspace_id = ?
     `;
     const params: unknown[] = [context.workspaceId];

     if (input.board_slug) {
       themeQuery += ` AND b.slug = ?`;
       params.push(input.board_slug);
     }

     themeQuery += ` GROUP BY t.id HAVING (recent > 0 OR previous > 0) ORDER BY recent DESC`;

     const themeGrowth = await context.env.DB.prepare(themeQuery).bind(...params).all();

     const trendingThemes = [];
     const anomalies: Anomaly[] = [];

     for (const t of themeGrowth.results) {
       const recent = t.recent as number;
       const previous = t.previous as number;

       let growthRate = 0;
       if (previous > 0) {
         growthRate = ((recent - previous) / previous) * 100;
       } else if (recent > 0) {
         growthRate = 100;
         // New theme anomaly
         if (recent >= 3) {
           anomalies.push({
             type: 'new_theme',
             description: `New theme "${t.name}" emerged with ${recent} items`,
             severity: recent >= 10 ? 'high' : recent >= 5 ? 'medium' : 'low',
             theme_id: t.id as string,
             theme_name: t.name as string,
             data: { item_count: recent }
           });
         }
       }

       // Check for spikes (3x normal volume)
       if (previous > 0 && recent >= previous * 3) {
         anomalies.push({
           type: 'spike',
           description: `${Math.round(recent / previous)}x normal volume for "${t.name}"`,
           severity: recent >= previous * 5 ? 'high' : 'medium',
           theme_id: t.id as string,
           theme_name: t.name as string,
           data: { recent, previous, multiplier: recent / previous }
         });
       }

       // Check for drops
       if (previous >= 5 && recent <= previous * 0.3) {
         anomalies.push({
           type: 'drop',
           description: `Significant drop in "${t.name}" (${previous} â†’ ${recent})`,
           severity: 'low',
           theme_id: t.id as string,
           theme_name: t.name as string,
           data: { recent, previous }
         });
       }

       if (growthRate >= 20) {
         trendingThemes.push({
           id: t.id as string,
           name: t.name as string,
           growth_rate: Math.round(growthRate),
           new_items_count: recent
         });
       }
     }

     // Sort by growth rate
     trendingThemes.sort((a, b) => b.growth_rate - a.growth_rate);

     // Generate summary
     const totalRecent = await context.env.DB.prepare(`
       SELECT COUNT(*) as count FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ? AND fi.created_at > datetime('now', '-${days} days')
     `).bind(context.workspaceId).first();

     const totalPrevious = await context.env.DB.prepare(`
       SELECT COUNT(*) as count FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?
         AND fi.created_at BETWEEN datetime('now', '-${days * 2} days') AND datetime('now', '-${days} days')
     `).bind(context.workspaceId).first();

     const recentCount = (totalRecent?.count as number) || 0;
     const previousCount = (totalPrevious?.count as number) || 0;
     const overallChange = previousCount > 0
       ? Math.round(((recentCount - previousCount) / previousCount) * 100)
       : 0;

     let summary = `Over the past ${days} days, there were ${recentCount} new feedback items`;
     if (overallChange !== 0) {
       summary += ` (${overallChange > 0 ? '+' : ''}${overallChange}% vs previous period)`;
     }
     summary += '.';

     if (trendingThemes.length > 0) {
       summary += ` Top trending theme: "${trendingThemes[0].name}" (+${trendingThemes[0].growth_rate}%).`;
     }

     if (anomalies.filter(a => a.severity === 'high').length > 0) {
       summary += ` ${anomalies.filter(a => a.severity === 'high').length} high-severity anomalies detected.`;
     }

     return {
       trending_themes: trendingThemes.slice(0, 10),
       anomalies: anomalies.sort((a, b) => {
         const severityOrder = { high: 0, medium: 1, low: 2 };
         return severityOrder[a.severity] - severityOrder[b.severity];
       }),
       summary,
       period: {
         start: new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString(),
         end: new Date().toISOString()
       }
     };
   }

   export function registerGetTrendsTool(): void {
     registerTool({
       name: 'get_trends',
       description: 'Get trending themes and anomalies (spikes, drops, new themes) over a time period.',
       inputSchema: GetTrendsInput,
       requiredScope: 'read',
       handler: getTrendsHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Trending themes accurately detected
- [ ] Anomalies flagged with severity
- [ ] Summary useful for agents

---

### 3.2.6 get_statistics Tool (0.5h)
**Objective**: Aggregate stats for workspace/board

**Steps**:
1. Implement statistics:
   ```typescript
   // src/mcp/tools/get-statistics.ts

   const GetStatisticsInput = z.object({
     board_slug: z.string().optional()
   });

   interface StatisticsOutput {
     total_feedback: number;
     total_votes: number;
     total_comments: number;
     by_status: Record<string, number>;
     by_source: Record<string, number>;
     sentiment: {
       average: number;
       distribution: { negative: number; neutral: number; positive: number };
     };
     resolution: {
       avg_time_to_response_hours: number;
       avg_time_to_close_days: number;
     };
     activity: {
       last_24h: number;
       last_7d: number;
       last_30d: number;
     };
   }

   async function getStatisticsHandler(
     input: z.infer<typeof GetStatisticsInput>,
     context: MCPContext
   ): Promise<StatisticsOutput> {
     let boardFilter = '';
     const params: unknown[] = [context.workspaceId];

     if (input.board_slug) {
       boardFilter = ' AND b.slug = ?';
       params.push(input.board_slug);
     }

     // Total counts
     const totals = await context.env.DB.prepare(`
       SELECT
         COUNT(DISTINCT fi.id) as total_feedback,
         COALESCE(SUM(fi.vote_count), 0) as total_votes,
         (SELECT COUNT(*) FROM feedback_comments fc
          JOIN feedback_items fi2 ON fc.feedback_id = fi2.id
          JOIN boards b2 ON fi2.board_id = b2.id
          WHERE b2.workspace_id = ?${boardFilter.replace('b.slug', 'b2.slug')}) as total_comments
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?${boardFilter}
     `).bind(...params, ...params).first();

     // By status
     const byStatus = await context.env.DB.prepare(`
       SELECT fi.status, COUNT(*) as count
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?${boardFilter}
       GROUP BY fi.status
     `).bind(...params).all();

     // By source
     const bySource = await context.env.DB.prepare(`
       SELECT fi.source, COUNT(*) as count
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?${boardFilter}
       GROUP BY fi.source
     `).bind(...params).all();

     // Sentiment distribution
     const sentiment = await context.env.DB.prepare(`
       SELECT
         AVG(fi.sentiment_score) as avg_sentiment,
         SUM(CASE WHEN fi.sentiment_score < -0.3 THEN 1 ELSE 0 END) as negative,
         SUM(CASE WHEN fi.sentiment_score BETWEEN -0.3 AND 0.3 THEN 1 ELSE 0 END) as neutral,
         SUM(CASE WHEN fi.sentiment_score > 0.3 THEN 1 ELSE 0 END) as positive
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?${boardFilter} AND fi.sentiment_score IS NOT NULL
     `).bind(...params).first();

     // Activity
     const activity = await context.env.DB.prepare(`
       SELECT
         SUM(CASE WHEN fi.created_at > datetime('now', '-1 day') THEN 1 ELSE 0 END) as last_24h,
         SUM(CASE WHEN fi.created_at > datetime('now', '-7 days') THEN 1 ELSE 0 END) as last_7d,
         SUM(CASE WHEN fi.created_at > datetime('now', '-30 days') THEN 1 ELSE 0 END) as last_30d
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE b.workspace_id = ?${boardFilter}
     `).bind(...params).first();

     return {
       total_feedback: (totals?.total_feedback as number) || 0,
       total_votes: (totals?.total_votes as number) || 0,
       total_comments: (totals?.total_comments as number) || 0,
       by_status: Object.fromEntries(byStatus.results.map(r => [r.status, r.count])),
       by_source: Object.fromEntries(bySource.results.map(r => [r.source || 'unknown', r.count])),
       sentiment: {
         average: Math.round(((sentiment?.avg_sentiment as number) || 0) * 100) / 100,
         distribution: {
           negative: (sentiment?.negative as number) || 0,
           neutral: (sentiment?.neutral as number) || 0,
           positive: (sentiment?.positive as number) || 0
         }
       },
       resolution: {
         avg_time_to_response_hours: 0,  // TODO: Calculate from first comment
         avg_time_to_close_days: 0  // TODO: Calculate from status changes
       },
       activity: {
         last_24h: (activity?.last_24h as number) || 0,
         last_7d: (activity?.last_7d as number) || 0,
         last_30d: (activity?.last_30d as number) || 0
       }
     };
   }

   export function registerGetStatisticsTool(): void {
     registerTool({
       name: 'get_statistics',
       description: 'Get aggregate statistics for a workspace or board: totals, breakdowns by status/source, sentiment distribution, and activity metrics.',
       inputSchema: GetStatisticsInput,
       requiredScope: 'read',
       handler: getStatisticsHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] All aggregate stats accurate
- [ ] By status and source breakdowns
- [ ] Sentiment distribution calculated
- [ ] Activity metrics included

---

## Definition of Done
- [ ] All 6 query tools registered and functional
- [ ] Workspace isolation on all queries
- [ ] Response times < 500ms (< 1s for search)
- [ ] Proper error handling for not found cases

## Technical Notes
- Use D1 indexes for performance
- Vectorize queries limited to workspace
- Consider caching statistics (1 min TTL)
- Semantic search embeds query on each call (~$0.0001)

## Related Files
- `src/mcp/tools/list-feedback.ts`
- `src/mcp/tools/get-feedback.ts`
- `src/mcp/tools/search-feedback.ts`
- `src/mcp/tools/get-themes.ts`
- `src/mcp/tools/get-trends.ts`
- `src/mcp/tools/get-statistics.ts`
