# Epic 7.1: Public Roadmaps

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Build comprehensive public roadmap system with kanban views, changelogs, and subscriber notifications.

## Wave Context
**Wave 7**: Advanced Features (Roadmaps, PM Integrations, AI Features)
**Dependencies**: Wave 2 (AI for prioritization), Wave 4 (analytics for votes)
**Unlocks**: Customer transparency, product communication, changelog publication

## Quality Requirements
- SEO-optimized public roadmap URLs
- Mobile-responsive kanban layouts
- Subscriber notifications with high deliverability
- Real-time updates via websockets (future)

---

## Tasks

### Task 7.1.1: Roadmap Data Model (1.5h)

Create flexible roadmap schema supporting phases, items, and feedback linkage.

**Subtasks**:
- [ ] Create roadmaps table with settings
- [ ] Create phases table with ordering
- [ ] Create items table linked to feedback
- [ ] Add roadmap permissions

**Schema**:
```sql
-- Roadmaps per workspace
CREATE TABLE IF NOT EXISTS roadmaps (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  name TEXT NOT NULL DEFAULT 'Public Roadmap',
  slug TEXT NOT NULL,
  description TEXT,
  is_public INTEGER DEFAULT 1,
  allow_voting INTEGER DEFAULT 1, -- Allow votes from roadmap view
  show_vote_counts INTEGER DEFAULT 1,
  show_feedback_links INTEGER DEFAULT 0, -- Link to original feedback
  theme TEXT DEFAULT 'default', -- 'default', 'minimal', 'colorful'
  custom_css TEXT,
  settings TEXT, -- JSON: { phases_visible: true, dates_visible: false }
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  UNIQUE(workspace_id, slug)
);

CREATE INDEX idx_roadmaps_workspace ON roadmaps(workspace_id);
CREATE INDEX idx_roadmaps_public ON roadmaps(is_public) WHERE is_public = 1;

-- Roadmap phases (columns in kanban)
CREATE TABLE IF NOT EXISTS roadmap_phases (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  roadmap_id TEXT NOT NULL REFERENCES roadmaps(id) ON DELETE CASCADE,
  name TEXT NOT NULL, -- 'Now', 'Next', 'Later', 'Future'
  description TEXT,
  color TEXT DEFAULT '#6B7280',
  icon TEXT, -- emoji or icon name
  sort_order INTEGER DEFAULT 0,
  is_visible INTEGER DEFAULT 1,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_phases_roadmap ON roadmap_phases(roadmap_id, sort_order);

-- Roadmap items (cards in phases)
CREATE TABLE IF NOT EXISTS roadmap_items (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  roadmap_id TEXT NOT NULL REFERENCES roadmaps(id) ON DELETE CASCADE,
  phase_id TEXT NOT NULL REFERENCES roadmap_phases(id) ON DELETE CASCADE,
  feedback_id TEXT REFERENCES feedback_items(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'planned', -- 'planned', 'in_progress', 'completed', 'cancelled'
  target_date TEXT,
  completed_at TEXT,
  priority INTEGER DEFAULT 0, -- Higher = more important
  vote_count INTEGER DEFAULT 0, -- Cached from feedback
  tags TEXT, -- JSON array
  custom_fields TEXT, -- JSON for extensibility
  sort_order INTEGER DEFAULT 0,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_items_phase ON roadmap_items(phase_id, sort_order);
CREATE INDEX idx_items_feedback ON roadmap_items(feedback_id);
CREATE INDEX idx_items_status ON roadmap_items(roadmap_id, status);
```

**Implementation**:
```typescript
// src/services/roadmaps.ts
interface Roadmap {
  id: string;
  workspace_id: string;
  name: string;
  slug: string;
  description: string | null;
  is_public: boolean;
  allow_voting: boolean;
  show_vote_counts: boolean;
  settings: Record<string, unknown>;
}

interface RoadmapPhase {
  id: string;
  roadmap_id: string;
  name: string;
  description: string | null;
  color: string;
  icon: string | null;
  sort_order: number;
  items?: RoadmapItem[];
}

interface RoadmapItem {
  id: string;
  phase_id: string;
  feedback_id: string | null;
  title: string;
  description: string | null;
  status: 'planned' | 'in_progress' | 'completed' | 'cancelled';
  target_date: string | null;
  vote_count: number;
  tags: string[];
  sort_order: number;
}

export async function createRoadmap(
  env: Env,
  workspaceId: string,
  input: { name: string; slug?: string; description?: string; is_public?: boolean }
): Promise<Roadmap> {
  const slug = input.slug || input.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');

  const id = crypto.randomUUID();
  await env.DB.prepare(`
    INSERT INTO roadmaps (id, workspace_id, name, slug, description, is_public)
    VALUES (?, ?, ?, ?, ?, ?)
  `).bind(id, workspaceId, input.name, slug, input.description || null, input.is_public ? 1 : 0).run();

  // Create default phases
  const defaultPhases = [
    { name: 'Now', color: '#22c55e', icon: 'ðŸš€' },
    { name: 'Next', color: '#3b82f6', icon: 'ðŸ“‹' },
    { name: 'Later', color: '#8b5cf6', icon: 'ðŸ’¡' },
    { name: 'Future', color: '#6b7280', icon: 'ðŸ”®' }
  ];

  for (let i = 0; i < defaultPhases.length; i++) {
    await env.DB.prepare(`
      INSERT INTO roadmap_phases (id, roadmap_id, name, color, icon, sort_order)
      VALUES (?, ?, ?, ?, ?, ?)
    `).bind(crypto.randomUUID(), id, defaultPhases[i].name, defaultPhases[i].color, defaultPhases[i].icon, i).run();
  }

  return { id, workspace_id: workspaceId, name: input.name, slug, description: input.description || null, is_public: !!input.is_public, allow_voting: true, show_vote_counts: true, settings: {} };
}

export async function getRoadmapWithPhases(
  env: Env,
  roadmapId: string,
  includeItems = true
): Promise<(Roadmap & { phases: RoadmapPhase[] }) | null> {
  const roadmap = await env.DB.prepare(`
    SELECT * FROM roadmaps WHERE id = ?
  `).bind(roadmapId).first<Roadmap>();

  if (!roadmap) return null;

  const phases = await env.DB.prepare(`
    SELECT * FROM roadmap_phases
    WHERE roadmap_id = ? AND is_visible = 1
    ORDER BY sort_order
  `).bind(roadmapId).all<RoadmapPhase>();

  if (includeItems) {
    for (const phase of phases.results) {
      const items = await env.DB.prepare(`
        SELECT ri.*, COALESCE(f.vote_count, 0) as vote_count
        FROM roadmap_items ri
        LEFT JOIN feedback_items f ON f.id = ri.feedback_id
        WHERE ri.phase_id = ?
        ORDER BY ri.sort_order
      `).bind(phase.id).all<RoadmapItem>();
      phase.items = items.results;
    }
  }

  return { ...roadmap, phases: phases.results };
}

export async function addItemToRoadmap(
  env: Env,
  phaseId: string,
  input: {
    title: string;
    description?: string;
    feedback_id?: string;
    target_date?: string;
    tags?: string[];
  }
): Promise<RoadmapItem> {
  const id = crypto.randomUUID();

  // Get max sort_order for phase
  const maxOrder = await env.DB.prepare(`
    SELECT MAX(sort_order) as max FROM roadmap_items WHERE phase_id = ?
  `).bind(phaseId).first<{ max: number }>();

  const phase = await env.DB.prepare(`
    SELECT roadmap_id FROM roadmap_phases WHERE id = ?
  `).bind(phaseId).first<{ roadmap_id: string }>();

  await env.DB.prepare(`
    INSERT INTO roadmap_items (
      id, roadmap_id, phase_id, feedback_id, title, description,
      target_date, tags, sort_order
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    id, phase?.roadmap_id, phaseId, input.feedback_id || null,
    input.title, input.description || null, input.target_date || null,
    JSON.stringify(input.tags || []), (maxOrder?.max || 0) + 1
  ).run();

  return {
    id, phase_id: phaseId, feedback_id: input.feedback_id || null,
    title: input.title, description: input.description || null,
    status: 'planned', target_date: input.target_date || null,
    vote_count: 0, tags: input.tags || [], sort_order: (maxOrder?.max || 0) + 1
  };
}

export async function moveItem(
  env: Env,
  itemId: string,
  targetPhaseId: string,
  newOrder: number
): Promise<void> {
  // Get current item
  const item = await env.DB.prepare(`
    SELECT phase_id FROM roadmap_items WHERE id = ?
  `).bind(itemId).first<{ phase_id: string }>();

  if (!item) throw new Error('Item not found');

  // Shift items in target phase
  await env.DB.prepare(`
    UPDATE roadmap_items
    SET sort_order = sort_order + 1
    WHERE phase_id = ? AND sort_order >= ?
  `).bind(targetPhaseId, newOrder).run();

  // Move item
  await env.DB.prepare(`
    UPDATE roadmap_items
    SET phase_id = ?, sort_order = ?, updated_at = datetime('now')
    WHERE id = ?
  `).bind(targetPhaseId, newOrder, itemId).run();

  // Reorder source phase if different
  if (item.phase_id !== targetPhaseId) {
    await env.DB.prepare(`
      UPDATE roadmap_items
      SET sort_order = sort_order - 1
      WHERE phase_id = ? AND sort_order > (
        SELECT sort_order FROM roadmap_items WHERE id = ?
      )
    `).bind(item.phase_id, itemId).run();
  }
}
```

**Acceptance Criteria**:
- [ ] Roadmaps with customizable settings
- [ ] Phases with colors and icons
- [ ] Items linkable to feedback
- [ ] Sort order persisted

---

### Task 7.1.2: Roadmap Management API (2h)

Build complete CRUD API for roadmaps, phases, and items.

**Subtasks**:
- [ ] Roadmap CRUD endpoints
- [ ] Phase management endpoints
- [ ] Item management with drag-drop ordering
- [ ] Bulk operations support

**API Routes**:
```typescript
// src/routes/roadmaps.ts

// Roadmap CRUD
// POST /api/v1/workspaces/:workspace_id/roadmaps
export async function createRoadmapHandler(request: Request, env: Env): Promise<Response> {
  const { workspace_id } = request.params;
  const body = await request.json();

  // Verify workspace access
  await requireWorkspaceAccess(env, request, workspace_id, 'admin');

  const roadmap = await createRoadmap(env, workspace_id, body);
  return jsonResponse(roadmap, 201);
}

// GET /api/v1/roadmaps/:roadmap_id
export async function getRoadmapHandler(request: Request, env: Env): Promise<Response> {
  const { roadmap_id } = request.params;

  const roadmap = await getRoadmapWithPhases(env, roadmap_id);
  if (!roadmap) {
    return jsonResponse({ error: 'Roadmap not found' }, 404);
  }

  // Check if public or user has access
  if (!roadmap.is_public) {
    await requireWorkspaceAccess(env, request, roadmap.workspace_id, 'read');
  }

  return jsonResponse(roadmap);
}

// PATCH /api/v1/roadmaps/:roadmap_id
export async function updateRoadmapHandler(request: Request, env: Env): Promise<Response> {
  const { roadmap_id } = request.params;
  const body = await request.json();

  const roadmap = await env.DB.prepare(`SELECT workspace_id FROM roadmaps WHERE id = ?`)
    .bind(roadmap_id).first<{ workspace_id: string }>();

  if (!roadmap) return jsonResponse({ error: 'Not found' }, 404);

  await requireWorkspaceAccess(env, request, roadmap.workspace_id, 'admin');

  const updates: string[] = [];
  const values: any[] = [];

  for (const [key, value] of Object.entries(body)) {
    if (['name', 'slug', 'description', 'is_public', 'allow_voting', 'show_vote_counts', 'settings'].includes(key)) {
      updates.push(`${key} = ?`);
      values.push(key === 'settings' ? JSON.stringify(value) : value);
    }
  }

  if (updates.length) {
    values.push(roadmap_id);
    await env.DB.prepare(`
      UPDATE roadmaps SET ${updates.join(', ')}, updated_at = datetime('now')
      WHERE id = ?
    `).bind(...values).run();
  }

  return jsonResponse({ success: true });
}

// Phase endpoints
// POST /api/v1/roadmaps/:roadmap_id/phases
export async function createPhaseHandler(request: Request, env: Env): Promise<Response> {
  const { roadmap_id } = request.params;
  const body = await request.json();

  const id = crypto.randomUUID();
  const maxOrder = await env.DB.prepare(`
    SELECT MAX(sort_order) as max FROM roadmap_phases WHERE roadmap_id = ?
  `).bind(roadmap_id).first<{ max: number }>();

  await env.DB.prepare(`
    INSERT INTO roadmap_phases (id, roadmap_id, name, description, color, icon, sort_order)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `).bind(id, roadmap_id, body.name, body.description || null, body.color || '#6B7280', body.icon || null, (maxOrder?.max || 0) + 1).run();

  return jsonResponse({ id, ...body, sort_order: (maxOrder?.max || 0) + 1 }, 201);
}

// PATCH /api/v1/phases/:phase_id
// DELETE /api/v1/phases/:phase_id

// Item endpoints
// POST /api/v1/phases/:phase_id/items
// PATCH /api/v1/items/:item_id
// DELETE /api/v1/items/:item_id

// POST /api/v1/items/:item_id/move
export async function moveItemHandler(request: Request, env: Env): Promise<Response> {
  const { item_id } = request.params;
  const { target_phase_id, new_order } = await request.json();

  await moveItem(env, item_id, target_phase_id, new_order);
  return jsonResponse({ success: true });
}

// Bulk reorder
// POST /api/v1/roadmaps/:roadmap_id/reorder
export async function reorderHandler(request: Request, env: Env): Promise<Response> {
  const { roadmap_id } = request.params;
  const { items } = await request.json();
  // items: [{ id, phase_id, sort_order }]

  for (const item of items) {
    await env.DB.prepare(`
      UPDATE roadmap_items SET phase_id = ?, sort_order = ?, updated_at = datetime('now')
      WHERE id = ? AND roadmap_id = ?
    `).bind(item.phase_id, item.sort_order, item.id, roadmap_id).run();
  }

  return jsonResponse({ success: true });
}
```

**Acceptance Criteria**:
- [ ] Full CRUD for roadmaps, phases, items
- [ ] Ordering updates via API
- [ ] Permission checks enforced
- [ ] Bulk reorder support

---

### Task 7.1.3: Public Roadmap Page (2.5h)

Create SEO-friendly public roadmap pages with kanban layout.

**Subtasks**:
- [ ] Public URL routing
- [ ] Kanban board component
- [ ] Item detail modal
- [ ] SEO meta tags

**Implementation**:
```typescript
// GET /roadmap/:workspace_slug/:roadmap_slug
export async function handlePublicRoadmap(
  request: Request,
  env: Env
): Promise<Response> {
  const url = new URL(request.url);
  const match = url.pathname.match(/^\/roadmap\/([^/]+)\/([^/]+)$/);

  if (!match) return notFound();

  const [, workspaceSlug, roadmapSlug] = match;

  // Look up workspace and roadmap
  const workspace = await env.DB.prepare(`
    SELECT id, name FROM workspaces WHERE slug = ?
  `).bind(workspaceSlug).first<{ id: string; name: string }>();

  if (!workspace) return notFound();

  const roadmap = await env.DB.prepare(`
    SELECT * FROM roadmaps WHERE workspace_id = ? AND slug = ? AND is_public = 1
  `).bind(workspace.id, roadmapSlug).first();

  if (!roadmap) return notFound();

  const roadmapData = await getRoadmapWithPhases(env, roadmap.id);

  // Get branding
  const branding = await getBrandingConfig(env, workspace.id);

  // Render HTML
  const html = renderPublicRoadmap(roadmapData, workspace, branding);

  return new Response(html, {
    headers: {
      'Content-Type': 'text/html; charset=utf-8',
      'Cache-Control': 'public, max-age=300' // 5 min cache
    }
  });
}

function renderPublicRoadmap(
  roadmap: Roadmap & { phases: RoadmapPhase[] },
  workspace: { name: string },
  branding: BrandingConfig
): string {
  const title = `${roadmap.name} | ${workspace.name}`;
  const description = roadmap.description || `See what we're working on at ${workspace.name}`;

  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>${escapeHtml(title)}</title>
  <meta name="description" content="${escapeHtml(description)}">

  <!-- Open Graph -->
  <meta property="og:title" content="${escapeHtml(title)}">
  <meta property="og:description" content="${escapeHtml(description)}">
  <meta property="og:type" content="website">
  <meta property="og:url" content="${escapeHtml(roadmap.public_url)}">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${escapeHtml(title)}">
  <meta name="twitter:description" content="${escapeHtml(description)}">

  <style>
    :root {
      --cv-primary: ${branding.colors.primary};
      --cv-accent: ${branding.colors.accent};
      --cv-background: ${branding.colors.background};
      --cv-text: ${branding.colors.text};
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: ${branding.font_family}; background: var(--cv-background); color: var(--cv-text); }

    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; margin-bottom: 40px; }
    .header h1 { font-size: 2rem; margin-bottom: 10px; }
    .header p { color: #6b7280; }

    .kanban { display: flex; gap: 20px; overflow-x: auto; padding-bottom: 20px; }
    .phase { flex: 1; min-width: 280px; max-width: 350px; }
    .phase-header { padding: 15px; border-radius: 10px 10px 0 0; color: white; }
    .phase-header h2 { font-size: 1.1rem; }
    .phase-items { background: #f3f4f6; padding: 10px; min-height: 400px; border-radius: 0 0 10px 10px; }

    .item { background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: box-shadow 0.2s; }
    .item:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .item-title { font-weight: 600; margin-bottom: 8px; }
    .item-meta { display: flex; justify-content: space-between; font-size: 0.85rem; color: #6b7280; }
    .item-votes { display: flex; align-items: center; gap: 5px; }
    .item-votes svg { width: 16px; height: 16px; }
    .item-tags { display: flex; gap: 5px; margin-top: 8px; flex-wrap: wrap; }
    .tag { font-size: 0.75rem; padding: 2px 8px; border-radius: 12px; background: #e5e7eb; }

    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
    .modal { background: white; border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; }
    .modal-header { padding: 20px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; }
    .modal-body { padding: 20px; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; }

    ${branding.show_powered_by ? `
    .powered-by { text-align: center; margin-top: 40px; font-size: 0.85rem; color: #9ca3af; }
    .powered-by a { color: #6b7280; }
    ` : ''}

    @media (max-width: 768px) {
      .kanban { flex-direction: column; }
      .phase { max-width: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      ${branding.custom_logo_url ? `<img src="${branding.custom_logo_url}" alt="" style="max-height: 40px; margin-bottom: 10px;">` : ''}
      <h1>${escapeHtml(roadmap.name)}</h1>
      ${roadmap.description ? `<p>${escapeHtml(roadmap.description)}</p>` : ''}
    </header>

    <div class="kanban">
      ${roadmap.phases.map(phase => `
        <div class="phase">
          <div class="phase-header" style="background: ${phase.color}">
            <h2>${phase.icon || ''} ${escapeHtml(phase.name)}</h2>
            ${phase.description ? `<p style="font-size: 0.85rem; opacity: 0.9;">${escapeHtml(phase.description)}</p>` : ''}
          </div>
          <div class="phase-items">
            ${(phase.items || []).map(item => `
              <div class="item" data-item-id="${item.id}" onclick="showItemDetails('${item.id}')">
                <div class="item-title">${escapeHtml(item.title)}</div>
                <div class="item-meta">
                  ${roadmap.show_vote_counts ? `
                    <div class="item-votes">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
                      ${item.vote_count}
                    </div>
                  ` : ''}
                  ${item.target_date ? `<span>${new Date(item.target_date).toLocaleDateString()}</span>` : ''}
                </div>
                ${item.tags && item.tags.length ? `
                  <div class="item-tags">
                    ${item.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}
                  </div>
                ` : ''}
              </div>
            `).join('')}
          </div>
        </div>
      `).join('')}
    </div>

    ${branding.show_powered_by ? `
      <div class="powered-by">
        Powered by <a href="https://collective-vision.com">Collective Vision</a>
      </div>
    ` : ''}
  </div>

  <div class="modal-overlay" id="modal">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modal-title"></h3>
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>
      <div class="modal-body" id="modal-body"></div>
    </div>
  </div>

  <script>
    const items = ${JSON.stringify(roadmap.phases.flatMap(p => p.items || []))};

    function showItemDetails(id) {
      const item = items.find(i => i.id === id);
      if (!item) return;

      document.getElementById('modal-title').textContent = item.title;
      document.getElementById('modal-body').innerHTML = item.description || 'No description provided.';
      document.getElementById('modal').style.display = 'flex';
    }

    function closeModal() {
      document.getElementById('modal').style.display = 'none';
    }

    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });
  </script>
</body>
</html>
  `;
}
```

**Acceptance Criteria**:
- [ ] Public URLs SEO-friendly
- [ ] Kanban layout responsive
- [ ] Item details in modal
- [ ] Vote counts displayed

---

### Task 7.1.4: Status Updates & Changelogs (2h)

Enable changelog entries linked to roadmap items.

**Subtasks**:
- [ ] Changelog data model
- [ ] Changelog CRUD API
- [ ] Public changelog page
- [ ] Link to roadmap items

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS changelogs (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL, -- Markdown
  version TEXT, -- e.g., "2.5.0"
  category TEXT DEFAULT 'update', -- 'feature', 'improvement', 'bugfix', 'update'
  is_published INTEGER DEFAULT 0,
  published_at TEXT,
  author_id TEXT REFERENCES team_members(id),
  roadmap_items TEXT, -- JSON array of item IDs
  feedback_items TEXT, -- JSON array of feedback IDs addressed
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_changelogs_workspace ON changelogs(workspace_id, published_at DESC);
CREATE INDEX idx_changelogs_published ON changelogs(workspace_id, is_published);
```

**Implementation**:
```typescript
// src/services/changelogs.ts
interface Changelog {
  id: string;
  title: string;
  content: string;
  version: string | null;
  category: string;
  is_published: boolean;
  published_at: string | null;
  roadmap_items: string[];
  feedback_items: string[];
}

export async function publishChangelog(
  env: Env,
  changelogId: string
): Promise<void> {
  await env.DB.prepare(`
    UPDATE changelogs
    SET is_published = 1, published_at = datetime('now'), updated_at = datetime('now')
    WHERE id = ?
  `).bind(changelogId).run();

  // Notify subscribers
  const changelog = await env.DB.prepare(`
    SELECT * FROM changelogs WHERE id = ?
  `).bind(changelogId).first<Changelog>();

  if (changelog) {
    await env.QUEUES.send({
      type: 'changelog_published',
      changelog_id: changelogId,
      workspace_id: changelog.workspace_id
    });
  }
}

export async function getPublicChangelogs(
  env: Env,
  workspaceId: string,
  limit = 20,
  offset = 0
): Promise<Changelog[]> {
  const results = await env.DB.prepare(`
    SELECT * FROM changelogs
    WHERE workspace_id = ? AND is_published = 1
    ORDER BY published_at DESC
    LIMIT ? OFFSET ?
  `).bind(workspaceId, limit, offset).all<Changelog>();

  return results.results.map(c => ({
    ...c,
    roadmap_items: JSON.parse(c.roadmap_items || '[]'),
    feedback_items: JSON.parse(c.feedback_items || '[]')
  }));
}
```

**Acceptance Criteria**:
- [ ] Changelogs with markdown content
- [ ] Version tags optional
- [ ] Links to roadmap items
- [ ] Public changelog page

---

### Task 7.1.5: Subscriber Notifications (2h)

Enable users to subscribe to roadmap updates.

**Subtasks**:
- [ ] Subscription management
- [ ] Email on changelog publish
- [ ] Email on item status change
- [ ] Unsubscribe handling

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS roadmap_subscriptions (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  roadmap_id TEXT NOT NULL REFERENCES roadmaps(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  user_id TEXT REFERENCES end_users(id),
  preferences TEXT DEFAULT '{}', -- JSON: { changelog: true, status_updates: true, digest: 'weekly' }
  confirmed INTEGER DEFAULT 0,
  confirmation_token TEXT,
  unsubscribe_token TEXT NOT NULL,
  created_at TEXT DEFAULT (datetime('now')),
  UNIQUE(roadmap_id, email)
);

CREATE INDEX idx_subscriptions_roadmap ON roadmap_subscriptions(roadmap_id, confirmed);
```

**Implementation**:
```typescript
// src/services/roadmap-notifications.ts
export async function subscribe(
  env: Env,
  roadmapId: string,
  email: string,
  preferences: Record<string, unknown> = {}
): Promise<{ confirmation_required: boolean }> {
  const unsubscribeToken = crypto.randomUUID();
  const confirmationToken = crypto.randomUUID();

  await env.DB.prepare(`
    INSERT INTO roadmap_subscriptions (
      roadmap_id, email, preferences, unsubscribe_token, confirmation_token
    ) VALUES (?, ?, ?, ?, ?)
    ON CONFLICT(roadmap_id, email) DO UPDATE SET
      preferences = ?, updated_at = datetime('now')
  `).bind(
    roadmapId, email, JSON.stringify(preferences),
    unsubscribeToken, confirmationToken,
    JSON.stringify(preferences)
  ).run();

  // Send confirmation email
  await env.QUEUES.send({
    type: 'confirm_subscription',
    email,
    roadmap_id: roadmapId,
    confirmation_token: confirmationToken
  });

  return { confirmation_required: true };
}

export async function notifySubscribers(
  env: Env,
  roadmapId: string,
  notificationType: 'changelog' | 'status_update',
  data: Record<string, unknown>
): Promise<number> {
  const subscribers = await env.DB.prepare(`
    SELECT * FROM roadmap_subscriptions
    WHERE roadmap_id = ? AND confirmed = 1
  `).bind(roadmapId).all();

  let notified = 0;

  for (const sub of subscribers.results) {
    const prefs = JSON.parse(sub.preferences || '{}');

    // Check preferences
    if (notificationType === 'changelog' && prefs.changelog !== false) {
      await env.QUEUES.send({
        type: 'send_roadmap_notification',
        email: sub.email,
        notification_type: notificationType,
        data,
        unsubscribe_token: sub.unsubscribe_token
      });
      notified++;
    }

    if (notificationType === 'status_update' && prefs.status_updates !== false) {
      await env.QUEUES.send({
        type: 'send_roadmap_notification',
        email: sub.email,
        notification_type: notificationType,
        data,
        unsubscribe_token: sub.unsubscribe_token
      });
      notified++;
    }
  }

  return notified;
}

export async function unsubscribe(
  env: Env,
  token: string
): Promise<boolean> {
  const result = await env.DB.prepare(`
    DELETE FROM roadmap_subscriptions WHERE unsubscribe_token = ?
  `).bind(token).run();

  return result.meta.changes > 0;
}
```

**Acceptance Criteria**:
- [ ] Email subscription with confirmation
- [ ] Notifications on changelog publish
- [ ] Notifications on item status change
- [ ] One-click unsubscribe

---

## Definition of Done
- [ ] Public roadmap pages live
- [ ] Kanban layout responsive
- [ ] Changelogs publishing
- [ ] Subscriber notifications working
- [ ] SEO meta tags complete

## Technical Notes
- Public pages cached for 5 minutes
- Subscriber notifications via queue
- Changelogs support markdown
- Mobile-first kanban design

## Related Files
- `src/services/roadmaps.ts` - Roadmap logic
- `src/services/changelogs.ts` - Changelog management
- `src/services/roadmap-notifications.ts` - Subscriber notifications
- `src/routes/public/roadmap.ts` - Public page rendering
