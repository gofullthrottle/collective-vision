# Epic 3.4: Agent Framework Integration

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Enable agent ecosystems with documentation, SDKs, and webhooks
**Tools**: LangChain, documentation, webhook system

## Wave Context
**Wave**: 3 - MCP Server + Agent Integration
**Priority**: P1 (enables agent ecosystem)
**Dependencies**: Epic 3.1-3.3 (MCP tools)
**Estimated Duration**: 6 hours

## Quality Requirements
- Documentation copy-paste ready
- LangChain integration tested
- Webhooks delivered reliably with retries
- Examples work out of the box

---

## Tasks

### 3.4.1 MCP Documentation (2h)
**Objective**: Complete documentation for agent developers

**Steps**:
1. Create main MCP README:
   ```markdown
   <!-- docs/mcp/README.md -->

   # Collective Vision MCP Server

   The Collective Vision MCP server enables AI agents to interact with your
   feedback system programmatically.

   ## Quick Start

   1. Generate an API key in your workspace settings
   2. Configure your agent with the MCP endpoint
   3. Start querying and submitting feedback

   ## Endpoints

   - `POST /mcp` - Main MCP endpoint (JSON-RPC 2.0)
   - `GET /mcp/.well-known/mcp.json` - Discovery

   ## Authentication

   Include your API key in the Authorization header:

   ```
   Authorization: Bearer cv_mcp_xxxxx
   ```

   Or in tool parameters:

   ```json
   {
     "method": "tools/call",
     "params": {
       "name": "list_feedback",
       "arguments": {
         "api_key": "cv_mcp_xxxxx", // pragma: allowlist secret
         "board_slug": "main"
       }
     }
   }
   ```

   ## Available Tools

   | Tool | Scope | Description |
   |------|-------|-------------|
   | `list_feedback` | read | List feedback with filters |
   | `get_feedback` | read | Get single feedback details |
   | `search_feedback` | read | Semantic search |
   | `get_themes` | read | Get themes with trends |
   | `get_trends` | read | Trending topics and anomalies |
   | `get_statistics` | read | Aggregate statistics |
   | `submit_feedback` | write | Create new feedback |
   | `vote_feedback` | write | Vote on feedback |
   | `add_comment` | write | Add comment |
   | `update_status` | admin | Update status |

   ## Rate Limits

   - 100 requests per minute per API key
   - Rate limit errors include `retry_after` in seconds

   ## Moderation

   Feedback submitted via MCP goes to moderation by default unless
   your workspace has auto-approve enabled.
   ```

2. Create tools reference:
   ```markdown
   <!-- docs/mcp/tools-reference.md -->

   # MCP Tools Reference

   Complete reference for all Collective Vision MCP tools.

   ## Query Tools

   ### list_feedback

   List feedback items with comprehensive filters.

   **Scope:** `read`

   **Input:**
   ```json
   {
     "board_slug": "main",           // required
     "status": ["open", "planned"],  // optional
     "tags": ["bug", "feature"],     // optional
     "theme_id": "theme_xxx",        // optional
     "sentiment_min": -0.5,          // optional
     "sentiment_max": 0.5,           // optional
     "urgency_min": 0.7,             // optional
     "priority_min": 70,             // optional
     "created_after": "2024-01-01",  // optional, ISO date
     "created_before": "2024-12-31", // optional
     "limit": 20,                    // default 20, max 100
     "offset": 0,                    // default 0
     "sort_by": "priority",          // votes|created_at|priority|sentiment
     "sort_order": "desc"            // asc|desc
   }
   ```

   **Output:**
   ```json
   {
     "items": [
       {
         "id": "fb_xxx",
         "title": "...",
         "description": "...",
         "status": "open",
         "vote_count": 42,
         "sentiment_score": 0.3,
         "priority_score": 75,
         "created_at": "2024-01-15T10:30:00Z"
       }
     ],
     "total": 150,
     "has_more": true
   }
   ```

   ### search_feedback

   Semantic search across feedback using natural language.

   **Scope:** `read`

   **Input:**
   ```json
   {
     "query": "mobile app crashes on login",
     "board_slug": "main",           // optional
     "status": ["open"],             // optional
     "limit": 10                     // default 10, max 50
   }
   ```

   **Output:**
   ```json
   {
     "items": [
       {
         "feedback": { ... },
         "similarity_score": 0.92
       }
     ]
   }
   ```

   ## Write Tools

   ### submit_feedback

   Submit new feedback on behalf of a user.

   **Scope:** `write`

   **Input:**
   ```json
   {
     "board_slug": "main",
     "title": "Feature request: Dark mode",
     "description": "Would love to have...",
     "source_context": {
       "agent_id": "my-agent",
       "original_source": "slack",
       "original_url": "https://...",
       "user_identifier": "user@example.com"
     }
   }
   ```

   **Output:**
   ```json
   {
     "feedback_id": "fb_xxx",
     "status": "pending_moderation",
     "message": "Feedback submitted and pending moderation review"
   }
   ```
   ```

3. Create authentication guide:
   ```markdown
   <!-- docs/mcp/authentication.md -->

   # MCP Authentication

   ## API Keys

   Generate API keys from your workspace settings:

   1. Go to Settings > Integrations > MCP
   2. Click "Create API Key"
   3. Choose scopes: read, write, or admin
   4. Copy the key (shown only once)

   ## Scopes

   | Scope | Permissions |
   |-------|-------------|
   | `read` | Query feedback, themes, statistics |
   | `write` | Submit feedback, vote, comment |
   | `admin` | Update status, access internal data |

   ## Key Format

   Keys follow the format: `cv_mcp_<32 random characters>`

   Example: `cv_mcp_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6`

   ## Security

   - Keys are hashed before storage (we can't recover lost keys)
   - Keys can be revoked instantly
   - Set expiration dates for temporary access
   - Monitor usage in the API key dashboard
   ```

4. Create examples document:
   ```markdown
   <!-- docs/mcp/examples.md -->

   # MCP Integration Examples

   ## Claude Desktop Configuration

   Add to your Claude desktop config:

   ```json
   {
     "mcpServers": {
       "collective-vision": {
         "url": "https://your-domain.com/mcp",
         "headers": {
           "Authorization": "Bearer cv_mcp_xxxxx"
         }
       }
     }
   }
   ```

   ## Raw JSON-RPC Request

   ```bash
   curl -X POST https://your-domain.com/mcp \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer cv_mcp_xxxxx" \
     -d '{
       "jsonrpc": "2.0",
       "id": 1,
       "method": "tools/call",
       "params": {
         "name": "list_feedback",
         "arguments": {
           "board_slug": "main",
           "limit": 5
         }
       }
     }'
   ```

   ## Python Client

   ```python
   import httpx

   class CollectiveVisionMCP:
       def __init__(self, api_key: str, base_url: str):
           self.api_key = api_key
           self.base_url = base_url
           self._request_id = 0

       def call_tool(self, name: str, arguments: dict) -> dict:
           self._request_id += 1
           response = httpx.post(
               f"{self.base_url}/mcp",
               headers={"Authorization": f"Bearer {self.api_key}"},
               json={
                   "jsonrpc": "2.0",
                   "id": self._request_id,
                   "method": "tools/call",
                   "params": {"name": name, "arguments": arguments}
               }
           )
           return response.json()["result"]

       def list_feedback(self, board_slug: str, **filters):
           return self.call_tool("list_feedback", {"board_slug": board_slug, **filters})

       def search(self, query: str, **filters):
           return self.call_tool("search_feedback", {"query": query, **filters})

   # Usage
   cv = CollectiveVisionMCP("cv_mcp_xxxxx", "https://your-domain.com")
   results = cv.search("mobile crashes")
   ```
   ```

**Acceptance Criteria**:
- [ ] Complete tool documentation
- [ ] Authentication guide
- [ ] Working examples
- [ ] Copy-paste ready configs

---

### 3.4.2 LangChain Tool Wrappers (2h)
**Objective**: Create LangChain-compatible tool wrappers

**Steps**:
1. Create Python package:
   ```python
   # collective_vision/tools.py

   from typing import Optional, List, Dict, Any
   from langchain.tools import BaseTool
   from pydantic import BaseModel, Field
   import httpx


   class CollectiveVisionClient:
       """Client for Collective Vision MCP API."""

       def __init__(self, api_key: str, base_url: str = "https://api.collectivevision.io"):
           self.api_key = api_key
           self.base_url = base_url
           self._request_id = 0

       def _call(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
           self._request_id += 1
           with httpx.Client() as client:
               response = client.post(
                   f"{self.base_url}/mcp",
                   headers={
                       "Authorization": f"Bearer {self.api_key}",
                       "Content-Type": "application/json"
                   },
                   json={
                       "jsonrpc": "2.0",
                       "id": self._request_id,
                       "method": "tools/call",
                       "params": {"name": tool_name, "arguments": arguments}
                   },
                   timeout=30.0
               )
               result = response.json()
               if "error" in result:
                   raise Exception(f"MCP Error: {result['error']['message']}")
               return result.get("result", {})


   class ListFeedbackInput(BaseModel):
       board_slug: str = Field(description="The board to list feedback from")
       status: Optional[List[str]] = Field(None, description="Filter by status")
       limit: int = Field(20, description="Max items to return")


   class ListFeedbackTool(BaseTool):
       """Tool for listing feedback from Collective Vision."""

       name: str = "list_feedback"
       description: str = """
       List feedback items from a Collective Vision board.
       Use this to get an overview of user feedback, feature requests, or bug reports.
       """
       args_schema: type = ListFeedbackInput
       client: CollectiveVisionClient

       def _run(self, board_slug: str, status: List[str] = None, limit: int = 20) -> str:
           result = self.client._call("list_feedback", {
               "board_slug": board_slug,
               "status": status,
               "limit": limit
           })
           items = result.get("items", [])
           if not items:
               return "No feedback items found."

           output = f"Found {result.get('total', len(items))} items:\n\n"
           for item in items:
               output += f"- [{item['status']}] {item['title']} ({item['vote_count']} votes)\n"
           return output


   class SearchFeedbackInput(BaseModel):
       query: str = Field(description="Natural language search query")
       board_slug: Optional[str] = Field(None, description="Limit to specific board")


   class SearchFeedbackTool(BaseTool):
       """Tool for semantic search across feedback."""

       name: str = "search_feedback"
       description: str = """
       Search feedback using natural language. Use this to find feedback
       related to specific topics, features, or issues.
       """
       args_schema: type = SearchFeedbackInput
       client: CollectiveVisionClient

       def _run(self, query: str, board_slug: str = None) -> str:
           args = {"query": query}
           if board_slug:
               args["board_slug"] = board_slug

           result = self.client._call("search_feedback", args)
           items = result.get("items", [])
           if not items:
               return f"No feedback found matching: {query}"

           output = f"Found {len(items)} relevant items:\n\n"
           for item in items:
               fb = item["feedback"]
               score = item["similarity_score"]
               output += f"- {fb['title']} (relevance: {score:.0%})\n"
               if fb.get("description"):
                   output += f"  {fb['description'][:100]}...\n"
           return output


   class SubmitFeedbackInput(BaseModel):
       board_slug: str = Field(description="Board to submit to")
       title: str = Field(description="Feedback title")
       description: Optional[str] = Field(None, description="Detailed description")


   class SubmitFeedbackTool(BaseTool):
       """Tool for submitting new feedback."""

       name: str = "submit_feedback"
       description: str = """
       Submit new feedback to Collective Vision. Use this to capture
       user requests or issues discovered during conversation.
       """
       args_schema: type = SubmitFeedbackInput
       client: CollectiveVisionClient

       def _run(self, board_slug: str, title: str, description: str = None) -> str:
           result = self.client._call("submit_feedback", {
               "board_slug": board_slug,
               "title": title,
               "description": description
           })
           return f"Feedback submitted: {result.get('feedback_id')} ({result.get('status')})"


   def get_collective_vision_tools(api_key: str, base_url: str = None) -> List[BaseTool]:
       """Get all Collective Vision tools configured with the given API key."""
       client = CollectiveVisionClient(api_key, base_url or "https://api.collectivevision.io")
       return [
           ListFeedbackTool(client=client),
           SearchFeedbackTool(client=client),
           SubmitFeedbackTool(client=client),
       ]
   ```

2. Create package setup:
   ```python
   # pyproject.toml

   [project]
   name = "collective-vision-langchain"
   version = "0.1.0"
   description = "LangChain tools for Collective Vision feedback platform"
   requires-python = ">=3.9"
   dependencies = [
       "langchain>=0.1.0",
       "httpx>=0.25.0",
       "pydantic>=2.0.0"
   ]

   [project.optional-dependencies]
   dev = ["pytest", "pytest-asyncio"]
   ```

3. Create usage example:
   ```python
   # examples/langchain_agent.py

   from langchain.agents import initialize_agent, AgentType
   from langchain_openai import ChatOpenAI
   from collective_vision import get_collective_vision_tools

   # Initialize
   tools = get_collective_vision_tools(
       api_key="cv_mcp_xxxxx",
       base_url="https://your-domain.com"
   )

   llm = ChatOpenAI(model="gpt-4")
   agent = initialize_agent(
       tools,
       llm,
       agent=AgentType.OPENAI_FUNCTIONS,
       verbose=True
   )

   # Query
   result = agent.run("What are the top feature requests from users?")
   print(result)
   ```

**Acceptance Criteria**:
- [ ] LangChain tools work with standard agents
- [ ] Easy to install and configure
- [ ] Well documented
- [ ] Handles errors gracefully

---

### 3.4.3 Webhook System (2h)
**Objective**: Deliver events to external systems reliably

**Steps**:
1. Create webhook tables:
   ```sql
   CREATE TABLE webhooks (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     url TEXT NOT NULL,
     secret TEXT NOT NULL,  -- For signature
     events TEXT NOT NULL,  -- JSON array of event types
     is_active INTEGER DEFAULT 1,
     created_by TEXT NOT NULL,
     created_at TEXT DEFAULT (datetime('now')),
     updated_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   CREATE TABLE webhook_deliveries (
     id TEXT PRIMARY KEY,
     webhook_id TEXT NOT NULL,
     event_type TEXT NOT NULL,
     payload TEXT NOT NULL,
     response_status INTEGER,
     response_body TEXT,
     attempt_count INTEGER DEFAULT 0,
     next_retry_at TEXT,
     delivered_at TEXT,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (webhook_id) REFERENCES webhooks(id)
   );

   CREATE INDEX idx_webhook_deliveries_pending ON webhook_deliveries(next_retry_at)
     WHERE delivered_at IS NULL;
   CREATE INDEX idx_webhooks_workspace ON webhooks(workspace_id, is_active);
   ```

2. Implement webhook API:
   ```typescript
   // src/routes/webhooks.ts

   const WebhookCreateSchema = z.object({
     name: z.string().min(1).max(100),
     url: z.string().url(),
     events: z.array(z.enum([
       'feedback.created',
       'feedback.status_changed',
       'feedback.duplicate_detected',
       'theme.new_detected',
       'theme.spike_detected',
       'comment.created'
     ])).min(1)
   });

   // POST /api/v1/workspaces/:id/webhooks
   async function createWebhook(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, WebhookCreateSchema);
     const { user } = await requirePermission(request, env, workspaceId, 'workspace:admin');

     const id = generateId('wh');
     const secret = `whsec_${crypto.randomUUID().replace(/-/g, '')}`;

     await env.DB.prepare(`
       INSERT INTO webhooks (id, workspace_id, name, url, secret, events, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?)
     `).bind(
       id,
       workspaceId,
       input.name,
       input.url,
       secret,
       JSON.stringify(input.events),
       user.id
     ).run();

     return jsonResponse({
       id,
       name: input.name,
       url: input.url,
       events: input.events,
       secret  // Only returned at creation
     }, 201);
   }

   // GET /api/v1/workspaces/:id/webhooks
   async function listWebhooks(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'workspace:admin');

     const webhooks = await env.DB.prepare(`
       SELECT id, name, url, events, is_active, created_at
       FROM webhooks
       WHERE workspace_id = ?
       ORDER BY created_at DESC
     `).bind(workspaceId).all();

     return jsonResponse({ webhooks: webhooks.results });
   }

   // DELETE /api/v1/workspaces/:id/webhooks/:webhookId
   async function deleteWebhook(request: Request, env: Env): Promise<Response> {
     const { workspaceId, webhookId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'workspace:admin');

     await env.DB.prepare(`
       DELETE FROM webhooks WHERE id = ? AND workspace_id = ?
     `).bind(webhookId, workspaceId).run();

     return jsonResponse({ deleted: true });
   }
   ```

3. Implement event dispatch:
   ```typescript
   // src/lib/webhooks/dispatch.ts

   interface WebhookEvent {
     type: string;
     timestamp: string;
     data: unknown;
   }

   export async function dispatchWebhookEvent(
     workspaceId: string,
     event: WebhookEvent,
     env: Env
   ): Promise<void> {
     // Get active webhooks for this event type
     const webhooks = await env.DB.prepare(`
       SELECT id, url, secret, events
       FROM webhooks
       WHERE workspace_id = ? AND is_active = 1
     `).bind(workspaceId).all();

     for (const webhook of webhooks.results) {
       const events = JSON.parse(webhook.events as string);
       if (!events.includes(event.type)) continue;

       // Queue delivery
       const deliveryId = generateId('whd');
       const payload = JSON.stringify({
         event: event.type,
         timestamp: event.timestamp,
         data: event.data
       });

       await env.DB.prepare(`
         INSERT INTO webhook_deliveries (id, webhook_id, event_type, payload, next_retry_at)
         VALUES (?, ?, ?, ?, datetime('now'))
       `).bind(deliveryId, webhook.id, event.type, payload).run();

       // Try immediate delivery
       await deliverWebhook(deliveryId, env);
     }
   }

   async function deliverWebhook(deliveryId: string, env: Env): Promise<void> {
     const delivery = await env.DB.prepare(`
       SELECT wd.*, w.url, w.secret
       FROM webhook_deliveries wd
       JOIN webhooks w ON wd.webhook_id = w.id
       WHERE wd.id = ? AND wd.delivered_at IS NULL
     `).bind(deliveryId).first();

     if (!delivery) return;

     // Create signature
     const signature = await signPayload(delivery.payload as string, delivery.secret as string);

     try {
       const response = await fetch(delivery.url as string, {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-Webhook-Signature': `sha256=${signature}`,
           'X-Webhook-Timestamp': new Date().toISOString()
         },
         body: delivery.payload as string
       });

       const responseBody = await response.text().catch(() => '');

       await env.DB.prepare(`
         UPDATE webhook_deliveries
         SET response_status = ?, response_body = ?, attempt_count = attempt_count + 1,
             delivered_at = CASE WHEN ? < 300 THEN datetime('now') ELSE NULL END,
             next_retry_at = CASE WHEN ? >= 300 THEN datetime('now', '+' || ((attempt_count + 1) * 60) || ' seconds') ELSE NULL END
         WHERE id = ?
       `).bind(
         response.status,
         responseBody.substring(0, 1000),
         response.status,
         response.status,
         deliveryId
       ).run();
     } catch (error) {
       // Network error - schedule retry
       await env.DB.prepare(`
         UPDATE webhook_deliveries
         SET attempt_count = attempt_count + 1,
             next_retry_at = datetime('now', '+' || ((attempt_count + 1) * 60) || ' seconds'),
             response_body = ?
         WHERE id = ?
       `).bind(
         error instanceof Error ? error.message : 'Unknown error',
         deliveryId
       ).run();
     }
   }

   async function signPayload(payload: string, secret: string): Promise<string> {
     const encoder = new TextEncoder();
     const key = await crypto.subtle.importKey(
       'raw',
       encoder.encode(secret),
       { name: 'HMAC', hash: 'SHA-256' },
       false,
       ['sign']
     );
     const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(payload));
     return Array.from(new Uint8Array(signature))
       .map(b => b.toString(16).padStart(2, '0'))
       .join('');
   }
   ```

4. Create retry worker:
   ```typescript
   // src/lib/webhooks/retry.ts

   export async function processWebhookRetries(env: Env): Promise<{ processed: number }> {
     const pending = await env.DB.prepare(`
       SELECT id FROM webhook_deliveries
       WHERE delivered_at IS NULL
         AND next_retry_at <= datetime('now')
         AND attempt_count < 5
       LIMIT 50
     `).all();

     for (const delivery of pending.results) {
       await deliverWebhook(delivery.id as string, env);
     }

     // Clean up old failed deliveries (> 7 days)
     await env.DB.prepare(`
       DELETE FROM webhook_deliveries
       WHERE delivered_at IS NULL AND attempt_count >= 5
         AND created_at < datetime('now', '-7 days')
     `).run();

     return { processed: pending.results.length };
   }
   ```

5. Integrate with feedback events:
   ```typescript
   // src/routes/feedback.ts - add to createFeedback

   // After creating feedback
   await dispatchWebhookEvent(workspaceId, {
     type: 'feedback.created',
     timestamp: new Date().toISOString(),
     data: {
       feedback_id: feedbackId,
       board_id: boardId,
       title: input.title,
       source: 'widget'
     }
   }, env);
   ```

**Acceptance Criteria**:
- [ ] Webhook CRUD API working
- [ ] Events dispatched on actions
- [ ] Signatures verifiable
- [ ] Retries with exponential backoff
- [ ] Failed webhooks cleaned up

---

## Definition of Done
- [ ] Complete MCP documentation
- [ ] LangChain tools published/documented
- [ ] Webhook system functional
- [ ] At least one external agent tested
- [ ] Examples work out of the box

## Technical Notes
- Webhook retries: 5 attempts with exponential backoff (1, 2, 4, 8, 16 min)
- Signature: HMAC-SHA256 of payload
- LangChain package: Python 3.9+
- Consider OpenAPI spec generation for tools

## Related Files
- `docs/mcp/README.md` - Main documentation
- `docs/mcp/tools-reference.md` - Tool reference
- `docs/mcp/authentication.md` - Auth guide
- `docs/mcp/examples.md` - Integration examples
- `src/routes/webhooks.ts` - Webhook API
- `src/lib/webhooks/dispatch.ts` - Event dispatch
- `collective-vision-langchain/` - Python package
