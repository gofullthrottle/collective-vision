# Epic 8.3: Testing & Quality

**Wave**: 8 - Enterprise Polish
**Epic**: Testing & Quality
**Estimated Hours**: 10h
**Priority**: P0 (Launch Critical)
**Dependencies**: All previous waves

---

## Overview

Establish comprehensive testing infrastructure with unit tests (80%+ coverage), integration tests, E2E tests with Playwright, and complete API documentation for enterprise-grade quality assurance.

---

## Methodology Guidance

### SPECTRA Phase: Assure
This epic is purely about quality assurance:
- Validate all implementations work correctly
- Document all APIs for consumers
- Ensure regression prevention

### Quality Bar
- 80%+ unit test coverage
- All API endpoints integration tested
- Critical user flows E2E tested
- OpenAPI spec complete and validated

---

## Wave Context

Wave 8 ensures production readiness. Testing and quality establishes:
- Regression prevention for future development
- Confidence in deployment
- Clear API contracts for integrations
- Developer experience for API consumers

---

## Tasks

### Task 8.3.1: Unit Testing Infrastructure (3h)

Set up Vitest for unit testing with coverage.

#### Subtask 8.3.1.1: Testing Framework Setup (1h)

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'miniflare',
    environmentOptions: {
      modules: true,
      d1Databases: ['DB'],
      kvNamespaces: ['KV'],
      r2Buckets: ['ATTACHMENTS'],
    },
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/**',
        'tests/**',
        '**/*.d.ts',
        'vitest.config.ts',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80,
      },
    },
    setupFiles: ['./tests/setup.ts'],
  },
});

// tests/setup.ts
import { beforeAll, afterAll, beforeEach } from 'vitest';
import { createTestEnv } from './helpers/env';

let testEnv: ReturnType<typeof createTestEnv>;

beforeAll(async () => {
  testEnv = await createTestEnv();
});

afterAll(async () => {
  await testEnv.cleanup();
});

beforeEach(async () => {
  await testEnv.reset();
});

// tests/helpers/env.ts
import { Miniflare } from 'miniflare';

export async function createTestEnv() {
  const mf = new Miniflare({
    modules: true,
    script: '',
    d1Databases: { DB: 'test-db' },
    kvNamespaces: { KV: 'test-kv' },
  });

  const db = await mf.getD1Database('DB');
  const kv = await mf.getKVNamespace('KV');

  // Apply schema
  const schema = await Bun.file('./schema.sql').text();
  for (const statement of schema.split(';').filter(s => s.trim())) {
    await db.exec(statement);
  }

  return {
    mf,
    db,
    kv,
    cleanup: async () => await mf.dispose(),
    reset: async () => {
      // Clear all tables
      await db.exec('DELETE FROM feedback_votes');
      await db.exec('DELETE FROM feedback_comments');
      await db.exec('DELETE FROM feedback_items');
      await db.exec('DELETE FROM boards');
      await db.exec('DELETE FROM end_users');
      await db.exec('DELETE FROM workspaces');
    },
  };
}
```

#### Subtask 8.3.1.2: Core Function Unit Tests (2h)

```typescript
// tests/unit/feedback.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createFeedback, listFeedback, voteFeedback } from '../../src/services/feedback';
import { createTestEnv } from '../helpers/env';

describe('Feedback Service', () => {
  let env: Awaited<ReturnType<typeof createTestEnv>>;
  let workspaceId: number;
  let boardId: number;
  let userId: number;

  beforeEach(async () => {
    env = await createTestEnv();

    // Create test workspace and board
    const ws = await env.db.prepare(
      'INSERT INTO workspaces (slug, name) VALUES (?, ?) RETURNING id'
    ).bind('test-ws', 'Test Workspace').first();
    workspaceId = ws!.id as number;

    const board = await env.db.prepare(
      'INSERT INTO boards (workspace_id, slug, name) VALUES (?, ?, ?) RETURNING id'
    ).bind(workspaceId, 'main', 'Main Board').first();
    boardId = board!.id as number;

    const user = await env.db.prepare(
      'INSERT INTO end_users (workspace_id, external_user_id) VALUES (?, ?) RETURNING id'
    ).bind(workspaceId, 'test-user').first();
    userId = user!.id as number;
  });

  describe('createFeedback', () => {
    it('creates feedback with required fields', async () => {
      const result = await createFeedback(env.db, {
        boardId,
        userId,
        title: 'Test Feedback',
        description: 'Description here',
        source: 'widget',
      });

      expect(result.id).toBeDefined();
      expect(result.title).toBe('Test Feedback');
      expect(result.status).toBe('new');
      expect(result.moderation_state).toBe('approved');
    });

    it('sets pending moderation for API source', async () => {
      const result = await createFeedback(env.db, {
        boardId,
        userId,
        title: 'API Feedback',
        description: 'From API',
        source: 'api',
      });

      expect(result.moderation_state).toBe('pending');
      expect(result.is_hidden).toBe(1);
    });

    it('validates title length', async () => {
      await expect(createFeedback(env.db, {
        boardId,
        userId,
        title: '', // Empty title
        description: 'Description',
        source: 'widget',
      })).rejects.toThrow('Title is required');
    });

    it('sanitizes HTML in title and description', async () => {
      const result = await createFeedback(env.db, {
        boardId,
        userId,
        title: '<script>alert("xss")</script>Test',
        description: '<img onerror="alert(1)" src="">Description',
        source: 'widget',
      });

      expect(result.title).toBe('Test');
      expect(result.description).not.toContain('<img');
    });
  });

  describe('listFeedback', () => {
    beforeEach(async () => {
      // Create test feedback items
      for (let i = 0; i < 15; i++) {
        await createFeedback(env.db, {
          boardId,
          userId,
          title: `Feedback ${i}`,
          description: `Description ${i}`,
          source: 'widget',
        });
      }
    });

    it('returns paginated results', async () => {
      const page1 = await listFeedback(env.db, boardId, { page: 1, limit: 10 });
      expect(page1.items).toHaveLength(10);
      expect(page1.total).toBe(15);
      expect(page1.hasMore).toBe(true);

      const page2 = await listFeedback(env.db, boardId, { page: 2, limit: 10 });
      expect(page2.items).toHaveLength(5);
      expect(page2.hasMore).toBe(false);
    });

    it('filters by status', async () => {
      await env.db.prepare(
        'UPDATE feedback_items SET status = ? WHERE title = ?'
      ).bind('planned', 'Feedback 0').run();

      const result = await listFeedback(env.db, boardId, { status: 'planned' });
      expect(result.items).toHaveLength(1);
      expect(result.items[0].title).toBe('Feedback 0');
    });

    it('excludes hidden items for public queries', async () => {
      await env.db.prepare(
        'UPDATE feedback_items SET is_hidden = 1 WHERE title = ?'
      ).bind('Feedback 0').run();

      const result = await listFeedback(env.db, boardId, { includeHidden: false });
      expect(result.items).toHaveLength(14);
    });
  });

  describe('voteFeedback', () => {
    let feedbackId: number;

    beforeEach(async () => {
      const feedback = await createFeedback(env.db, {
        boardId,
        userId,
        title: 'Voteable Item',
        description: 'Vote on me',
        source: 'widget',
      });
      feedbackId = feedback.id;
    });

    it('adds vote and returns updated count', async () => {
      const result = await voteFeedback(env.db, feedbackId, userId);
      expect(result.voteCount).toBe(1);
      expect(result.userVote).toBe(1);
    });

    it('prevents duplicate votes from same user', async () => {
      await voteFeedback(env.db, feedbackId, userId);
      const result = await voteFeedback(env.db, feedbackId, userId);

      expect(result.voteCount).toBe(1); // Still 1, not 2
      expect(result.alreadyVoted).toBe(true);
    });

    it('allows different users to vote', async () => {
      const user2 = await env.db.prepare(
        'INSERT INTO end_users (workspace_id, external_user_id) VALUES (?, ?) RETURNING id'
      ).bind(workspaceId, 'user-2').first();

      await voteFeedback(env.db, feedbackId, userId);
      const result = await voteFeedback(env.db, feedbackId, user2!.id as number);

      expect(result.voteCount).toBe(2);
    });
  });
});

// tests/unit/deduplication.test.ts
import { describe, it, expect } from 'vitest';
import { findDuplicates, calculateSimilarity } from '../../src/services/deduplication';

describe('Deduplication Service', () => {
  describe('calculateSimilarity', () => {
    it('returns 1.0 for identical embeddings', () => {
      const embedding = new Float32Array([0.1, 0.2, 0.3, 0.4]);
      expect(calculateSimilarity(embedding, embedding)).toBeCloseTo(1.0);
    });

    it('returns 0 for orthogonal embeddings', () => {
      const a = new Float32Array([1, 0, 0, 0]);
      const b = new Float32Array([0, 1, 0, 0]);
      expect(calculateSimilarity(a, b)).toBeCloseTo(0);
    });

    it('returns -1 for opposite embeddings', () => {
      const a = new Float32Array([1, 0, 0, 0]);
      const b = new Float32Array([-1, 0, 0, 0]);
      expect(calculateSimilarity(a, b)).toBeCloseTo(-1);
    });
  });

  describe('findDuplicates', () => {
    it('groups similar feedback items', async () => {
      const items = [
        { id: 1, embedding: [0.9, 0.1, 0.1], title: 'Dark mode' },
        { id: 2, embedding: [0.85, 0.15, 0.1], title: 'Dark theme' },
        { id: 3, embedding: [0.1, 0.9, 0.1], title: 'Export CSV' },
      ];

      const groups = await findDuplicates(items, 0.8);

      expect(groups).toHaveLength(2);
      expect(groups[0].items.map(i => i.id)).toEqual([1, 2]);
      expect(groups[1].items.map(i => i.id)).toEqual([3]);
    });
  });
});
```

**Acceptance Criteria**:
- [ ] Vitest configured with Miniflare
- [ ] 80%+ test coverage achieved
- [ ] All core services unit tested
- [ ] CI runs tests on every PR

---

### Task 8.3.2: Integration Testing (3h)

Test API endpoints with real D1 database.

#### Subtask 8.3.2.1: API Integration Test Suite (2h)

```typescript
// tests/integration/api.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { unstable_dev, UnstableDevWorker } from 'wrangler';

describe('API Integration Tests', () => {
  let worker: UnstableDevWorker;

  beforeAll(async () => {
    worker = await unstable_dev('src/worker.ts', {
      experimental: { disableExperimentalWarning: true },
      local: true,
      persist: false,
    });
  });

  afterAll(async () => {
    await worker.stop();
  });

  describe('Health Check', () => {
    it('GET /health returns ok', async () => {
      const res = await worker.fetch('/health');
      const json = await res.json() as { ok: boolean };

      expect(res.status).toBe(200);
      expect(json.ok).toBe(true);
    });
  });

  describe('Widget', () => {
    it('GET /widget.js returns JavaScript', async () => {
      const res = await worker.fetch('/widget.js');

      expect(res.status).toBe(200);
      expect(res.headers.get('Content-Type')).toContain('javascript');

      const text = await res.text();
      expect(text).toContain('CollectiveVision');
    });
  });

  describe('Feedback API', () => {
    const workspace = 'integration-test';
    const board = 'main';

    it('creates workspace and board on first request', async () => {
      const res = await worker.fetch(
        `/api/v1/${workspace}/${board}/feedback`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: 'Integration test feedback',
            description: 'Created during integration test',
            externalUserId: 'test-user-1',
          }),
        }
      );

      expect(res.status).toBe(201);

      const json = await res.json() as { id: number; title: string };
      expect(json.id).toBeDefined();
      expect(json.title).toBe('Integration test feedback');
    });

    it('lists feedback items', async () => {
      // Create a few items first
      for (let i = 0; i < 3; i++) {
        await worker.fetch(`/api/v1/${workspace}/${board}/feedback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: `Item ${i}`,
            description: `Description ${i}`,
            externalUserId: 'test-user',
          }),
        });
      }

      const res = await worker.fetch(`/api/v1/${workspace}/${board}/feedback`);
      const json = await res.json() as any[];

      expect(res.status).toBe(200);
      expect(json.length).toBeGreaterThanOrEqual(3);
    });

    it('votes on feedback', async () => {
      // Create item
      const createRes = await worker.fetch(
        `/api/v1/${workspace}/${board}/feedback`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: 'Voteable item',
            description: 'Vote test',
            externalUserId: 'creator',
          }),
        }
      );
      const { id } = await createRes.json() as { id: number };

      // Vote
      const voteRes = await worker.fetch(
        `/api/v1/${workspace}/${board}/feedback/${id}/votes`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ externalUserId: 'voter-1' }),
        }
      );

      expect(voteRes.status).toBe(200);

      const vote = await voteRes.json() as { vote_count: number };
      expect(vote.vote_count).toBe(1);
    });

    it('handles CORS preflight', async () => {
      const res = await worker.fetch(
        `/api/v1/${workspace}/${board}/feedback`,
        {
          method: 'OPTIONS',
          headers: {
            'Origin': 'https://example.com',
            'Access-Control-Request-Method': 'POST',
          },
        }
      );

      expect(res.status).toBe(204);
      expect(res.headers.get('Access-Control-Allow-Origin')).toBe('https://example.com');
      expect(res.headers.get('Access-Control-Allow-Methods')).toContain('POST');
    });

    it('returns 400 for invalid feedback', async () => {
      const res = await worker.fetch(
        `/api/v1/${workspace}/${board}/feedback`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            // Missing required title
            description: 'No title',
            externalUserId: 'test',
          }),
        }
      );

      expect(res.status).toBe(400);
    });
  });

  describe('Admin API', () => {
    it('requires authentication for admin endpoints', async () => {
      const res = await worker.fetch('/api/admin/workspaces');
      expect(res.status).toBe(401);
    });

    it('accepts valid API key', async () => {
      const res = await worker.fetch('/api/admin/workspaces', {
        headers: { 'X-API-Key': 'test-admin-key' },
      });
      expect(res.status).toBe(200);
    });
  });
});
```

#### Subtask 8.3.2.2: Database Integration Tests (1h)

```typescript
// tests/integration/database.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createTestEnv } from '../helpers/env';

describe('Database Constraints', () => {
  let env: Awaited<ReturnType<typeof createTestEnv>>;

  beforeEach(async () => {
    env = await createTestEnv();
  });

  describe('Foreign Key Constraints', () => {
    it('prevents orphan feedback items', async () => {
      await expect(
        env.db.prepare(
          'INSERT INTO feedback_items (board_id, user_id, title) VALUES (?, ?, ?)'
        ).bind(9999, 9999, 'Orphan').run()
      ).rejects.toThrow(/FOREIGN KEY/);
    });

    it('cascades workspace deletion', async () => {
      const ws = await env.db.prepare(
        'INSERT INTO workspaces (slug, name) VALUES (?, ?) RETURNING id'
      ).bind('cascade-test', 'Test').first();

      await env.db.prepare(
        'INSERT INTO boards (workspace_id, slug, name) VALUES (?, ?, ?)'
      ).bind(ws!.id, 'board', 'Board').run();

      await env.db.prepare('DELETE FROM workspaces WHERE id = ?').bind(ws!.id).run();

      const boards = await env.db.prepare(
        'SELECT * FROM boards WHERE workspace_id = ?'
      ).bind(ws!.id).all();

      expect(boards.results).toHaveLength(0);
    });
  });

  describe('Unique Constraints', () => {
    it('prevents duplicate workspace slugs', async () => {
      await env.db.prepare(
        'INSERT INTO workspaces (slug, name) VALUES (?, ?)'
      ).bind('unique-test', 'Test 1').run();

      await expect(
        env.db.prepare(
          'INSERT INTO workspaces (slug, name) VALUES (?, ?)'
        ).bind('unique-test', 'Test 2').run()
      ).rejects.toThrow(/UNIQUE/);
    });

    it('prevents duplicate votes', async () => {
      // Setup
      const ws = await env.db.prepare(
        'INSERT INTO workspaces (slug, name) VALUES (?, ?) RETURNING id'
      ).bind('vote-test', 'Test').first();

      const board = await env.db.prepare(
        'INSERT INTO boards (workspace_id, slug, name) VALUES (?, ?, ?) RETURNING id'
      ).bind(ws!.id, 'main', 'Main').first();

      const user = await env.db.prepare(
        'INSERT INTO end_users (workspace_id, external_user_id) VALUES (?, ?) RETURNING id'
      ).bind(ws!.id, 'voter').first();

      const feedback = await env.db.prepare(
        'INSERT INTO feedback_items (board_id, user_id, title) VALUES (?, ?, ?) RETURNING id'
      ).bind(board!.id, user!.id, 'Item').first();

      // First vote succeeds
      await env.db.prepare(
        'INSERT INTO feedback_votes (feedback_id, user_id, weight) VALUES (?, ?, ?)'
      ).bind(feedback!.id, user!.id, 1).run();

      // Duplicate vote fails
      await expect(
        env.db.prepare(
          'INSERT INTO feedback_votes (feedback_id, user_id, weight) VALUES (?, ?, ?)'
        ).bind(feedback!.id, user!.id, 1).run()
      ).rejects.toThrow(/UNIQUE/);
    });
  });
});
```

**Acceptance Criteria**:
- [ ] All API endpoints have integration tests
- [ ] Database constraints validated
- [ ] CORS handling tested
- [ ] Error responses validated

---

### Task 8.3.3: E2E Testing with Playwright (2h)

Test critical user flows in real browser.

#### Subtask 8.3.3.1: Playwright Setup (0.5h)

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: process.env.E2E_BASE_URL || 'http://localhost:8787',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } },
    { name: 'mobile', use: { ...devices['iPhone 13'] } },
  ],
  webServer: {
    command: 'wrangler dev --local',
    url: 'http://localhost:8787/health',
    reuseExistingServer: !process.env.CI,
  },
});

// tests/e2e/fixtures.ts
import { test as base } from '@playwright/test';

export const test = base.extend({
  // Custom fixture for embedding widget
  widgetPage: async ({ page }, use) => {
    await page.setContent(`
      <!DOCTYPE html>
      <html>
      <head><title>Widget Test</title></head>
      <body>
        <h1>Test Page</h1>
        <script
          src="http://localhost:8787/widget.js"
          data-workspace="e2e-test"
          data-board="main"
        ></script>
      </body>
      </html>
    `);
    await use(page);
  },
});

export { expect } from '@playwright/test';
```

#### Subtask 8.3.3.2: Widget E2E Tests (1.5h)

```typescript
// tests/e2e/widget.spec.ts
import { test, expect } from './fixtures';

test.describe('Feedback Widget', () => {
  test('loads and displays widget button', async ({ widgetPage }) => {
    // Wait for widget to load
    const widget = widgetPage.locator('.cv-widget-button');
    await expect(widget).toBeVisible({ timeout: 5000 });

    // Widget should have "Feedback" text
    await expect(widget).toContainText('Feedback');
  });

  test('opens feedback form on click', async ({ widgetPage }) => {
    const button = widgetPage.locator('.cv-widget-button');
    await button.click();

    const form = widgetPage.locator('.cv-widget-form');
    await expect(form).toBeVisible();

    // Form should have title and description inputs
    await expect(widgetPage.locator('input[name="title"]')).toBeVisible();
    await expect(widgetPage.locator('textarea[name="description"]')).toBeVisible();
  });

  test('submits feedback successfully', async ({ widgetPage }) => {
    // Open form
    await widgetPage.locator('.cv-widget-button').click();

    // Fill form
    await widgetPage.fill('input[name="title"]', 'E2E Test Feedback');
    await widgetPage.fill('textarea[name="description"]', 'Submitted from Playwright');

    // Submit
    await widgetPage.click('button[type="submit"]');

    // Should show success message
    await expect(widgetPage.locator('.cv-success-message')).toBeVisible({ timeout: 5000 });
    await expect(widgetPage.locator('.cv-success-message')).toContainText('Thank you');
  });

  test('displays existing feedback', async ({ widgetPage }) => {
    // Open widget panel
    await widgetPage.locator('.cv-widget-button').click();

    // Click "View all feedback" or similar
    await widgetPage.click('text=View feedback');

    // Should show feedback list
    const list = widgetPage.locator('.cv-feedback-list');
    await expect(list).toBeVisible();
  });

  test('allows voting on feedback', async ({ widgetPage }) => {
    // Navigate to feedback list
    await widgetPage.locator('.cv-widget-button').click();
    await widgetPage.click('text=View feedback');

    // Wait for list to load
    await widgetPage.waitForSelector('.cv-feedback-item');

    // Get first item vote button
    const voteButton = widgetPage.locator('.cv-feedback-item').first().locator('.cv-vote-button');
    const initialCount = await voteButton.textContent();

    // Click vote
    await voteButton.click();

    // Vote count should increase
    await expect(voteButton).not.toHaveText(initialCount!);
  });

  test('persists user across sessions', async ({ widgetPage, context }) => {
    // Submit feedback
    await widgetPage.locator('.cv-widget-button').click();
    await widgetPage.fill('input[name="title"]', 'Session test');
    await widgetPage.fill('textarea[name="description"]', 'Testing persistence');
    await widgetPage.click('button[type="submit"]');
    await widgetPage.waitForSelector('.cv-success-message');

    // Check localStorage has user ID
    const userId = await widgetPage.evaluate(() => localStorage.getItem('cv_uid'));
    expect(userId).toBeTruthy();
    expect(userId).toMatch(/^anon_/);

    // Reload page
    await widgetPage.reload();
    await widgetPage.waitForSelector('.cv-widget-button');

    // User ID should persist
    const persistedId = await widgetPage.evaluate(() => localStorage.getItem('cv_uid'));
    expect(persistedId).toBe(userId);
  });

  test('handles offline gracefully', async ({ widgetPage }) => {
    // Go offline
    await widgetPage.context().setOffline(true);

    // Try to submit
    await widgetPage.locator('.cv-widget-button').click();
    await widgetPage.fill('input[name="title"]', 'Offline test');
    await widgetPage.click('button[type="submit"]');

    // Should show error message
    await expect(widgetPage.locator('.cv-error-message')).toBeVisible();

    // Go back online
    await widgetPage.context().setOffline(false);
  });
});

// tests/e2e/admin.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Admin Dashboard', () => {
  test.beforeEach(async ({ page }) => {
    // Login flow would go here
    await page.goto('/admin');
  });

  test('displays workspace list', async ({ page }) => {
    await expect(page.locator('h1')).toContainText('Workspaces');
    await expect(page.locator('.workspace-card')).toHaveCount.greaterThan(0);
  });

  test('can moderate feedback', async ({ page }) => {
    await page.click('text=Moderation Queue');

    // Get first pending item
    const item = page.locator('.pending-item').first();
    await expect(item).toBeVisible();

    // Approve it
    await item.locator('button:has-text("Approve")').click();

    // Should be removed from queue
    await expect(item).not.toBeVisible();
  });
});
```

**Acceptance Criteria**:
- [ ] Widget loads and functions correctly
- [ ] Feedback submission flow works
- [ ] Voting works
- [ ] Tests pass on Chrome, Firefox, Safari, Mobile

---

### Task 8.3.4: API Documentation (2h)

Complete OpenAPI specification and documentation.

#### Subtask 8.3.4.1: OpenAPI Specification (1h)

```yaml
# openapi.yaml
openapi: 3.1.0
info:
  title: Collective Vision API
  description: |
    AI-native feedback collection and analysis platform.

    ## Authentication

    Public endpoints (widget) require no authentication.
    Admin endpoints require an API key via `X-API-Key` header.

    ## Rate Limits

    - Widget endpoints: 100 requests/minute per IP
    - Admin endpoints: 1000 requests/minute per API key
  version: 1.0.0
  contact:
    email: support@collectivevision.io

servers:
  - url: https://feedback.example.com/api/v1
    description: Production
  - url: http://localhost:8787/api/v1
    description: Local development

tags:
  - name: Feedback
    description: Feedback submission and retrieval
  - name: Voting
    description: Vote on feedback items
  - name: Comments
    description: Comment on feedback items
  - name: Admin
    description: Administrative operations (requires auth)

paths:
  /{workspace}/{board}/feedback:
    get:
      tags: [Feedback]
      summary: List feedback items
      description: Returns paginated list of approved, visible feedback items
      parameters:
        - name: workspace
          in: path
          required: true
          schema:
            type: string
          description: Workspace slug
        - name: board
          in: path
          required: true
          schema:
            type: string
          description: Board slug
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
            maximum: 100
        - name: sort
          in: query
          schema:
            type: string
            enum: [vote_count, created_at, updated_at]
            default: vote_count
        - name: status
          in: query
          schema:
            type: string
            enum: [new, under_review, planned, in_progress, completed, declined]
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/FeedbackItem'
              example:
                - id: 1
                  title: "Dark mode support"
                  description: "Would love a dark theme option"
                  status: planned
                  vote_count: 42
                  comment_count: 5
                  created_at: "2024-01-15T10:30:00Z"

    post:
      tags: [Feedback]
      summary: Create feedback item
      description: |
        Submits new feedback. Auto-provisions workspace/board if they don't exist.

        Widget submissions are auto-approved. API submissions go to moderation queue.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateFeedbackRequest'
      responses:
        '201':
          description: Feedback created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FeedbackItem'
        '400':
          $ref: '#/components/responses/BadRequest'

  /{workspace}/{board}/feedback/{id}/votes:
    post:
      tags: [Voting]
      summary: Vote on feedback
      description: Adds or updates vote for the specified user
      parameters:
        - name: workspace
          in: path
          required: true
          schema:
            type: string
        - name: board
          in: path
          required: true
          schema:
            type: string
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [externalUserId]
              properties:
                externalUserId:
                  type: string
      responses:
        '200':
          description: Vote recorded
          content:
            application/json:
              schema:
                type: object
                properties:
                  vote_count:
                    type: integer

components:
  schemas:
    FeedbackItem:
      type: object
      properties:
        id:
          type: integer
        title:
          type: string
        description:
          type: string
        status:
          type: string
          enum: [new, under_review, planned, in_progress, completed, declined]
        category:
          type: string
          nullable: true
        vote_count:
          type: integer
        comment_count:
          type: integer
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    CreateFeedbackRequest:
      type: object
      required: [title, externalUserId]
      properties:
        title:
          type: string
          minLength: 1
          maxLength: 255
        description:
          type: string
          maxLength: 5000
        externalUserId:
          type: string
          description: Unique identifier for the user
        category:
          type: string
        email:
          type: string
          format: email
        name:
          type: string

  responses:
    BadRequest:
      description: Invalid request
      content:
        application/json:
          schema:
            type: object
            properties:
              error:
                type: string
              details:
                type: object

  securitySchemes:
    ApiKey:
      type: apiKey
      in: header
      name: X-API-Key
```

#### Subtask 8.3.4.2: Documentation Site (1h)

```typescript
// Generate docs with Redoc or Scalar
// docs/generate.ts
import { writeFileSync } from 'fs';
import { load } from 'js-yaml';
import { readFileSync } from 'fs';

const spec = load(readFileSync('./openapi.yaml', 'utf8'));

// Generate HTML documentation
const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Collective Vision API</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Inter:400,600,700" rel="stylesheet">
  <script src="https://unpkg.com/@scalar/api-reference"></script>
</head>
<body>
  <script id="api-reference" data-url="/openapi.yaml"></script>
  <script>
    var configuration = {
      theme: 'default',
      layout: 'modern',
      searchHotKey: 'k',
      showSidebar: true,
    };
    document.getElementById('api-reference').dataset.configuration = JSON.stringify(configuration);
  </script>
</body>
</html>
`;

writeFileSync('./docs/api/index.html', html);

// Also generate markdown for quick reference
const markdown = generateMarkdown(spec);
writeFileSync('./docs/api/README.md', markdown);

function generateMarkdown(spec: any): string {
  let md = `# ${spec.info.title}\n\n`;
  md += `${spec.info.description}\n\n`;

  md += `## Endpoints\n\n`;

  for (const [path, methods] of Object.entries(spec.paths as Record<string, any>)) {
    for (const [method, details] of Object.entries(methods as Record<string, any>)) {
      md += `### ${method.toUpperCase()} ${path}\n\n`;
      md += `${details.summary}\n\n`;
      md += `${details.description || ''}\n\n`;
    }
  }

  return md;
}
```

**Acceptance Criteria**:
- [ ] OpenAPI 3.1 spec complete
- [ ] All endpoints documented
- [ ] Request/response examples provided
- [ ] Interactive docs site deployed

---

## Definition of Done

- [ ] 80%+ unit test coverage achieved
- [ ] All API endpoints integration tested
- [ ] E2E tests passing on major browsers
- [ ] OpenAPI specification complete
- [ ] API documentation site deployed
- [ ] CI/CD runs all tests automatically

---

## Technical Notes

### Test Data Management
- Use isolated test workspaces per test run
- Clean up test data after E2E tests
- Use meaningful test data for documentation screenshots

### CI Integration
```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1
      - run: bun install
      - run: bun test:unit
      - run: bun test:integration
      - run: bunx playwright install
      - run: bun test:e2e
```

---

## Related Files

- `vitest.config.ts` - Unit test configuration
- `playwright.config.ts` - E2E test configuration
- `openapi.yaml` - API specification
- `tests/` - All test files
- `docs/api/` - Generated documentation
