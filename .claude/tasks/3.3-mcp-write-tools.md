# Epic 3.3: MCP Write Tools

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Build write MCP tools for agent mutations
**Tools**: MCP SDK, D1 mutations, Queue triggers

## Wave Context
**Wave**: 3 - MCP Server + Agent Integration
**Priority**: P1 (enables agent ecosystem)
**Dependencies**: Epic 3.1 (MCP core), Epic 2.6 (AI pipeline)
**Estimated Duration**: 4 hours

## Quality Requirements
- Write operations atomic and safe
- Proper moderation for agent-submitted content
- Audit trail for all mutations
- Idempotent where possible (vote dedup)

---

## Tasks

### 3.3.1 submit_feedback Tool (1.5h)
**Objective**: Create new feedback via MCP with proper attribution

**Steps**:
1. Define input schema:
   ```typescript
   // src/mcp/tools/submit-feedback.ts

   import { z } from 'zod';
   import { registerTool } from './registry';

   const SubmitFeedbackInput = z.object({
     board_slug: z.string(),
     title: z.string().min(5).max(200),
     description: z.string().max(5000).optional(),
     source_context: z.object({
       agent_id: z.string().optional(),
       original_source: z.enum(['slack', 'reddit', 'support', 'discord', 'twitter', 'email', 'other']).optional(),
       original_url: z.string().url().optional(),
       user_identifier: z.string().optional(),
       additional_metadata: z.record(z.unknown()).optional()
     }).optional()
   });

   type SubmitFeedbackInputType = z.infer<typeof SubmitFeedbackInput>;
   ```

2. Implement handler with moderation:
   ```typescript
   interface SubmitFeedbackOutput {
     feedback_id: string;
     status: 'pending_moderation' | 'approved';
     message: string;
   }

   async function submitFeedbackHandler(
     input: SubmitFeedbackInputType,
     context: MCPContext
   ): Promise<SubmitFeedbackOutput> {
     // Get or create board
     const board = await context.env.DB.prepare(`
       SELECT b.id, b.workspace_id, b.auto_approve_mcp
       FROM boards b
       JOIN workspaces w ON b.workspace_id = w.id
       WHERE w.id = ? AND b.slug = ?
     `).bind(context.workspaceId, input.board_slug).first();

     if (!board) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, `Board not found: ${input.board_slug}`);
     }

     // Check workspace can receive MCP submissions
     const workspace = await context.env.DB.prepare(`
       SELECT allow_mcp_submissions, mcp_submission_moderation
       FROM workspaces WHERE id = ?
     `).bind(context.workspaceId).first();

     if (!workspace?.allow_mcp_submissions) {
       throw new MCPError(MCPErrorCodes.INSUFFICIENT_PERMISSIONS, 'MCP submissions not enabled for this workspace');
     }

     // Determine moderation state
     const autoApprove = board.auto_approve_mcp || workspace.mcp_submission_moderation === 'auto_approve';
     const moderationState = autoApprove ? 'approved' : 'pending';
     const isHidden = autoApprove ? 0 : 1;

     // Create feedback
     const feedbackId = generateId('fb');
     const now = new Date().toISOString();

     await context.env.DB.prepare(`
       INSERT INTO feedback_items (
         id, board_id, title, description, status, source,
         moderation_state, is_hidden, source_metadata,
         created_at, updated_at
       ) VALUES (?, ?, ?, ?, 'open', 'mcp', ?, ?, ?, ?, ?)
     `).bind(
       feedbackId,
       board.id,
       input.title,
       input.description || null,
       moderationState,
       isHidden,
       input.source_context ? JSON.stringify(input.source_context) : null,
       now,
       now
     ).run();

     // Log the submission
     await context.env.DB.prepare(`
       INSERT INTO mcp_submission_log (
         id, api_key_id, feedback_id, source_context, created_at
       ) VALUES (?, ?, ?, ?, ?)
     `).bind(
       generateId('mcpsub'),
       context.apiKeyId,
       feedbackId,
       JSON.stringify(input.source_context || {}),
       now
     ).run();

     // Queue for AI processing
     await enqueueAIJob(context.env.AI_QUEUE, feedbackId, context.workspaceId, [
       'embed', 'classify', 'sentiment', 'urgency'
     ]);

     // Track usage
     await incrementUsage(context.env.DB, context.workspaceId, 'mcp_submissions');

     return {
       feedback_id: feedbackId,
       status: autoApprove ? 'approved' : 'pending_moderation',
       message: autoApprove
         ? 'Feedback submitted and published'
         : 'Feedback submitted and pending moderation review'
     };
   }

   export function registerSubmitFeedbackTool(): void {
     registerTool({
       name: 'submit_feedback',
       description: 'Submit new feedback on behalf of a user. Feedback goes to moderation by default. Include source_context for attribution.',
       inputSchema: SubmitFeedbackInput,
       requiredScope: 'write',
       handler: submitFeedbackHandler
     });
   }
   ```

3. Create submission log table:
   ```sql
   CREATE TABLE mcp_submission_log (
     id TEXT PRIMARY KEY,
     api_key_id TEXT NOT NULL,
     feedback_id TEXT NOT NULL,
     source_context TEXT,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (api_key_id) REFERENCES mcp_api_keys(id),
     FOREIGN KEY (feedback_id) REFERENCES feedback_items(id)
   );

   CREATE INDEX idx_mcp_submissions_key ON mcp_submission_log(api_key_id, created_at);
   ```

**Acceptance Criteria**:
- [ ] Feedback created with source='mcp'
- [ ] Pending moderation by default (unless auto-approve)
- [ ] AI processing queued
- [ ] Source context preserved

---

### 3.3.2 vote_feedback Tool (0.5h)
**Objective**: Register vote with deduplication

**Steps**:
1. Implement vote tool:
   ```typescript
   // src/mcp/tools/vote-feedback.ts

   const VoteFeedbackInput = z.object({
     feedback_id: z.string(),
     user_identifier: z.string().optional(),
     weight: z.number().min(1).max(1).default(1)  // Future: weighted votes
   });

   interface VoteFeedbackOutput {
     success: boolean;
     new_vote: boolean;
     current_vote_count: number;
   }

   async function voteFeedbackHandler(
     input: z.infer<typeof VoteFeedbackInput>,
     context: MCPContext
   ): Promise<VoteFeedbackOutput> {
     // Verify feedback exists and is in workspace
     const feedback = await context.env.DB.prepare(`
       SELECT fi.id, fi.vote_count, b.workspace_id
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE fi.id = ? AND b.workspace_id = ?
         AND fi.is_hidden = 0 AND fi.moderation_state = 'approved'
     `).bind(input.feedback_id, context.workspaceId).first();

     if (!feedback) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, 'Feedback not found or not visible');
     }

     // Create unique voter ID for deduplication
     // Combine API key + user_identifier for uniqueness
     const voterId = input.user_identifier
       ? `mcp:${context.apiKeyId}:${input.user_identifier}`
       : `mcp:${context.apiKeyId}`;

     // Check for existing vote
     const existingVote = await context.env.DB.prepare(`
       SELECT id FROM feedback_votes
       WHERE feedback_id = ? AND user_id = ?
     `).bind(input.feedback_id, voterId).first();

     if (existingVote) {
       // Already voted - return current count
       return {
         success: true,
         new_vote: false,
         current_vote_count: feedback.vote_count as number
       };
     }

     // Create vote
     const voteId = generateId('vote');

     await context.env.DB.batch([
       context.env.DB.prepare(`
         INSERT INTO feedback_votes (id, feedback_id, user_id, weight, source)
         VALUES (?, ?, ?, ?, 'mcp')
       `).bind(voteId, input.feedback_id, voterId, input.weight),

       context.env.DB.prepare(`
         UPDATE feedback_items
         SET vote_count = vote_count + ?, updated_at = datetime('now')
         WHERE id = ?
       `).bind(input.weight, input.feedback_id)
     ]);

     // Recalculate priority score
     await updatePriorityScore(input.feedback_id, context.env);

     return {
       success: true,
       new_vote: true,
       current_vote_count: (feedback.vote_count as number) + input.weight
     };
   }

   export function registerVoteFeedbackTool(): void {
     registerTool({
       name: 'vote_feedback',
       description: 'Add a vote to feedback. Votes are deduplicated by API key + user_identifier.',
       inputSchema: VoteFeedbackInput,
       requiredScope: 'write',
       handler: voteFeedbackHandler
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Votes tracked with source='mcp'
- [ ] Deduplication by API key + user identifier
- [ ] Vote count updated
- [ ] Priority score recalculated

---

### 3.3.3 add_comment Tool (1h)
**Objective**: Add comment with agent attribution

**Steps**:
1. Implement comment tool:
   ```typescript
   // src/mcp/tools/add-comment.ts

   const AddCommentInput = z.object({
     feedback_id: z.string(),
     body: z.string().min(1).max(5000),
     is_internal: z.boolean().default(false),
     author_context: z.object({
       agent_id: z.string().optional(),
       display_name: z.string().optional()
     }).optional()
   });

   interface AddCommentOutput {
     comment_id: string;
     feedback_id: string;
     visibility: 'public' | 'internal';
   }

   async function addCommentHandler(
     input: z.infer<typeof AddCommentInput>,
     context: MCPContext
   ): Promise<AddCommentOutput> {
     // Verify feedback exists and is in workspace
     const feedback = await context.env.DB.prepare(`
       SELECT fi.id, fi.user_id, b.workspace_id
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE fi.id = ? AND b.workspace_id = ?
     `).bind(input.feedback_id, context.workspaceId).first();

     if (!feedback) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, 'Feedback not found');
     }

     // Internal comments require admin scope
     if (input.is_internal && !requireScope(context, 'admin')) {
       throw new MCPError(MCPErrorCodes.INSUFFICIENT_PERMISSIONS, 'Internal comments require admin scope');
     }

     // Create comment
     const commentId = generateId('cmt');
     const now = new Date().toISOString();

     // Create agent user for attribution
     const agentUserId = `mcp:${context.apiKeyId}`;
     const displayName = input.author_context?.display_name || 'AI Agent';

     await context.env.DB.prepare(`
       INSERT OR IGNORE INTO end_users (id, workspace_id, external_user_id, name, is_agent)
       VALUES (?, ?, ?, ?, 1)
     `).bind(agentUserId, context.workspaceId, agentUserId, displayName).run();

     await context.env.DB.prepare(`
       INSERT INTO feedback_comments (
         id, feedback_id, user_id, body, is_internal,
         source, source_metadata, created_at, updated_at
       ) VALUES (?, ?, ?, ?, ?, 'mcp', ?, ?, ?)
     `).bind(
       commentId,
       input.feedback_id,
       agentUserId,
       input.body,
       input.is_internal ? 1 : 0,
       input.author_context ? JSON.stringify(input.author_context) : null,
       now,
       now
     ).run();

     // Update feedback timestamp
     await context.env.DB.prepare(`
       UPDATE feedback_items SET updated_at = ? WHERE id = ?
     `).bind(now, input.feedback_id).run();

     // Queue notification (if public comment)
     if (!input.is_internal && feedback.user_id) {
       // TODO: Trigger notification to original submitter
     }

     return {
       comment_id: commentId,
       feedback_id: input.feedback_id,
       visibility: input.is_internal ? 'internal' : 'public'
     };
   }

   export function registerAddCommentTool(): void {
     registerTool({
       name: 'add_comment',
       description: 'Add a comment to feedback. Use is_internal=true for team-only comments (requires admin scope).',
       inputSchema: AddCommentInput,
       requiredScope: 'write',
       handler: addCommentHandler
     });
   }
   ```

2. Add is_agent column to end_users:
   ```sql
   ALTER TABLE end_users ADD COLUMN is_agent INTEGER DEFAULT 0;
   ```

**Acceptance Criteria**:
- [ ] Comments added with agent attribution
- [ ] Internal comments hidden from public
- [ ] Display name customizable
- [ ] Notifications triggered for public comments

---

### 3.3.4 update_status Tool (1h)
**Objective**: Update feedback status with audit trail

**Steps**:
1. Implement status update tool:
   ```typescript
   // src/mcp/tools/update-status.ts

   const UpdateStatusInput = z.object({
     feedback_id: z.string(),
     status: z.enum(['open', 'under_review', 'planned', 'in_progress', 'done', 'declined']),
     comment: z.string().max(1000).optional()
   });

   interface UpdateStatusOutput {
     success: boolean;
     previous_status: string;
     new_status: string;
     comment_id?: string;
   }

   async function updateStatusHandler(
     input: z.infer<typeof UpdateStatusInput>,
     context: MCPContext
   ): Promise<UpdateStatusOutput> {
     // Require admin scope for status changes
     if (!requireScope(context, 'admin')) {
       throw new MCPError(MCPErrorCodes.INSUFFICIENT_PERMISSIONS, 'Status updates require admin scope');
     }

     // Verify feedback exists and get current status
     const feedback = await context.env.DB.prepare(`
       SELECT fi.id, fi.status, fi.user_id, b.workspace_id
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       WHERE fi.id = ? AND b.workspace_id = ?
     `).bind(input.feedback_id, context.workspaceId).first();

     if (!feedback) {
       throw new MCPError(MCPErrorCodes.RESOURCE_NOT_FOUND, 'Feedback not found');
     }

     const previousStatus = feedback.status as string;

     if (previousStatus === input.status) {
       return {
         success: true,
         previous_status: previousStatus,
         new_status: input.status
       };
     }

     const now = new Date().toISOString();

     // Update status
     await context.env.DB.prepare(`
       UPDATE feedback_items
       SET status = ?, updated_at = ?
       WHERE id = ?
     `).bind(input.status, now, input.feedback_id).run();

     // Log status change
     await context.env.DB.prepare(`
       INSERT INTO feedback_status_history (
         id, feedback_id, previous_status, new_status,
         changed_by, changed_by_type, changed_at
       ) VALUES (?, ?, ?, ?, ?, 'mcp', ?)
     `).bind(
       generateId('statushist'),
       input.feedback_id,
       previousStatus,
       input.status,
       context.apiKeyId,
       now
     ).run();

     // Add comment if provided
     let commentId: string | undefined;
     if (input.comment) {
       commentId = generateId('cmt');
       const agentUserId = `mcp:${context.apiKeyId}`;

       await context.env.DB.prepare(`
         INSERT INTO feedback_comments (
           id, feedback_id, user_id, body, is_internal,
           is_status_change, source, created_at, updated_at
         ) VALUES (?, ?, ?, ?, 1, 1, 'mcp', ?, ?)
       `).bind(
         commentId,
         input.feedback_id,
         agentUserId,
         `Status changed from ${previousStatus} to ${input.status}: ${input.comment}`,
         now,
         now
       ).run();
     }

     // Queue notification
     // TODO: Notify subscribers of status change

     return {
       success: true,
       previous_status: previousStatus,
       new_status: input.status,
       comment_id: commentId
     };
   }

   export function registerUpdateStatusTool(): void {
     registerTool({
       name: 'update_status',
       description: 'Update feedback status. Requires admin scope. Optionally include a comment explaining the change.',
       inputSchema: UpdateStatusInput,
       requiredScope: 'admin',
       handler: updateStatusHandler
     });
   }
   ```

2. Create status history table:
   ```sql
   CREATE TABLE feedback_status_history (
     id TEXT PRIMARY KEY,
     feedback_id TEXT NOT NULL,
     previous_status TEXT NOT NULL,
     new_status TEXT NOT NULL,
     changed_by TEXT NOT NULL,
     changed_by_type TEXT NOT NULL,  -- user, mcp, system
     changed_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (feedback_id) REFERENCES feedback_items(id)
   );

   CREATE INDEX idx_status_history_feedback ON feedback_status_history(feedback_id, changed_at);
   ```

3. Add is_status_change column to comments:
   ```sql
   ALTER TABLE feedback_comments ADD COLUMN is_status_change INTEGER DEFAULT 0;
   ```

**Acceptance Criteria**:
- [ ] Status updated with audit trail
- [ ] History tracked in separate table
- [ ] Optional comment auto-added
- [ ] Subscribers notified

---

## Definition of Done
- [ ] All 4 write tools registered and functional
- [ ] Proper moderation for MCP submissions
- [ ] Audit trail for all mutations
- [ ] Vote deduplication working
- [ ] Scope checking enforced

## Technical Notes
- Write tools require 'write' or 'admin' scope
- All mutations logged for audit
- Agent users created with is_agent=1 flag
- Status changes tracked separately for analytics

## Related Files
- `src/mcp/tools/submit-feedback.ts`
- `src/mcp/tools/vote-feedback.ts`
- `src/mcp/tools/add-comment.ts`
- `src/mcp/tools/update-status.ts`
