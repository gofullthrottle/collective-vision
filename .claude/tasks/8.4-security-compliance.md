# Epic 8.4: Security & Compliance

**Wave**: 8 - Enterprise Polish
**Epic**: Security & Compliance
**Estimated Hours**: 10h
**Priority**: P0 (Launch Critical)
**Dependencies**: Core API (0.x), Auth (4.x), Admin (4.x)

---

## Overview

Conduct security audit, address OWASP Top 10 vulnerabilities, implement GDPR compliance features, and prepare SOC 2 documentation for enterprise readiness.

---

## Methodology Guidance

### SPECTRA Phase: Assure
This epic focuses on security validation and compliance:
- Audit existing implementations
- Fix identified vulnerabilities
- Document compliance measures

### Quality Bar
- Zero critical/high severity vulnerabilities
- GDPR data rights fully implemented
- Security headers A+ rating
- SOC 2 controls documented

---

## Wave Context

Wave 8 prepares the platform for enterprise deployment. Security and compliance ensures:
- Protection against common attacks
- User data privacy rights
- Audit trail for compliance
- Documentation for enterprise procurement

---

## Tasks

### Task 8.4.1: Security Audit (3h)

Comprehensive security review of the platform.

#### Subtask 8.4.1.1: OWASP Top 10 Assessment (2h)

```typescript
// security/audit-checklist.ts

interface SecurityCheck {
  category: string;
  item: string;
  status: 'pass' | 'fail' | 'partial' | 'na';
  notes: string;
  remediation?: string;
}

const OWASP_TOP_10_AUDIT: SecurityCheck[] = [
  // A01:2021 - Broken Access Control
  {
    category: 'A01 - Broken Access Control',
    item: 'Workspace isolation enforced',
    status: 'pass',
    notes: 'All queries include workspace_id filter',
  },
  {
    category: 'A01 - Broken Access Control',
    item: 'Admin endpoints require authentication',
    status: 'pass',
    notes: 'API key required for /api/admin/* routes',
  },
  {
    category: 'A01 - Broken Access Control',
    item: 'CORS configured correctly',
    status: 'partial',
    notes: 'Currently allows all origins for widget',
    remediation: 'Implement domain allowlist for API endpoints',
  },

  // A02:2021 - Cryptographic Failures
  {
    category: 'A02 - Cryptographic Failures',
    item: 'HTTPS enforced',
    status: 'pass',
    notes: 'Cloudflare handles TLS termination',
  },
  {
    category: 'A02 - Cryptographic Failures',
    item: 'Sensitive data encrypted at rest',
    status: 'pass',
    notes: 'D1 database encrypted by Cloudflare',
  },
  {
    category: 'A02 - Cryptographic Failures',
    item: 'API keys hashed in storage',
    status: 'partial',
    notes: 'Keys stored with SHA-256, need bcrypt',
    remediation: 'Migrate to bcrypt with salt',
  },

  // A03:2021 - Injection
  {
    category: 'A03 - Injection',
    item: 'SQL injection prevention',
    status: 'pass',
    notes: 'All queries use prepared statements',
  },
  {
    category: 'A03 - Injection',
    item: 'XSS prevention',
    status: 'partial',
    notes: 'Input sanitized, but CSP not configured',
    remediation: 'Add Content-Security-Policy header',
  },

  // A04:2021 - Insecure Design
  {
    category: 'A04 - Insecure Design',
    item: 'Rate limiting implemented',
    status: 'fail',
    notes: 'No rate limiting on API endpoints',
    remediation: 'Implement rate limiting with KV counter',
  },
  {
    category: 'A04 - Insecure Design',
    item: 'Moderation queue for untrusted input',
    status: 'pass',
    notes: 'API submissions go to moderation queue',
  },

  // A05:2021 - Security Misconfiguration
  {
    category: 'A05 - Security Misconfiguration',
    item: 'Security headers configured',
    status: 'fail',
    notes: 'Missing security headers',
    remediation: 'Add HSTS, X-Content-Type-Options, etc.',
  },
  {
    category: 'A05 - Security Misconfiguration',
    item: 'Error messages sanitized',
    status: 'pass',
    notes: 'Stack traces not exposed to users',
  },

  // A06:2021 - Vulnerable and Outdated Components
  {
    category: 'A06 - Vulnerable Components',
    item: 'Dependencies audited',
    status: 'partial',
    notes: 'Need automated dependency scanning',
    remediation: 'Add npm audit to CI pipeline',
  },

  // A07:2021 - Identification and Authentication Failures
  {
    category: 'A07 - Auth Failures',
    item: 'Session management secure',
    status: 'pass',
    notes: 'Admin sessions use secure cookies with HttpOnly',
  },
  {
    category: 'A07 - Auth Failures',
    item: 'Password requirements enforced',
    status: 'na',
    notes: 'No password auth - API key and OAuth only',
  },

  // A08:2021 - Software and Data Integrity Failures
  {
    category: 'A08 - Integrity Failures',
    item: 'Webhook signatures verified',
    status: 'pass',
    notes: 'Stripe webhooks verified with signature',
  },

  // A09:2021 - Security Logging and Monitoring Failures
  {
    category: 'A09 - Logging Failures',
    item: 'Security events logged',
    status: 'partial',
    notes: 'Auth failures logged, need centralized SIEM',
    remediation: 'Integrate with logging service',
  },

  // A10:2021 - Server-Side Request Forgery
  {
    category: 'A10 - SSRF',
    item: 'External requests validated',
    status: 'pass',
    notes: 'No user-controlled URL fetching',
  },
];
```

#### Subtask 8.4.1.2: Implement Security Headers (1h)

```typescript
// src/middleware/security.ts

export interface SecurityHeadersConfig {
  csp: string;
  hsts: boolean;
  frameOptions: 'DENY' | 'SAMEORIGIN';
  contentType: boolean;
  xss: boolean;
  referrer: string;
}

const DEFAULT_CONFIG: SecurityHeadersConfig = {
  csp: [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "font-src 'self' https://fonts.gstatic.com",
    "connect-src 'self' https://api.stripe.com",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'",
  ].join('; '),
  hsts: true,
  frameOptions: 'DENY',
  contentType: true,
  xss: true,
  referrer: 'strict-origin-when-cross-origin',
};

export function addSecurityHeaders(
  response: Response,
  config: Partial<SecurityHeadersConfig> = {}
): Response {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  const headers = new Headers(response.headers);

  // Content Security Policy
  headers.set('Content-Security-Policy', cfg.csp);

  // HTTP Strict Transport Security
  if (cfg.hsts) {
    headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }

  // X-Frame-Options
  headers.set('X-Frame-Options', cfg.frameOptions);

  // X-Content-Type-Options
  if (cfg.contentType) {
    headers.set('X-Content-Type-Options', 'nosniff');
  }

  // X-XSS-Protection (legacy but still useful)
  if (cfg.xss) {
    headers.set('X-XSS-Protection', '1; mode=block');
  }

  // Referrer Policy
  headers.set('Referrer-Policy', cfg.referrer);

  // Permissions Policy
  headers.set('Permissions-Policy', [
    'accelerometer=()',
    'camera=()',
    'geolocation=()',
    'microphone=()',
    'payment=()',
    'usb=()',
  ].join(', '));

  // Remove server header
  headers.delete('Server');

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

// Widget-specific CSP (more permissive for embedding)
export function getWidgetSecurityHeaders(): Headers {
  const headers = new Headers();

  // Widget needs to be embeddable
  headers.set('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'",
    "style-src 'self' 'unsafe-inline'",
    "connect-src 'self' *", // Widget can call any origin
  ].join('; '));

  headers.set('X-Content-Type-Options', 'nosniff');

  return headers;
}
```

**Acceptance Criteria**:
- [ ] OWASP Top 10 audit completed
- [ ] All critical issues remediated
- [ ] Security headers implemented
- [ ] securityheaders.com rating A+

---

### Task 8.4.2: Rate Limiting (2h)

Implement rate limiting to prevent abuse.

#### Subtask 8.4.2.1: Rate Limiter Implementation (1.5h)

```typescript
// src/middleware/rate-limit.ts

interface RateLimitConfig {
  windowMs: number;       // Time window in milliseconds
  maxRequests: number;    // Max requests per window
  keyPrefix: string;      // KV key prefix
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetTime: number;
  retryAfter?: number;
}

const RATE_LIMITS: Record<string, RateLimitConfig> = {
  'widget-submit': {
    windowMs: 60 * 1000,  // 1 minute
    maxRequests: 10,      // 10 submissions per minute
    keyPrefix: 'rl:widget:submit',
  },
  'widget-vote': {
    windowMs: 60 * 1000,
    maxRequests: 30,      // 30 votes per minute
    keyPrefix: 'rl:widget:vote',
  },
  'api-read': {
    windowMs: 60 * 1000,
    maxRequests: 100,     // 100 reads per minute
    keyPrefix: 'rl:api:read',
  },
  'api-write': {
    windowMs: 60 * 1000,
    maxRequests: 50,      // 50 writes per minute
    keyPrefix: 'rl:api:write',
  },
  'admin': {
    windowMs: 60 * 1000,
    maxRequests: 1000,    // Higher limit for admins
    keyPrefix: 'rl:admin',
  },
};

export class RateLimiter {
  constructor(private kv: KVNamespace) {}

  async check(
    limitName: string,
    identifier: string
  ): Promise<RateLimitResult> {
    const config = RATE_LIMITS[limitName];
    if (!config) {
      return { allowed: true, remaining: Infinity, resetTime: 0 };
    }

    const key = `${config.keyPrefix}:${identifier}`;
    const now = Date.now();
    const windowStart = now - config.windowMs;

    // Get current count
    const data = await this.kv.get<{ count: number; windowStart: number }>(key, 'json');

    if (!data || data.windowStart < windowStart) {
      // New window
      await this.kv.put(key, JSON.stringify({
        count: 1,
        windowStart: now,
      }), { expirationTtl: Math.ceil(config.windowMs / 1000) + 60 });

      return {
        allowed: true,
        remaining: config.maxRequests - 1,
        resetTime: now + config.windowMs,
      };
    }

    if (data.count >= config.maxRequests) {
      const resetTime = data.windowStart + config.windowMs;
      return {
        allowed: false,
        remaining: 0,
        resetTime,
        retryAfter: Math.ceil((resetTime - now) / 1000),
      };
    }

    // Increment count
    await this.kv.put(key, JSON.stringify({
      count: data.count + 1,
      windowStart: data.windowStart,
    }), { expirationTtl: Math.ceil(config.windowMs / 1000) + 60 });

    return {
      allowed: true,
      remaining: config.maxRequests - data.count - 1,
      resetTime: data.windowStart + config.windowMs,
    };
  }
}

// Middleware wrapper
export function withRateLimit(
  limitName: string,
  getIdentifier: (request: Request) => string = (req) => req.headers.get('CF-Connecting-IP') || 'unknown'
) {
  return (handler: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>) => {
    return async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {
      const limiter = new RateLimiter(env.KV);
      const identifier = getIdentifier(request);
      const result = await limiter.check(limitName, identifier);

      if (!result.allowed) {
        return new Response(JSON.stringify({
          error: 'Too Many Requests',
          retryAfter: result.retryAfter,
        }), {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'Retry-After': result.retryAfter!.toString(),
            'X-RateLimit-Limit': RATE_LIMITS[limitName].maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': result.resetTime.toString(),
          },
        });
      }

      const response = await handler(request, env, ctx);

      // Add rate limit headers to response
      const headers = new Headers(response.headers);
      headers.set('X-RateLimit-Limit', RATE_LIMITS[limitName].maxRequests.toString());
      headers.set('X-RateLimit-Remaining', result.remaining.toString());
      headers.set('X-RateLimit-Reset', result.resetTime.toString());

      return new Response(response.body, {
        status: response.status,
        headers,
      });
    };
  };
}
```

#### Subtask 8.4.2.2: Apply Rate Limits (0.5h)

```typescript
// src/routes/feedback.ts
import { withRateLimit } from '../middleware/rate-limit';

// Apply rate limiting to feedback endpoints
export const createFeedbackHandler = withRateLimit('widget-submit')(
  async (request: Request, env: Env, ctx: ExecutionContext) => {
    // Existing implementation
  }
);

export const voteFeedbackHandler = withRateLimit('widget-vote')(
  async (request: Request, env: Env, ctx: ExecutionContext) => {
    // Existing implementation
  }
);

// src/routes/admin.ts
import { withRateLimit } from '../middleware/rate-limit';

// Admin endpoints with higher limits
export const adminHandler = withRateLimit('admin', (req) => {
  // Use API key as identifier for admin requests
  return req.headers.get('X-API-Key') || 'no-key';
})(
  async (request: Request, env: Env, ctx: ExecutionContext) => {
    // Admin implementation
  }
);
```

**Acceptance Criteria**:
- [ ] Rate limiting implemented for all endpoints
- [ ] Rate limit headers included in responses
- [ ] 429 responses with Retry-After header
- [ ] Different limits for widget vs admin

---

### Task 8.4.3: GDPR Compliance (3h)

Implement data subject rights and privacy features.

#### Subtask 8.4.3.1: Data Export (1h)

```typescript
// src/services/gdpr.ts

interface UserDataExport {
  user: {
    id: number;
    externalUserId: string;
    email?: string;
    name?: string;
    createdAt: string;
  };
  feedback: Array<{
    id: number;
    title: string;
    description: string;
    status: string;
    createdAt: string;
    votes: number;
  }>;
  votes: Array<{
    feedbackId: number;
    feedbackTitle: string;
    votedAt: string;
  }>;
  comments: Array<{
    id: number;
    feedbackId: number;
    content: string;
    createdAt: string;
  }>;
}

export async function exportUserData(
  db: D1Database,
  workspaceId: number,
  userId: number
): Promise<UserDataExport> {
  // Get user info
  const user = await db.prepare(`
    SELECT id, external_user_id, email, name, created_at
    FROM end_users
    WHERE id = ? AND workspace_id = ?
  `).bind(userId, workspaceId).first();

  if (!user) {
    throw new Error('User not found');
  }

  // Get user's feedback
  const feedback = await db.prepare(`
    SELECT
      f.id, f.title, f.description, f.status, f.created_at,
      COALESCE(SUM(v.weight), 0) as vote_count
    FROM feedback_items f
    LEFT JOIN feedback_votes v ON v.feedback_id = f.id
    WHERE f.user_id = ?
    GROUP BY f.id
  `).bind(userId).all();

  // Get user's votes
  const votes = await db.prepare(`
    SELECT v.created_at, f.id as feedback_id, f.title as feedback_title
    FROM feedback_votes v
    JOIN feedback_items f ON f.id = v.feedback_id
    WHERE v.user_id = ?
  `).bind(userId).all();

  // Get user's comments
  const comments = await db.prepare(`
    SELECT id, feedback_id, content, created_at
    FROM feedback_comments
    WHERE user_id = ?
  `).bind(userId).all();

  return {
    user: {
      id: user.id as number,
      externalUserId: user.external_user_id as string,
      email: user.email as string | undefined,
      name: user.name as string | undefined,
      createdAt: user.created_at as string,
    },
    feedback: feedback.results.map((f: any) => ({
      id: f.id,
      title: f.title,
      description: f.description,
      status: f.status,
      createdAt: f.created_at,
      votes: f.vote_count,
    })),
    votes: votes.results.map((v: any) => ({
      feedbackId: v.feedback_id,
      feedbackTitle: v.feedback_title,
      votedAt: v.created_at,
    })),
    comments: comments.results.map((c: any) => ({
      id: c.id,
      feedbackId: c.feedback_id,
      content: c.content,
      createdAt: c.created_at,
    })),
  };
}

// Generate downloadable export file
export async function generateExportFile(
  data: UserDataExport
): Promise<{ content: string; filename: string }> {
  const content = JSON.stringify(data, null, 2);
  const filename = `user-data-export-${data.user.id}-${Date.now()}.json`;
  return { content, filename };
}
```

#### Subtask 8.4.3.2: Data Deletion (1h)

```typescript
// src/services/gdpr.ts

interface DeletionResult {
  feedbackDeleted: number;
  votesDeleted: number;
  commentsDeleted: number;
  userDeleted: boolean;
  anonymizedFeedback: number;
}

export async function deleteUserData(
  db: D1Database,
  workspaceId: number,
  userId: number,
  options: {
    anonymizeFeedback?: boolean;  // Keep feedback but anonymize author
    deleteAll?: boolean;          // Delete everything including feedback
  } = {}
): Promise<DeletionResult> {
  const result: DeletionResult = {
    feedbackDeleted: 0,
    votesDeleted: 0,
    commentsDeleted: 0,
    userDeleted: false,
    anonymizedFeedback: 0,
  };

  // Start transaction
  await db.exec('BEGIN TRANSACTION');

  try {
    // Delete votes
    const votesResult = await db.prepare(`
      DELETE FROM feedback_votes WHERE user_id = ?
    `).bind(userId).run();
    result.votesDeleted = votesResult.meta.changes || 0;

    // Delete comments
    const commentsResult = await db.prepare(`
      DELETE FROM feedback_comments WHERE user_id = ?
    `).bind(userId).run();
    result.commentsDeleted = commentsResult.meta.changes || 0;

    if (options.deleteAll) {
      // Delete all feedback
      const feedbackResult = await db.prepare(`
        DELETE FROM feedback_items WHERE user_id = ?
      `).bind(userId).run();
      result.feedbackDeleted = feedbackResult.meta.changes || 0;
    } else if (options.anonymizeFeedback) {
      // Anonymize feedback instead of deleting
      const anonResult = await db.prepare(`
        UPDATE feedback_items
        SET user_id = NULL, updated_at = datetime('now')
        WHERE user_id = ?
      `).bind(userId).run();
      result.anonymizedFeedback = anonResult.meta.changes || 0;
    }

    // Delete user record
    await db.prepare(`
      DELETE FROM end_users WHERE id = ? AND workspace_id = ?
    `).bind(userId, workspaceId).run();
    result.userDeleted = true;

    await db.exec('COMMIT');
  } catch (error) {
    await db.exec('ROLLBACK');
    throw error;
  }

  return result;
}

// Audit log for GDPR actions
export async function logGdprAction(
  db: D1Database,
  action: 'export' | 'delete' | 'anonymize',
  workspaceId: number,
  userId: number,
  performedBy: number,
  details: Record<string, any>
): Promise<void> {
  await db.prepare(`
    INSERT INTO audit_log (
      workspace_id, action, entity_type, entity_id,
      performed_by, details, created_at
    ) VALUES (?, ?, 'user', ?, ?, ?, datetime('now'))
  `).bind(
    workspaceId,
    `gdpr:${action}`,
    userId,
    performedBy,
    JSON.stringify(details)
  ).run();
}
```

#### Subtask 8.4.3.3: Consent Management (1h)

```typescript
// Schema addition for consent
/*
CREATE TABLE IF NOT EXISTS user_consents (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  consent_type TEXT NOT NULL,  -- 'marketing', 'analytics', 'essential'
  granted INTEGER NOT NULL DEFAULT 0,
  granted_at TEXT,
  revoked_at TEXT,
  ip_address TEXT,
  user_agent TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (user_id) REFERENCES end_users(id) ON DELETE CASCADE,
  UNIQUE(user_id, consent_type)
);
*/

// src/services/consent.ts

type ConsentType = 'marketing' | 'analytics' | 'essential';

interface ConsentRecord {
  type: ConsentType;
  granted: boolean;
  grantedAt?: string;
  revokedAt?: string;
}

export async function getUserConsents(
  db: D1Database,
  userId: number
): Promise<ConsentRecord[]> {
  const result = await db.prepare(`
    SELECT consent_type, granted, granted_at, revoked_at
    FROM user_consents
    WHERE user_id = ?
  `).bind(userId).all();

  return result.results.map((r: any) => ({
    type: r.consent_type,
    granted: r.granted === 1,
    grantedAt: r.granted_at,
    revokedAt: r.revoked_at,
  }));
}

export async function updateConsent(
  db: D1Database,
  userId: number,
  consentType: ConsentType,
  granted: boolean,
  metadata: { ip?: string; userAgent?: string }
): Promise<void> {
  const now = new Date().toISOString();

  await db.prepare(`
    INSERT INTO user_consents (user_id, consent_type, granted, granted_at, ip_address, user_agent)
    VALUES (?, ?, ?, ?, ?, ?)
    ON CONFLICT (user_id, consent_type) DO UPDATE SET
      granted = excluded.granted,
      granted_at = CASE WHEN excluded.granted = 1 THEN ? ELSE granted_at END,
      revoked_at = CASE WHEN excluded.granted = 0 THEN ? ELSE NULL END,
      ip_address = excluded.ip_address,
      user_agent = excluded.user_agent
  `).bind(
    userId,
    consentType,
    granted ? 1 : 0,
    granted ? now : null,
    metadata.ip || null,
    metadata.userAgent || null,
    now,
    now
  ).run();
}

// Check if user has required consent
export async function hasConsent(
  db: D1Database,
  userId: number,
  consentType: ConsentType
): Promise<boolean> {
  const result = await db.prepare(`
    SELECT granted FROM user_consents
    WHERE user_id = ? AND consent_type = ?
  `).bind(userId, consentType).first();

  return result?.granted === 1;
}
```

**Acceptance Criteria**:
- [ ] Data export endpoint functional
- [ ] Data deletion with anonymization option
- [ ] Consent management system
- [ ] Audit logging for GDPR actions

---

### Task 8.4.4: SOC 2 Preparation (2h)

Document security controls for SOC 2 compliance.

#### Subtask 8.4.4.1: Control Documentation (1.5h)

```markdown
<!-- docs/security/soc2-controls.md -->

# SOC 2 Type II Control Documentation

## Trust Service Criteria Coverage

### Security (Common Criteria)

#### CC1 - Control Environment

| Control | Implementation | Evidence |
|---------|----------------|----------|
| CC1.1 - Organization demonstrates commitment to integrity | Code of conduct, security policy | Policy documents |
| CC1.2 - Board exercises oversight | Quarterly security reviews | Meeting minutes |
| CC1.3 - Management establishes structures | Clear ownership of security | Org chart, RACI |
| CC1.4 - Commitment to competence | Security training for developers | Training records |
| CC1.5 - Accountability for controls | Security responsibilities documented | Role descriptions |

#### CC2 - Communication and Information

| Control | Implementation | Evidence |
|---------|----------------|----------|
| CC2.1 - Internal communication | Slack security channel, security alerts | Channel archives |
| CC2.2 - External communication | Security contact, responsible disclosure | security.txt file |
| CC2.3 - External party communication | Vendor security assessments | Assessment reports |

#### CC3 - Risk Assessment

| Control | Implementation | Evidence |
|---------|----------------|----------|
| CC3.1 - Risk objectives | Risk register maintained | Risk register |
| CC3.2 - Risk identification | Quarterly risk assessments | Assessment reports |
| CC3.3 - Fraud consideration | Fraud scenarios in threat model | Threat model document |
| CC3.4 - Change identification | Change management process | Change logs |

#### CC6 - Logical and Physical Access

| Control | Implementation | Evidence |
|---------|----------------|----------|
| CC6.1 - Logical access security | API key authentication, OAuth | Auth configuration |
| CC6.2 - Access provisioning | Manual provisioning by admin | Access request tickets |
| CC6.3 - Access removal | Offboarding checklist | Offboarding records |
| CC6.6 - Access restriction | RBAC for admin functions | Permission matrix |
| CC6.7 - Data encryption | TLS 1.3, AES-256 at rest | Cloudflare config |

#### CC7 - System Operations

| Control | Implementation | Evidence |
|---------|----------------|----------|
| CC7.1 - Vulnerability management | Dependabot, npm audit | Scan reports |
| CC7.2 - Anomaly detection | Cloudflare analytics, alerting | Alert configurations |
| CC7.3 - Incident response | Incident response plan | IR runbook |
| CC7.4 - Recovery operations | Backup and restore procedures | Backup logs |

### Availability

| Control | Implementation | Evidence |
|---------|----------------|----------|
| A1.1 - Capacity management | Cloudflare auto-scaling | Usage metrics |
| A1.2 - Recovery testing | Quarterly DR tests | Test results |

### Confidentiality

| Control | Implementation | Evidence |
|---------|----------------|----------|
| C1.1 - Confidential data identification | Data classification policy | Policy document |
| C1.2 - Confidential data protection | Encryption, access controls | Configuration |

### Privacy

| Control | Implementation | Evidence |
|---------|----------------|----------|
| P1.1 - Privacy notice | Privacy policy published | Policy URL |
| P3.1 - Personal information collection | Consent management | Consent records |
| P4.1 - Personal information use | Purpose limitation | Data flow diagram |
| P6.1 - Data subject rights | GDPR endpoints | API documentation |
| P8.1 - Data quality | Input validation | Validation rules |
```

#### Subtask 8.4.4.2: Audit Logging Enhancement (0.5h)

```typescript
// src/services/audit.ts

interface AuditEvent {
  eventType: string;
  entityType: string;
  entityId: number | string;
  action: string;
  performedBy: number | string;
  workspaceId?: number;
  metadata?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
}

const AUDIT_EVENT_TYPES = [
  // Authentication events
  'auth:login',
  'auth:logout',
  'auth:failed',
  'auth:api_key_created',
  'auth:api_key_revoked',

  // Data access events
  'data:export',
  'data:view_pii',

  // CRUD events
  'feedback:created',
  'feedback:updated',
  'feedback:deleted',
  'feedback:moderated',

  // Admin events
  'admin:settings_changed',
  'admin:user_added',
  'admin:user_removed',
  'admin:role_changed',

  // GDPR events
  'gdpr:export_requested',
  'gdpr:delete_requested',
  'gdpr:consent_updated',

  // Integration events
  'integration:connected',
  'integration:disconnected',
  'integration:sync_started',
  'integration:sync_failed',
] as const;

export async function logAuditEvent(
  db: D1Database,
  event: AuditEvent
): Promise<void> {
  await db.prepare(`
    INSERT INTO audit_log (
      event_type, entity_type, entity_id, action,
      performed_by, workspace_id, metadata,
      ip_address, user_agent, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
  `).bind(
    event.eventType,
    event.entityType,
    event.entityId.toString(),
    event.action,
    event.performedBy.toString(),
    event.workspaceId || null,
    JSON.stringify(event.metadata || {}),
    event.ipAddress || null,
    event.userAgent || null
  ).run();
}

// Query audit logs with filters
export async function queryAuditLogs(
  db: D1Database,
  filters: {
    workspaceId?: number;
    eventType?: string;
    entityType?: string;
    performedBy?: number;
    startDate?: string;
    endDate?: string;
  },
  pagination: { page: number; limit: number }
): Promise<{ events: any[]; total: number }> {
  let whereClause = '1=1';
  const params: any[] = [];

  if (filters.workspaceId) {
    whereClause += ' AND workspace_id = ?';
    params.push(filters.workspaceId);
  }
  if (filters.eventType) {
    whereClause += ' AND event_type = ?';
    params.push(filters.eventType);
  }
  if (filters.entityType) {
    whereClause += ' AND entity_type = ?';
    params.push(filters.entityType);
  }
  if (filters.startDate) {
    whereClause += ' AND created_at >= ?';
    params.push(filters.startDate);
  }
  if (filters.endDate) {
    whereClause += ' AND created_at <= ?';
    params.push(filters.endDate);
  }

  const offset = (pagination.page - 1) * pagination.limit;

  const countResult = await db.prepare(`
    SELECT COUNT(*) as total FROM audit_log WHERE ${whereClause}
  `).bind(...params).first();

  const events = await db.prepare(`
    SELECT * FROM audit_log
    WHERE ${whereClause}
    ORDER BY created_at DESC
    LIMIT ? OFFSET ?
  `).bind(...params, pagination.limit, offset).all();

  return {
    events: events.results,
    total: countResult?.total as number || 0,
  };
}
```

**Acceptance Criteria**:
- [ ] SOC 2 control matrix documented
- [ ] Evidence collection procedures defined
- [ ] Comprehensive audit logging implemented
- [ ] Audit log query API available

---

## Definition of Done

- [ ] Security audit completed with no critical issues
- [ ] All OWASP Top 10 vulnerabilities addressed
- [ ] Rate limiting in place for all endpoints
- [ ] GDPR data rights fully implemented
- [ ] SOC 2 controls documented
- [ ] Audit logging comprehensive

---

## Technical Notes

### Security Headers Configuration
Apply security headers at the Cloudflare edge for best performance.
Consider using Cloudflare Managed Rules for additional protection.

### Rate Limiting Storage
Use KV for rate limit counters with appropriate TTL.
Consider Redis for higher-volume scenarios.

### GDPR Considerations
- Right to erasure may conflict with audit requirements
- Retain anonymized data for analytics
- Document lawful basis for processing

---

## Related Files

- `src/middleware/security.ts` - Security headers
- `src/middleware/rate-limit.ts` - Rate limiting
- `src/services/gdpr.ts` - GDPR functions
- `src/services/audit.ts` - Audit logging
- `docs/security/` - Security documentation
