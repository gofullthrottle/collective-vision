# Epic 1.4: Team Roles & Permissions

## Methodology Guidance
**SPECTRA Phase**: Implementation/Authorization
**Approach**: Role-based access control (RBAC) with middleware enforcement
**Tools**: Custom permission middleware, D1 queries

## Wave Context
**Wave**: 1 - Authentication & User Management
**Priority**: High (enables team collaboration)
**Dependencies**: Epic 1.1 (database), Epic 1.2 (auth)
**Estimated Duration**: 5 hours

## Quality Requirements
- All protected endpoints check permissions
- No authorization bypass possible
- Clear permission denied messages
- Owner role cannot be accidentally removed

---

## Tasks

### 1.4.1 Permission System Design (1h)
**Objective**: Define permission matrix and create checking utilities

**Steps**:
1. Define complete permission matrix:
   ```typescript
   // src/lib/auth/permissions.ts

   export const ROLES = ['owner', 'admin', 'member', 'viewer'] as const;
   export type Role = typeof ROLES[number];

   export const PERMISSIONS = {
     // Feedback operations
     'feedback:view': ['owner', 'admin', 'member', 'viewer'],
     'feedback:create': ['owner', 'admin', 'member'],
     'feedback:moderate': ['owner', 'admin'],
     'feedback:delete': ['owner', 'admin'],

     // Comment operations
     'comment:view': ['owner', 'admin', 'member', 'viewer'],
     'comment:create': ['owner', 'admin', 'member'],
     'comment:internal': ['owner', 'admin'],  // Internal/team comments

     // Team operations
     'team:view': ['owner', 'admin', 'member', 'viewer'],
     'team:invite': ['owner', 'admin'],
     'team:remove': ['owner', 'admin'],
     'team:change_role': ['owner', 'admin'],

     // Workspace operations
     'workspace:view': ['owner', 'admin', 'member', 'viewer'],
     'workspace:settings': ['owner', 'admin'],
     'workspace:delete': ['owner'],
     'workspace:billing': ['owner'],

     // Analytics
     'analytics:view': ['owner', 'admin', 'member'],
     'analytics:export': ['owner', 'admin'],

     // API Keys
     'api_keys:view': ['owner', 'admin'],
     'api_keys:create': ['owner', 'admin'],
     'api_keys:revoke': ['owner', 'admin'],
   } as const;

   export type Permission = keyof typeof PERMISSIONS;
   ```

2. Create permission checking utilities:
   ```typescript
   export function hasPermission(role: Role, permission: Permission): boolean {
     const allowedRoles = PERMISSIONS[permission];
     return allowedRoles.includes(role);
   }

   export function getRoleRank(role: Role): number {
     return { owner: 0, admin: 1, member: 2, viewer: 3 }[role];
   }

   export function canManageRole(actorRole: Role, targetRole: Role): boolean {
     // Can only manage roles below your own
     return getRoleRank(actorRole) < getRoleRank(targetRole);
   }
   ```

**Acceptance Criteria**:
- [ ] Complete permission matrix documented
- [ ] Permission checking utilities work correctly
- [ ] Role hierarchy enforced

---

### 1.4.2 Permission Middleware (1.5h)
**Objective**: Create middleware for enforcing permissions

**Steps**:
1. Create `requireAuth` middleware:
   ```typescript
   // src/middleware/auth.ts

   export async function requireAuth(
     request: Request,
     env: Env
   ): Promise<User> {
     const authHeader = request.headers.get('Authorization');

     if (!authHeader?.startsWith('Bearer ')) {
       throw new AuthError('UNAUTHORIZED', 'Authentication required', 401);
     }

     const token = authHeader.slice(7);

     // Try JWT first
     try {
       const payload = await verifyJWT(token, env.JWT_SECRET);
       const user = await getUserById(payload.sub, env);
       if (!user) throw new Error('User not found');
       return user;
     } catch {
       // Try API key
       const apiKey = await verifyApiKey(token, env);
       if (apiKey) {
         const user = await getUserById(apiKey.user_id, env);
         if (!user) throw new Error('User not found');
         return { ...user, apiKeyId: apiKey.id, apiKeyScopes: apiKey.scopes };
       }
     }

     throw new AuthError('UNAUTHORIZED', 'Invalid token', 401);
   }
   ```

2. Create `requireWorkspaceMember` middleware:
   ```typescript
   export async function requireWorkspaceMember(
     request: Request,
     env: Env,
     workspaceId: string
   ): Promise<{ user: User; membership: TeamMembership }> {
     const user = await requireAuth(request, env);

     const membership = await env.DB.prepare(`
       SELECT * FROM team_memberships
       WHERE user_id = ? AND workspace_id = ?
     `).bind(user.id, workspaceId).first();

     if (!membership) {
       throw new AuthError('FORBIDDEN', 'Not a member of this workspace', 403);
     }

     return { user, membership };
   }
   ```

3. Create `requirePermission` middleware:
   ```typescript
   export async function requirePermission(
     request: Request,
     env: Env,
     workspaceId: string,
     permission: Permission
   ): Promise<{ user: User; membership: TeamMembership }> {
     const { user, membership } = await requireWorkspaceMember(request, env, workspaceId);

     if (!hasPermission(membership.role as Role, permission)) {
       throw new AuthError(
         'FORBIDDEN',
         `Permission denied: ${permission} requires ${PERMISSIONS[permission].join(' or ')} role`,
         403
       );
     }

     return { user, membership };
   }
   ```

4. Apply middleware to existing endpoints:
   ```typescript
   // Example: moderating feedback
   async function handleModerateFeedback(request: Request, env: Env) {
     const { workspaceId, feedbackId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'feedback:moderate');
     // ... moderation logic
   }
   ```

**Acceptance Criteria**:
- [ ] Unauthenticated requests return 401
- [ ] Insufficient role returns 403
- [ ] Error messages clearly state required role
- [ ] All protected endpoints use middleware

---

### 1.4.3 Team Management Endpoints (2h)
**Objective**: CRUD operations for team members

**Steps**:
1. List members endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/members
   async function handleListMembers(request: Request, env: Env) {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'team:view');

     const members = await env.DB.prepare(`
       SELECT u.id, u.email, u.name, u.avatar_url,
              tm.role, tm.created_at as joined_at
       FROM team_memberships tm
       JOIN users u ON tm.user_id = u.id
       WHERE tm.workspace_id = ?
       ORDER BY tm.role, tm.created_at
     `).bind(workspaceId).all();

     return jsonResponse({ members: members.results });
   }
   ```

2. Invite member endpoint:
   ```typescript
   // POST /api/v1/workspaces/:id/members
   async function handleInviteMember(request: Request, env: Env) {
     const { workspaceId } = parseParams(request);
     const { user: inviter } = await requirePermission(request, env, workspaceId, 'team:invite');

     const { email, role } = await validateBody(request, inviteSchema);

     // Validate role (cannot invite owner)
     if (role === 'owner') {
       return errorResponse('INVALID_ROLE', 'Cannot invite as owner', 400);
     }

     // Check if already a member
     const existingMember = await findMemberByEmail(workspaceId, email, env);
     if (existingMember) {
       return errorResponse('ALREADY_MEMBER', 'User is already a member', 400);
     }

     // Check for pending invitation
     const existingInvite = await findPendingInvite(workspaceId, email, env);
     if (existingInvite) {
       return errorResponse('INVITE_EXISTS', 'Invitation already sent', 400);
     }

     // Create invitation
     const token = generateSecureToken();
     const inviteId = generateId('invite');

     await env.DB.prepare(`
       INSERT INTO workspace_invitations
         (id, workspace_id, email, role, token_hash, invited_by, expires_at)
       VALUES (?, ?, ?, ?, ?, ?, datetime('now', '+7 days'))
     `).bind(inviteId, workspaceId, email.toLowerCase(), role, hashToken(token), inviter.id).run();

     // Send invitation email
     await sendInvitationEmail(email, workspaceId, token, env);

     return jsonResponse({
       invitation: { id: inviteId, email, role, expires_in: 7 * 24 * 60 * 60 }
     }, 201);
   }
   ```

3. Update member role:
   ```typescript
   // PATCH /api/v1/workspaces/:id/members/:userId
   async function handleUpdateMemberRole(request: Request, env: Env) {
     const { workspaceId, userId } = parseParams(request);
     const { user: actor, membership: actorMembership } = await requirePermission(
       request, env, workspaceId, 'team:change_role'
     );

     const { role: newRole } = await validateBody(request, updateRoleSchema);

     // Get target member
     const targetMembership = await getMembership(userId, workspaceId, env);
     if (!targetMembership) {
       return errorResponse('NOT_FOUND', 'Member not found', 404);
     }

     // Cannot change owner role
     if (targetMembership.role === 'owner') {
       return errorResponse('FORBIDDEN', 'Cannot change owner role', 403);
     }

     // Cannot promote to owner
     if (newRole === 'owner') {
       return errorResponse('FORBIDDEN', 'Cannot promote to owner', 403);
     }

     // Can only change roles below your own
     if (!canManageRole(actorMembership.role as Role, targetMembership.role as Role)) {
       return errorResponse('FORBIDDEN', 'Cannot manage this member', 403);
     }

     await env.DB.prepare(
       'UPDATE team_memberships SET role = ? WHERE id = ?'
     ).bind(newRole, targetMembership.id).run();

     // Audit log
     await logAuditEvent('team.role_changed', actor.id, workspaceId, {
       target_user_id: userId,
       old_role: targetMembership.role,
       new_role: newRole
     }, env);

     return jsonResponse({ message: 'Role updated' });
   }
   ```

4. Remove member:
   ```typescript
   // DELETE /api/v1/workspaces/:id/members/:userId
   async function handleRemoveMember(request: Request, env: Env) {
     const { workspaceId, userId } = parseParams(request);
     const { user: actor, membership: actorMembership } = await requirePermission(
       request, env, workspaceId, 'team:remove'
     );

     const targetMembership = await getMembership(userId, workspaceId, env);
     if (!targetMembership) {
       return errorResponse('NOT_FOUND', 'Member not found', 404);
     }

     // Cannot remove owner
     if (targetMembership.role === 'owner') {
       return errorResponse('FORBIDDEN', 'Cannot remove workspace owner', 403);
     }

     // Cannot remove yourself (use leave instead)
     if (userId === actor.id) {
       return errorResponse('FORBIDDEN', 'Use leave endpoint to leave workspace', 403);
     }

     await env.DB.prepare(
       'DELETE FROM team_memberships WHERE id = ?'
     ).bind(targetMembership.id).run();

     return jsonResponse({ message: 'Member removed' });
   }
   ```

**Acceptance Criteria**:
- [ ] List, invite, update, remove all working
- [ ] Only admins+ can manage members
- [ ] Owner cannot be removed or demoted
- [ ] Role changes logged to audit

---

### 1.4.4 Invite System (0.5h)
**Objective**: Handle invitation acceptance

**Steps**:
1. Accept invitation endpoint:
   ```typescript
   // POST /api/v1/invites/:token/accept
   async function handleAcceptInvite(request: Request, env: Env) {
     const { token } = parseParams(request);
     const tokenHash = hashToken(token);

     // Find invitation
     const invite = await env.DB.prepare(`
       SELECT * FROM workspace_invitations
       WHERE token_hash = ? AND accepted_at IS NULL AND expires_at > datetime('now')
     `).bind(tokenHash).first();

     if (!invite) {
       return errorResponse('INVALID_INVITE', 'Invalid or expired invitation', 400);
     }

     // Require authentication
     const user = await requireAuth(request, env);

     // Verify email matches (optional strict mode)
     // if (user.email !== invite.email) { ... }

     // Create membership
     await env.DB.batch([
       env.DB.prepare(`
         INSERT INTO team_memberships (id, user_id, workspace_id, role, invited_by)
         VALUES (?, ?, ?, ?, ?)
       `).bind(generateId('mem'), user.id, invite.workspace_id, invite.role, invite.invited_by),
       env.DB.prepare(
         'UPDATE workspace_invitations SET accepted_at = datetime(\'now\') WHERE id = ?'
       ).bind(invite.id)
     ]);

     return jsonResponse({
       message: 'Invitation accepted',
       workspace_id: invite.workspace_id
     });
   }
   ```

2. Add ability to revoke pending invitations:
   ```typescript
   // DELETE /api/v1/workspaces/:id/invitations/:inviteId
   async function handleRevokeInvite(request: Request, env: Env) {
     const { workspaceId, inviteId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'team:invite');

     await env.DB.prepare(
       'DELETE FROM workspace_invitations WHERE id = ? AND workspace_id = ?'
     ).bind(inviteId, workspaceId).run();

     return jsonResponse({ message: 'Invitation revoked' });
   }
   ```

**Acceptance Criteria**:
- [ ] Invites expire after 7 days
- [ ] Can be revoked before acceptance
- [ ] User becomes member on acceptance
- [ ] Invitation marked as used

---

## Definition of Done
- [ ] All CRUD operations for team members work
- [ ] Permission middleware applied to all endpoints
- [ ] Owner protection in place
- [ ] Invitation flow complete
- [ ] Audit logging for role changes

## Technical Notes
- Consider caching membership lookups in KV for performance
- Rate limit invitation emails to prevent abuse
- Consider allowing owner transfer (with confirmation)

## Related Files
- `src/lib/auth/permissions.ts` - Permission definitions
- `src/middleware/auth.ts` - Auth middleware
- `src/routes/team.ts` - Team endpoints
