# Epic 6.2: Subscription Tier Management

## Methodology Guidance
**SPECTRA Phase**: Implementation/Business Logic
**Approach**: Feature gating and limit enforcement
**Tools**: Tier configuration, feature flags

## Wave Context
**Wave**: 6 - Monetization & Scaling
**Priority**: P0 (enables tiered access)
**Dependencies**: 6.1 (Stripe integration)
**Estimated Duration**: 6 hours

## Quality Requirements
- Clear tier boundaries
- Graceful limit handling
- Upgrade prompts not intrusive
- No data loss on downgrade

---

## Tasks

### 6.2.1 Tier Definition (1.5h)
**Objective**: Define tier limits and features

**Steps**:
1. Create tier configuration:
   ```typescript
   // src/lib/billing/tiers.ts

   export interface TierLimits {
     boards: number;
     feedback_per_month: number;
     team_members: number;
     integrations: number;
     ai_credits_monthly: number;
     api_requests_daily: number;
     storage_mb: number;
     custom_branding: boolean;
     badge_removal: boolean;
     priority_support: boolean;
     custom_domain: boolean;
     sso: boolean;
     audit_logs: boolean;
     advanced_analytics: boolean;
   }

   export const TIER_LIMITS: Record<string, TierLimits> = {
     free: {
       boards: 2,
       feedback_per_month: 100,
       team_members: 2,
       integrations: 0,
       ai_credits_monthly: 500,
       api_requests_daily: 1000,
       storage_mb: 100,
       custom_branding: false,
       badge_removal: false,
       priority_support: false,
       custom_domain: false,
       sso: false,
       audit_logs: false,
       advanced_analytics: false
     },
     pro: {
       boards: 10,
       feedback_per_month: 1000,
       team_members: 10,
       integrations: 5,
       ai_credits_monthly: 5000,
       api_requests_daily: 10000,
       storage_mb: 1000,
       custom_branding: true,
       badge_removal: true,
       priority_support: false,
       custom_domain: true,
       sso: false,
       audit_logs: true,
       advanced_analytics: true
     },
     enterprise: {
       boards: Infinity,
       feedback_per_month: Infinity,
       team_members: Infinity,
       integrations: Infinity,
       ai_credits_monthly: Infinity,
       api_requests_daily: 100000,
       storage_mb: 10000,
       custom_branding: true,
       badge_removal: true,
       priority_support: true,
       custom_domain: true,
       sso: true,
       audit_logs: true,
       advanced_analytics: true
     }
   };

   export const TIER_DISPLAY = {
     free: {
       name: 'Free',
       price: '$0',
       description: 'For individuals and small projects',
       color: '#6B7280'
     },
     pro: {
       name: 'Pro',
       price: '$49/mo',
       description: 'For growing teams and products',
       color: '#3B82F6'
     },
     enterprise: {
       name: 'Enterprise',
       price: '$199/mo',
       description: 'For large organizations',
       color: '#8B5CF6'
     }
   };
   ```

2. Update workspace schema:
   ```sql
   ALTER TABLE workspaces ADD COLUMN plan_tier TEXT DEFAULT 'free';
   ALTER TABLE workspaces ADD COLUMN plan_expires_at TEXT;
   ```

3. Create tier info endpoint:
   ```typescript
   // GET /api/v1/billing/tiers
   async function handleGetTiers(request: Request, env: Env): Promise<Response> {
     return jsonResponse({
       tiers: Object.entries(TIER_LIMITS).map(([key, limits]) => ({
         id: key,
         ...TIER_DISPLAY[key],
         limits
       }))
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Tiers clearly defined
- [ ] Limits documented
- [ ] Config in code

---

### 6.2.2 Feature Flag System (2h)
**Objective**: Gate features by tier

**Steps**:
1. Create feature check utilities:
   ```typescript
   // src/lib/billing/features.ts

   export function canUseFeature(
     tier: string,
     feature: keyof TierLimits
   ): boolean {
     const limits = TIER_LIMITS[tier];
     if (!limits) return false;

     const value = limits[feature];
     return typeof value === 'boolean' ? value : value > 0;
   }

   export async function hasFeatureAccess(
     env: Env,
     workspaceId: string,
     feature: keyof TierLimits
   ): Promise<boolean> {
     const workspace = await env.DB.prepare(`
       SELECT plan_tier FROM workspaces WHERE id = ?
     `).bind(workspaceId).first();

     if (!workspace) return false;
     return canUseFeature(workspace.plan_tier as string, feature);
   }

   export function getLimit(tier: string, resource: keyof TierLimits): number {
     const limits = TIER_LIMITS[tier];
     if (!limits) return 0;

     const value = limits[resource];
     return typeof value === 'number' ? value : 0;
   }
   ```

2. Create usage tracking:
   ```sql
   CREATE TABLE usage_metrics (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL REFERENCES workspaces(id),
     metric_type TEXT NOT NULL,  -- boards, feedback, api_requests, ai_credits, storage
     period TEXT NOT NULL,       -- YYYY-MM for monthly, YYYY-MM-DD for daily
     count INTEGER DEFAULT 0,
     updated_at TEXT DEFAULT (datetime('now')),
     UNIQUE(workspace_id, metric_type, period)
   );

   CREATE INDEX idx_usage_workspace ON usage_metrics(workspace_id, metric_type, period);
   ```

3. Create usage tracking utilities:
   ```typescript
   // src/lib/billing/usage.ts

   export async function incrementUsage(
     env: Env,
     workspaceId: string,
     metricType: string,
     increment: number = 1
   ): Promise<void> {
     const period = metricType === 'api_requests'
       ? new Date().toISOString().slice(0, 10)  // Daily
       : new Date().toISOString().slice(0, 7);   // Monthly

     await env.DB.prepare(`
       INSERT INTO usage_metrics (id, workspace_id, metric_type, period, count)
       VALUES (?, ?, ?, ?, ?)
       ON CONFLICT (workspace_id, metric_type, period)
       DO UPDATE SET count = count + ?, updated_at = datetime('now')
     `).bind(
       generateId('usage'),
       workspaceId,
       metricType,
       period,
       increment,
       increment
     ).run();
   }

   export async function getUsage(
     env: Env,
     workspaceId: string,
     metricType: string
   ): Promise<number> {
     const period = metricType === 'api_requests'
       ? new Date().toISOString().slice(0, 10)
       : new Date().toISOString().slice(0, 7);

     const result = await env.DB.prepare(`
       SELECT count FROM usage_metrics
       WHERE workspace_id = ? AND metric_type = ? AND period = ?
     `).bind(workspaceId, metricType, period).first();

     return (result?.count as number) || 0;
   }

   export async function getRemainingLimit(
     env: Env,
     workspaceId: string,
     resource: keyof TierLimits
   ): Promise<{ used: number; limit: number; remaining: number }> {
     const workspace = await env.DB.prepare(`
       SELECT plan_tier FROM workspaces WHERE id = ?
     `).bind(workspaceId).first();

     if (!workspace) {
       return { used: 0, limit: 0, remaining: 0 };
     }

     const tier = workspace.plan_tier as string;
     const limit = getLimit(tier, resource);
     const used = await getUsage(env, workspaceId, resource as string);

     return {
       used,
       limit,
       remaining: limit === Infinity ? Infinity : Math.max(0, limit - used)
     };
   }
   ```

4. Create feature gate middleware:
   ```typescript
   // src/middleware/feature-gate.ts

   export function requireFeature(feature: keyof TierLimits) {
     return async (request: Request, env: Env, workspaceId: string): Promise<Response | null> => {
       const hasAccess = await hasFeatureAccess(env, workspaceId, feature);

       if (!hasAccess) {
         return jsonResponse({
           error: 'UPGRADE_REQUIRED',
           message: `This feature requires a higher plan`,
           feature,
           upgrade_url: '/settings/billing'
         }, 403);
       }

       return null;  // Continue
     };
   }

   export function requireLimit(resource: keyof TierLimits) {
     return async (request: Request, env: Env, workspaceId: string): Promise<Response | null> => {
       const { remaining, limit } = await getRemainingLimit(env, workspaceId, resource);

       if (remaining <= 0 && limit !== Infinity) {
         return jsonResponse({
           error: 'LIMIT_EXCEEDED',
           message: `You've reached your ${resource} limit`,
           resource,
           limit,
           upgrade_url: '/settings/billing'
         }, 403);
       }

       return null;  // Continue
     };
   }
   ```

**Acceptance Criteria**:
- [ ] Features gated by tier
- [ ] Usage tracked accurately
- [ ] Clear messaging

---

### 6.2.3 Limit Enforcement (1.5h)
**Objective**: Enforce limits at resource creation

**Steps**:
1. Integrate limits into resource creation:
   ```typescript
   // Example: Board creation with limit check
   async function handleCreateBoard(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, BoardCreateSchema);

     await requirePermission(request, env, workspaceId, 'boards:create');

     // Check limit
     const { remaining, limit } = await getRemainingLimit(env, workspaceId, 'boards');

     if (remaining <= 0 && limit !== Infinity) {
       return jsonResponse({
         error: 'LIMIT_EXCEEDED',
         message: 'You have reached your board limit',
         current: limit - remaining,
         limit,
         upgrade_url: '/settings/billing'
       }, 403);
     }

     // Create board
     const boardId = generateId('board');
     await env.DB.prepare(`
       INSERT INTO boards (id, workspace_id, name, slug)
       VALUES (?, ?, ?, ?)
     `).bind(boardId, workspaceId, input.name, input.slug).run();

     return jsonResponse({ id: boardId }, 201);
   }
   ```

2. Create soft limit warnings:
   ```typescript
   // src/lib/billing/warnings.ts

   export async function checkLimitWarnings(
     env: Env,
     workspaceId: string
   ): Promise<Array<{ resource: string; usage: number; limit: number; percentage: number }>> {
     const warnings: Array<{ resource: string; usage: number; limit: number; percentage: number }> = [];

     const resourcesToCheck: Array<keyof TierLimits> = [
       'boards', 'feedback_per_month', 'team_members', 'ai_credits_monthly', 'storage_mb'
     ];

     for (const resource of resourcesToCheck) {
       const { used, limit } = await getRemainingLimit(env, workspaceId, resource);

       if (limit !== Infinity) {
         const percentage = Math.round((used / limit) * 100);
         if (percentage >= 80) {
           warnings.push({ resource: resource as string, usage: used, limit, percentage });
         }
       }
     }

     return warnings;
   }
   ```

3. Add limit checks to all relevant endpoints:
   ```typescript
   // Feedback submission
   async function handleCreateFeedback(request: Request, env: Env): Promise<Response> {
     // ...existing code...

     // Check monthly feedback limit
     const { remaining } = await getRemainingLimit(env, workspaceId, 'feedback_per_month');
     if (remaining <= 0) {
       return jsonResponse({
         error: 'LIMIT_EXCEEDED',
         message: 'Monthly feedback limit reached',
         upgrade_url: '/settings/billing'
       }, 403);
     }

     // Create feedback...

     // Track usage
     await incrementUsage(env, workspaceId, 'feedback_per_month');

     return jsonResponse({ id: feedbackId }, 201);
   }

   // Team member invite
   async function handleInviteMember(request: Request, env: Env): Promise<Response> {
     // Check team member limit
     const currentMembers = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM workspace_members WHERE workspace_id = ?
     `).bind(workspaceId).first();

     const { limit } = await getRemainingLimit(env, workspaceId, 'team_members');

     if ((currentMembers?.count as number) >= limit && limit !== Infinity) {
       return jsonResponse({
         error: 'LIMIT_EXCEEDED',
         message: 'Team member limit reached',
         upgrade_url: '/settings/billing'
       }, 403);
     }

     // Continue with invite...
   }
   ```

**Acceptance Criteria**:
- [ ] Limits enforced
- [ ] Clear error messages
- [ ] Upgrade path shown

---

### 6.2.4 Upgrade/Downgrade Flows (1h)
**Objective**: Handle plan changes gracefully

**Steps**:
1. Create plan change handler:
   ```typescript
   // Handled via Stripe webhook, but need local logic

   async function handlePlanChange(
     env: Env,
     workspaceId: string,
     oldTier: string,
     newTier: string
   ): Promise<void> {
     // Upgrade: Immediate access
     if (tierValue(newTier) > tierValue(oldTier)) {
       await env.DB.prepare(`
         UPDATE workspaces SET plan_tier = ?, updated_at = datetime('now')
         WHERE id = ?
       `).bind(newTier, workspaceId).run();

       // Log plan change
       await logAudit(env, workspaceId, 'plan_upgraded', { from: oldTier, to: newTier });
       return;
     }

     // Downgrade: Check for over-limit issues
     const issues = await checkDowngradeIssues(env, workspaceId, newTier);

     if (issues.length > 0) {
       // Store pending downgrade
       await env.DB.prepare(`
         UPDATE workspaces
         SET pending_tier = ?, pending_tier_issues = ?,
             updated_at = datetime('now')
         WHERE id = ?
       `).bind(newTier, JSON.stringify(issues), workspaceId).run();

       // Notify admin about required actions
       await sendDowngradeWarning(env, workspaceId, issues);
     } else {
       // Clean downgrade
       await env.DB.prepare(`
         UPDATE workspaces SET plan_tier = ?, updated_at = datetime('now')
         WHERE id = ?
       `).bind(newTier, workspaceId).run();
     }
   }

   function tierValue(tier: string): number {
     const values: Record<string, number> = { free: 0, pro: 1, enterprise: 2 };
     return values[tier] || 0;
   }

   async function checkDowngradeIssues(
     env: Env,
     workspaceId: string,
     newTier: string
   ): Promise<Array<{ resource: string; current: number; newLimit: number }>> {
     const issues: Array<{ resource: string; current: number; newLimit: number }> = [];
     const newLimits = TIER_LIMITS[newTier];

     // Check boards
     const boardCount = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM boards WHERE workspace_id = ?
     `).bind(workspaceId).first();

     if ((boardCount?.count as number) > newLimits.boards) {
       issues.push({
         resource: 'boards',
         current: boardCount?.count as number,
         newLimit: newLimits.boards
       });
     }

     // Check team members
     const memberCount = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM workspace_members WHERE workspace_id = ?
     `).bind(workspaceId).first();

     if ((memberCount?.count as number) > newLimits.team_members) {
       issues.push({
         resource: 'team_members',
         current: memberCount?.count as number,
         newLimit: newLimits.team_members
       });
     }

     // Check integrations
     const integrationCount = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM integrations WHERE workspace_id = ? AND status = 'connected'
     `).bind(workspaceId).first();

     if ((integrationCount?.count as number) > newLimits.integrations) {
       issues.push({
         resource: 'integrations',
         current: integrationCount?.count as number,
         newLimit: newLimits.integrations
       });
     }

     return issues;
   }
   ```

2. Create downgrade resolution endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/downgrade-preview
   async function handleDowngradePreview(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const url = new URL(request.url);
     const targetTier = url.searchParams.get('tier') || 'free';

     await requirePermission(request, env, workspaceId, 'billing:manage');

     const issues = await checkDowngradeIssues(env, workspaceId, targetTier);

     return jsonResponse({
       target_tier: targetTier,
       can_downgrade: issues.length === 0,
       issues: issues.map(i => ({
         resource: i.resource,
         message: `You have ${i.current} ${i.resource}, but the ${targetTier} plan allows ${i.newLimit}`,
         action_required: `Remove ${i.current - i.newLimit} ${i.resource} to downgrade`
       }))
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Upgrades instant
- [ ] Downgrades handled gracefully
- [ ] No data loss

---

## Definition of Done
- [ ] All tiers defined with limits
- [ ] Feature flags working
- [ ] Limits enforced at all points
- [ ] Upgrade/downgrade flows smooth
- [ ] Usage tracked accurately

## Technical Notes
- Cache tier lookups for performance
- Use soft limits (warnings) at 80%
- Hard limits block at 100%
- Downgrade doesn't delete data, just restricts

## Related Files
- `src/lib/billing/tiers.ts` - Tier configuration
- `src/lib/billing/features.ts` - Feature checks
- `src/lib/billing/usage.ts` - Usage tracking
- `src/middleware/feature-gate.ts` - Feature middleware
