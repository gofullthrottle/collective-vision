# Epic 1.3: OAuth Integration

## Methodology Guidance
**SPECTRA Phase**: Implementation/Social Auth
**Approach**: OAuth 2.0 Authorization Code Flow with PKCE
**Tools**: Google OAuth, GitHub OAuth, manual OAuth implementation

## Wave Context
**Wave**: 1 - Authentication & User Management
**Priority**: High (user convenience for signup/login)
**Dependencies**: Epic 1.1 (database), Epic 1.2 (base auth)
**Estimated Duration**: 6 hours

## Quality Requirements
- Secure OAuth state parameter to prevent CSRF
- Proper handling of denied access
- Account linking for existing users
- No duplicate accounts for same email

---

## Tasks

### 1.3.1 OAuth Configuration (1h)
**Objective**: Set up OAuth apps and configuration

**Steps**:
1. Create Google OAuth App:
   - Go to Google Cloud Console → APIs & Services → Credentials
   - Create OAuth 2.0 Client ID (Web application)
   - Add authorized redirect URI: `https://your-domain.com/api/v1/auth/google/callback`
   - Note Client ID and Client Secret

2. Create GitHub OAuth App:
   - Go to GitHub Settings → Developer Settings → OAuth Apps
   - Create new OAuth App
   - Add callback URL: `https://your-domain.com/api/v1/auth/github/callback`
   - Note Client ID and Client Secret

3. Store secrets in Cloudflare:
   ```bash
   wrangler secret put GOOGLE_CLIENT_ID
   wrangler secret put GOOGLE_CLIENT_SECRET
   wrangler secret put GITHUB_CLIENT_ID
   wrangler secret put GITHUB_CLIENT_SECRET
   ```

4. Create OAuth configuration module:
   ```typescript
   // src/lib/auth/oauth-config.ts
   export const OAUTH_PROVIDERS = {
     google: {
       authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
       tokenUrl: 'https://oauth2.googleapis.com/token',
       userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
       scopes: ['openid', 'email', 'profile']
     },
     github: {
       authUrl: 'https://github.com/login/oauth/authorize',
       tokenUrl: 'https://github.com/login/oauth/access_token',
       userInfoUrl: 'https://api.github.com/user',
       emailsUrl: 'https://api.github.com/user/emails',
       scopes: ['user:email']
     }
   };
   ```

**Acceptance Criteria**:
- [ ] OAuth apps created in Google and GitHub
- [ ] Secrets stored in Cloudflare
- [ ] Configuration module created

---

### 1.3.2 Google OAuth Flow (2h)
**Objective**: Complete Google OAuth login/signup

**Steps**:
1. Create OAuth redirect endpoint:
   ```typescript
   // GET /api/v1/auth/google
   async function handleGoogleAuth(request: Request, env: Env) {
     const url = new URL(request.url);
     const redirectTo = url.searchParams.get('redirect') || '/';

     // Generate state for CSRF protection
     const state = generateSecureToken();
     await storeOAuthState(state, { provider: 'google', redirectTo }, env);

     const authUrl = new URL(OAUTH_PROVIDERS.google.authUrl);
     authUrl.searchParams.set('client_id', env.GOOGLE_CLIENT_ID);
     authUrl.searchParams.set('redirect_uri', `${env.APP_URL}/api/v1/auth/google/callback`);
     authUrl.searchParams.set('response_type', 'code');
     authUrl.searchParams.set('scope', OAUTH_PROVIDERS.google.scopes.join(' '));
     authUrl.searchParams.set('state', state);
     authUrl.searchParams.set('access_type', 'offline');
     authUrl.searchParams.set('prompt', 'consent');

     return Response.redirect(authUrl.toString(), 302);
   }
   ```

2. Create callback handler:
   ```typescript
   // GET /api/v1/auth/google/callback
   async function handleGoogleCallback(request: Request, env: Env) {
     const url = new URL(request.url);
     const code = url.searchParams.get('code');
     const state = url.searchParams.get('state');
     const error = url.searchParams.get('error');

     if (error) {
       return redirectWithError(env.APP_URL, 'OAuth denied');
     }

     // Verify state
     const storedState = await verifyOAuthState(state, env);
     if (!storedState || storedState.provider !== 'google') {
       return redirectWithError(env.APP_URL, 'Invalid state');
     }

     // Exchange code for tokens
     const tokenResponse = await fetch(OAUTH_PROVIDERS.google.tokenUrl, {
       method: 'POST',
       headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
       body: new URLSearchParams({
         code,
         client_id: env.GOOGLE_CLIENT_ID,
         client_secret: env.GOOGLE_CLIENT_SECRET,
         redirect_uri: `${env.APP_URL}/api/v1/auth/google/callback`,
         grant_type: 'authorization_code'
       })
     });

     const tokens = await tokenResponse.json();

     // Fetch user profile
     const userResponse = await fetch(OAUTH_PROVIDERS.google.userInfoUrl, {
       headers: { 'Authorization': `Bearer ${tokens.access_token}` }
     });

     const googleUser = await userResponse.json();

     // Find or create user
     const user = await findOrCreateOAuthUser({
       provider: 'google',
       providerUserId: googleUser.id,
       email: googleUser.email,
       name: googleUser.name,
       avatarUrl: googleUser.picture,
       tokens
     }, env);

     // Generate app tokens and redirect
     const accessToken = await generateAccessToken(user, env);
     const refreshToken = await generateRefreshToken(user, env);
     await createSession(user.id, refreshToken, env);

     return redirectWithTokens(storedState.redirectTo, accessToken, refreshToken);
   }
   ```

3. Implement user finding/creation:
   ```typescript
   async function findOrCreateOAuthUser(oauthData: OAuthUserData, env: Env) {
     // Check for existing OAuth account
     let oauthAccount = await env.DB.prepare(`
       SELECT oa.*, u.* FROM oauth_accounts oa
       JOIN users u ON oa.user_id = u.id
       WHERE oa.provider = ? AND oa.provider_user_id = ?
     `).bind(oauthData.provider, oauthData.providerUserId).first();

     if (oauthAccount) {
       // Update tokens
       await updateOAuthTokens(oauthAccount.id, oauthData.tokens, env);
       return oauthAccount;
     }

     // Check for existing user with same email
     let user = await env.DB.prepare(
       'SELECT * FROM users WHERE email = ?'
     ).bind(oauthData.email.toLowerCase()).first();

     if (!user) {
       // Create new user
       const userId = generateId('user');
       await env.DB.prepare(`
         INSERT INTO users (id, email, name, avatar_url, email_verified)
         VALUES (?, ?, ?, ?, 1)
       `).bind(userId, oauthData.email.toLowerCase(), oauthData.name, oauthData.avatarUrl).run();

       user = { id: userId, email: oauthData.email, name: oauthData.name };
     }

     // Link OAuth account
     await env.DB.prepare(`
       INSERT INTO oauth_accounts (id, user_id, provider, provider_user_id, provider_email, access_token, refresh_token, token_expires_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
     `).bind(
       generateId('oauth'),
       user.id,
       oauthData.provider,
       oauthData.providerUserId,
       oauthData.email,
       oauthData.tokens.access_token,
       oauthData.tokens.refresh_token,
       oauthData.tokens.expires_in ? new Date(Date.now() + oauthData.tokens.expires_in * 1000).toISOString() : null
     ).run();

     return user;
   }
   ```

**Acceptance Criteria**:
- [ ] New users created with Google profile
- [ ] Existing users linked if same email
- [ ] Proper error handling for denied access
- [ ] State parameter prevents CSRF

---

### 1.3.3 GitHub OAuth Flow (2h)
**Objective**: Complete GitHub OAuth login/signup

**Steps**:
1. Create GitHub redirect endpoint (similar to Google):
   ```typescript
   // GET /api/v1/auth/github
   async function handleGitHubAuth(request: Request, env: Env) {
     const state = generateSecureToken();
     await storeOAuthState(state, { provider: 'github', redirectTo: '/' }, env);

     const authUrl = new URL(OAUTH_PROVIDERS.github.authUrl);
     authUrl.searchParams.set('client_id', env.GITHUB_CLIENT_ID);
     authUrl.searchParams.set('redirect_uri', `${env.APP_URL}/api/v1/auth/github/callback`);
     authUrl.searchParams.set('scope', OAUTH_PROVIDERS.github.scopes.join(' '));
     authUrl.searchParams.set('state', state);

     return Response.redirect(authUrl.toString(), 302);
   }
   ```

2. Create GitHub callback (with email handling):
   ```typescript
   // GET /api/v1/auth/github/callback
   async function handleGitHubCallback(request: Request, env: Env) {
     // ... similar code exchange as Google ...

     // Fetch user profile
     const userResponse = await fetch(OAUTH_PROVIDERS.github.userInfoUrl, {
       headers: {
         'Authorization': `Bearer ${tokens.access_token}`,
         'Accept': 'application/json'
       }
     });

     const githubUser = await userResponse.json();

     // GitHub may not have public email - fetch from emails API
     let email = githubUser.email;
     if (!email) {
       const emailsResponse = await fetch(OAUTH_PROVIDERS.github.emailsUrl, {
         headers: {
           'Authorization': `Bearer ${tokens.access_token}`,
           'Accept': 'application/json'
         }
       });
       const emails = await emailsResponse.json();
       const primaryEmail = emails.find(e => e.primary && e.verified);
       email = primaryEmail?.email;
     }

     if (!email) {
       return redirectWithError(env.APP_URL, 'No verified email found on GitHub account');
     }

     // Find or create user
     const user = await findOrCreateOAuthUser({
       provider: 'github',
       providerUserId: githubUser.id.toString(),
       email,
       name: githubUser.name || githubUser.login,
       avatarUrl: githubUser.avatar_url,
       tokens
     }, env);

     // Generate tokens and redirect
     // ... same as Google ...
   }
   ```

**Acceptance Criteria**:
- [ ] Same flow as Google OAuth
- [ ] Handle GitHub users without public email (fetch from emails API)
- [ ] Use login name if no display name

---

### 1.3.4 Account Linking (1h)
**Objective**: Allow logged-in users to link additional OAuth providers

**Steps**:
1. Create linking endpoints:
   ```typescript
   // POST /api/v1/auth/link/google
   // POST /api/v1/auth/link/github
   async function handleLinkOAuth(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const provider = request.url.includes('google') ? 'google' : 'github';

     // Check if already linked
     const existing = await env.DB.prepare(`
       SELECT id FROM oauth_accounts WHERE user_id = ? AND provider = ?
     `).bind(user.id, provider).first();

     if (existing) {
       return errorResponse('ALREADY_LINKED', `${provider} account already linked`, 400);
     }

     // Store state with link intent
     const state = generateSecureToken();
     await storeOAuthState(state, {
       provider,
       intent: 'link',
       userId: user.id,
       redirectTo: '/settings/accounts'
     }, env);

     // Redirect to OAuth provider
     // ... same redirect logic ...
   }
   ```

2. Handle link in callback:
   ```typescript
   // In callback handler, check for link intent
   if (storedState.intent === 'link') {
     // Verify OAuth account not already linked to another user
     const existingLink = await env.DB.prepare(`
       SELECT user_id FROM oauth_accounts WHERE provider = ? AND provider_user_id = ?
     `).bind(provider, providerUserId).first();

     if (existingLink) {
       return redirectWithError(storedState.redirectTo, 'This account is already linked to another user');
     }

     // Link to current user
     await env.DB.prepare(`
       INSERT INTO oauth_accounts (id, user_id, provider, provider_user_id, ...)
       VALUES (?, ?, ?, ?, ...)
     `).bind(generateId('oauth'), storedState.userId, provider, providerUserId, ...).run();

     return Response.redirect(storedState.redirectTo, 302);
   }
   ```

**Acceptance Criteria**:
- [ ] User can log in via any linked method
- [ ] Cannot link already-used OAuth account
- [ ] Clear error messages for link conflicts

---

## Definition of Done
- [ ] Google OAuth working for signup and login
- [ ] GitHub OAuth working for signup and login
- [ ] Account linking functional
- [ ] Existing users auto-linked by email
- [ ] OAuth state prevents CSRF

## Technical Notes
- Store OAuth state in KV with 10-minute TTL
- Encrypt stored OAuth tokens at rest
- Consider PKCE for enhanced security
- Handle token refresh for long-lived integrations

## Related Files
- `src/lib/auth/oauth-config.ts` - Provider configuration
- `src/lib/auth/oauth.ts` - OAuth utilities
- `src/routes/auth/google.ts` - Google routes
- `src/routes/auth/github.ts` - GitHub routes
