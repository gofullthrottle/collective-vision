# Epic 5.4: Multi-Channel Listeners

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Real-time feedback from community platforms
**Tools**: Platform APIs, webhooks, bots

## Wave Context
**Wave**: 5 - Data Ingestion & Multi-Channel
**Priority**: P2 (community engagement)
**Dependencies**: 5.1 (import infrastructure), 5.3 (keyword matching)
**Estimated Duration**: 8 hours

## Quality Requirements
- Real-time or near-real-time ingestion
- Proper attribution to source
- Respect platform rate limits
- Handle API failures gracefully

---

## Tasks

### 5.4.1 Reddit Monitoring (2h)
**Objective**: Monitor subreddits for relevant mentions

**Steps**:
1. Create Reddit API client:
   ```typescript
   // src/lib/channels/reddit.ts

   interface RedditConfig {
     client_id: string;
     client_secret: string;
     username: string;
     password: string;
     user_agent: string;
   }

   interface RedditPost {
     id: string;
     title: string;
     selftext: string;
     author: string;
     subreddit: string;
     score: number;
     num_comments: number;
     created_utc: number;
     permalink: string;
     url: string;
   }

   interface RedditComment {
     id: string;
     body: string;
     author: string;
     score: number;
     created_utc: number;
     permalink: string;
     parent_id: string;
   }

   export class RedditClient {
     private accessToken: string | null = null;
     private tokenExpiry: number = 0;
     private config: RedditConfig;

     constructor(config: RedditConfig) {
       this.config = config;
     }

     private async authenticate(): Promise<void> {
       if (this.accessToken && Date.now() < this.tokenExpiry) {
         return;
       }

       const auth = btoa(`${this.config.client_id}:${this.config.client_secret}`);
       const response = await fetch('https://www.reddit.com/api/v1/access_token', {
         method: 'POST',
         headers: {
           'Authorization': `Basic ${auth}`,
           'Content-Type': 'application/x-www-form-urlencoded',
           'User-Agent': this.config.user_agent
         },
         body: `grant_type=password&username=${this.config.username}&password=${this.config.password}`
       });

       if (!response.ok) {
         throw new Error(`Reddit auth failed: ${response.status}`);
       }

       const data = await response.json();
       this.accessToken = data.access_token;
       this.tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000;
     }

     private async request(endpoint: string): Promise<unknown> {
       await this.authenticate();

       const response = await fetch(`https://oauth.reddit.com${endpoint}`, {
         headers: {
           'Authorization': `Bearer ${this.accessToken}`,
           'User-Agent': this.config.user_agent
         }
       });

       if (!response.ok) {
         throw new Error(`Reddit API error: ${response.status}`);
       }

       return response.json();
     }

     async searchPosts(
       query: string,
       subreddit?: string,
       options?: { limit?: number; sort?: 'new' | 'relevance' | 'top' }
     ): Promise<RedditPost[]> {
       const params = new URLSearchParams({
         q: query,
         limit: String(options?.limit || 25),
         sort: options?.sort || 'new',
         t: 'week'
       });

       const path = subreddit
         ? `/r/${subreddit}/search.json?${params}&restrict_sr=on`
         : `/search.json?${params}`;

       const data = await this.request(path) as {
         data: { children: Array<{ data: RedditPost }> }
       };

       return data.data.children.map(c => c.data);
     }

     async getNewPosts(subreddit: string, limit: number = 25): Promise<RedditPost[]> {
       const data = await this.request(`/r/${subreddit}/new.json?limit=${limit}`) as {
         data: { children: Array<{ data: RedditPost }> }
       };
       return data.data.children.map(c => c.data);
     }

     async getComments(postId: string): Promise<RedditComment[]> {
       const data = await this.request(`/comments/${postId}.json`) as Array<{
         data: { children: Array<{ data: RedditComment }> }
       }>;

       // Second element contains comments
       if (data.length < 2) return [];
       return data[1].data.children
         .filter(c => c.data.body)
         .map(c => c.data);
     }
   }
   ```

2. Create Reddit channel listener:
   ```typescript
   // src/lib/channels/reddit-listener.ts

   interface RedditChannelConfig {
     subreddits: string[];
     keywords: string[];
     exclude_keywords?: string[];
     include_comments?: boolean;
     min_score?: number;
   }

   export async function processRedditChannel(
     env: Env,
     workspaceId: string,
     channelId: string,
     config: RedditChannelConfig
   ): Promise<{ processed: number; ingested: number }> {
     const reddit = new RedditClient({
       client_id: env.REDDIT_CLIENT_ID,
       client_secret: env.REDDIT_CLIENT_SECRET,
       username: env.REDDIT_USERNAME,
       password: env.REDDIT_PASSWORD,
       user_agent: 'CollectiveVision/1.0'
     });

     let processed = 0;
     let ingested = 0;

     for (const subreddit of config.subreddits) {
       // Get new posts
       const posts = await reddit.getNewPosts(subreddit, 50);

       for (const post of posts) {
         processed++;

         // Check if already processed
         const existing = await env.DB.prepare(`
           SELECT id FROM import_signatures
           WHERE workspace_id = ? AND source_type = 'reddit' AND source_id = ?
         `).bind(workspaceId, post.id).first();

         if (existing) continue;

         // Check min score
         if (config.min_score && post.score < config.min_score) continue;

         // Match keywords
         const keywordConfig = {
           include: config.keywords.map(k => ({ term: k, type: 'fuzzy' as const, weight: 5 })),
           exclude: config.exclude_keywords?.map(k => ({ term: k, type: 'exact' as const }))
         };

         const content = `${post.title}\n${post.selftext}`;
         const match = matchKeywords(content, post.title, keywordConfig);

         if (!match.matched) continue;

         // Detect pain points
         const painSignals = detectPainPoints(content);
         const isPainPoint = painSignals.some(s => s.confidence >= 0.5);

         // Create import item
         const item: ImportItem = {
           source_type: 'reddit',
           source_id: post.id,
           source_url: `https://reddit.com${post.permalink}`,
           title: post.title,
           description: post.selftext || '[Link post]',
           votes: post.score,
           created_at: new Date(post.created_utc * 1000).toISOString(),
           author: { name: post.author },
           source_metadata: {
             subreddit: post.subreddit,
             num_comments: post.num_comments,
             matched_keywords: match.matches.map(m => m.keyword),
             is_pain_point: isPainPoint,
             pain_signals: painSignals
           }
         };

         // Import the item
         await importChannelItem(env, workspaceId, channelId, item);
         ingested++;

         // Optionally process comments
         if (config.include_comments && post.num_comments > 0) {
           const comments = await reddit.getComments(post.id);

           for (const comment of comments.slice(0, 10)) {  // Limit comments
             const commentMatch = matchKeywords(comment.body, '', keywordConfig);
             if (!commentMatch.matched) continue;

             const commentItem: ImportItem = {
               source_type: 'reddit',
               source_id: `${post.id}_${comment.id}`,
               source_url: `https://reddit.com${comment.permalink}`,
               title: `Re: ${post.title.slice(0, 50)}...`,
               description: comment.body,
               votes: comment.score,
               created_at: new Date(comment.created_utc * 1000).toISOString(),
               author: { name: comment.author },
               source_metadata: {
                 parent_post_id: post.id,
                 subreddit: post.subreddit
               }
             };

             await importChannelItem(env, workspaceId, channelId, commentItem);
             ingested++;
           }
         }

         // Rate limit
         await new Promise(r => setTimeout(r, 100));
       }
     }

     return { processed, ingested };
   }
   ```

3. Create channels table and API:
   ```sql
   CREATE TABLE channels (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     type TEXT NOT NULL,  -- 'reddit', 'discord', 'slack', 'support'
     config TEXT NOT NULL,
     board_id TEXT NOT NULL,  -- Target board for ingested items
     status TEXT DEFAULT 'active',
     last_poll_at TEXT,
     poll_interval INTEGER DEFAULT 300,  -- seconds
     stats TEXT,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
     FOREIGN KEY (board_id) REFERENCES boards(id)
   );

   CREATE INDEX idx_channels_poll ON channels(status, last_poll_at);
   ```

**Acceptance Criteria**:
- [ ] Reddit posts ingested
- [ ] Comments optionally included
- [ ] Score filtering works
- [ ] Deduplication prevents re-import

---

### 5.4.2 Discord Bot (2h)
**Objective**: Capture feedback from Discord channels

**Steps**:
1. Create Discord bot client:
   ```typescript
   // src/lib/channels/discord.ts

   interface DiscordConfig {
     bot_token: string;
     guild_id: string;
     channel_ids: string[];
   }

   interface DiscordMessage {
     id: string;
     content: string;
     author: {
       id: string;
       username: string;
       discriminator: string;
       avatar: string | null;
     };
     channel_id: string;
     guild_id: string;
     timestamp: string;
     reactions?: Array<{
       emoji: { name: string };
       count: number;
     }>;
     referenced_message?: DiscordMessage;
   }

   export class DiscordClient {
     private token: string;

     constructor(config: DiscordConfig) {
       this.token = config.bot_token;
     }

     private async request(endpoint: string, method: string = 'GET'): Promise<unknown> {
       const response = await fetch(`https://discord.com/api/v10${endpoint}`, {
         method,
         headers: {
           'Authorization': `Bot ${this.token}`,
           'Content-Type': 'application/json'
         }
       });

       if (!response.ok) {
         throw new Error(`Discord API error: ${response.status}`);
       }

       return response.json();
     }

     async getMessages(
       channelId: string,
       options?: { limit?: number; after?: string }
     ): Promise<DiscordMessage[]> {
       const params = new URLSearchParams();
       if (options?.limit) params.set('limit', String(options.limit));
       if (options?.after) params.set('after', options.after);

       return this.request(`/channels/${channelId}/messages?${params}`) as Promise<DiscordMessage[]>;
     }

     async getChannel(channelId: string): Promise<{ name: string; guild_id: string }> {
       return this.request(`/channels/${channelId}`) as Promise<{ name: string; guild_id: string }>;
     }
   }
   ```

2. Create Discord webhook handler:
   ```typescript
   // POST /api/v1/webhooks/discord/:channelId
   // Discord sends events via webhooks, but we'll also poll

   interface DiscordChannelConfig {
     keywords?: string[];
     reaction_threshold?: number;  // Min reactions to capture
     capture_threads?: boolean;
     feedback_emoji?: string;      // Specific emoji to trigger capture
   }

   export async function processDiscordChannel(
     env: Env,
     workspaceId: string,
     channelId: string,
     config: DiscordChannelConfig
   ): Promise<{ processed: number; ingested: number }> {
     const discord = new DiscordClient({
       bot_token: env.DISCORD_BOT_TOKEN,
       guild_id: '',  // Set per workspace
       channel_ids: []
     });

     // Get channel to get the stored last_message_id
     const channel = await env.DB.prepare(`
       SELECT config FROM channels WHERE id = ?
     `).bind(channelId).first();

     const channelConfig = JSON.parse(channel?.config as string || '{}');
     const lastMessageId = channelConfig.last_message_id;

     const messages = await discord.getMessages(channelConfig.discord_channel_id, {
       limit: 100,
       after: lastMessageId
     });

     let processed = 0;
     let ingested = 0;

     for (const message of messages.reverse()) {  // Process oldest first
       processed++;

       // Skip bot messages
       if (message.author.username.includes('[BOT]')) continue;

       // Check reaction threshold
       const totalReactions = message.reactions?.reduce((sum, r) => sum + r.count, 0) || 0;
       if (config.reaction_threshold && totalReactions < config.reaction_threshold) continue;

       // Check for specific feedback emoji
       if (config.feedback_emoji) {
         const hasFeedbackEmoji = message.reactions?.some(
           r => r.emoji.name === config.feedback_emoji
         );
         if (!hasFeedbackEmoji) continue;
       }

       // Check keywords if configured
       if (config.keywords && config.keywords.length > 0) {
         const keywordConfig = {
           include: config.keywords.map(k => ({ term: k, type: 'fuzzy' as const, weight: 5 }))
         };
         const match = matchKeywords(message.content, '', keywordConfig);
         if (!match.matched) continue;
       }

       // Create import item
       const item: ImportItem = {
         source_type: 'discord',
         source_id: message.id,
         source_url: `https://discord.com/channels/${message.guild_id}/${message.channel_id}/${message.id}`,
         title: message.content.slice(0, 100) + (message.content.length > 100 ? '...' : ''),
         description: message.content,
         votes: totalReactions,
         created_at: message.timestamp,
         author: {
           external_id: message.author.id,
           name: `${message.author.username}#${message.author.discriminator}`,
           avatar_url: message.author.avatar
             ? `https://cdn.discordapp.com/avatars/${message.author.id}/${message.author.avatar}.png`
             : undefined
         },
         source_metadata: {
           channel_id: message.channel_id,
           guild_id: message.guild_id,
           reactions: message.reactions,
           reply_to: message.referenced_message?.id
         }
       };

       await importChannelItem(env, workspaceId, channelId, item);
       ingested++;
     }

     // Update last processed message ID
     if (messages.length > 0) {
       const lastId = messages[messages.length - 1].id;
       await env.DB.prepare(`
         UPDATE channels SET config = json_set(config, '$.last_message_id', ?)
         WHERE id = ?
       `).bind(lastId, channelId).run();
     }

     return { processed, ingested };
   }
   ```

3. Create Discord slash command for manual feedback:
   ```typescript
   // Discord interaction handler for /feedback command
   export async function handleDiscordInteraction(
     request: Request,
     env: Env
   ): Promise<Response> {
     const body = await request.json();

     // Verify Discord signature
     const signature = request.headers.get('X-Signature-Ed25519');
     const timestamp = request.headers.get('X-Signature-Timestamp');

     if (!verifyDiscordSignature(body, signature!, timestamp!, env.DISCORD_PUBLIC_KEY)) {
       return new Response('Invalid signature', { status: 401 });
     }

     // Handle ping (required by Discord)
     if (body.type === 1) {
       return jsonResponse({ type: 1 });
     }

     // Handle slash command
     if (body.type === 2 && body.data.name === 'feedback') {
       const title = body.data.options?.find((o: any) => o.name === 'title')?.value;
       const description = body.data.options?.find((o: any) => o.name === 'description')?.value;

       if (!title) {
         return jsonResponse({
           type: 4,
           data: { content: 'Please provide a title for your feedback.', flags: 64 }
         });
       }

       // Find workspace for this guild
       const channel = await env.DB.prepare(`
         SELECT c.*, w.id as workspace_id FROM channels c
         JOIN workspaces w ON c.workspace_id = w.id
         WHERE c.type = 'discord' AND json_extract(c.config, '$.guild_id') = ?
         LIMIT 1
       `).bind(body.guild_id).first();

       if (!channel) {
         return jsonResponse({
           type: 4,
           data: { content: 'This server is not connected to Collective Vision.', flags: 64 }
         });
       }

       // Create feedback
       const item: ImportItem = {
         source_type: 'discord',
         source_id: `cmd_${body.id}`,
         title,
         description: description || '',
         author: {
           external_id: body.member.user.id,
           name: body.member.user.username
         }
       };

       await importChannelItem(env, channel.workspace_id as string, channel.id as string, item);

       return jsonResponse({
         type: 4,
         data: {
           content: `Feedback submitted: "${title}"\nThank you for your input!`,
           flags: 64
         }
       });
     }

     return new Response('Unknown interaction', { status: 400 });
   }
   ```

**Acceptance Criteria**:
- [ ] Bot captures messages from configured channels
- [ ] Reaction filtering works
- [ ] Slash command for direct feedback
- [ ] Author attribution preserved

---

### 5.4.3 Slack App (2h)
**Objective**: Integrate with Slack workspaces

**Steps**:
1. Create Slack client:
   ```typescript
   // src/lib/channels/slack.ts

   interface SlackConfig {
     bot_token: string;
     signing_secret: string;
   }

   interface SlackMessage {
     type: string;
     ts: string;
     user: string;
     text: string;
     channel: string;
     reactions?: Array<{
       name: string;
       count: number;
       users: string[];
     }>;
     thread_ts?: string;
   }

   interface SlackUser {
     id: string;
     name: string;
     real_name: string;
     profile: {
       email?: string;
       image_72?: string;
     };
   }

   export class SlackClient {
     private token: string;

     constructor(config: SlackConfig) {
       this.token = config.bot_token;
     }

     private async request(
       method: string,
       body?: Record<string, unknown>
     ): Promise<unknown> {
       const response = await fetch(`https://slack.com/api/${method}`, {
         method: 'POST',
         headers: {
           'Authorization': `Bearer ${this.token}`,
           'Content-Type': 'application/json'
         },
         body: body ? JSON.stringify(body) : undefined
       });

       const data = await response.json();
       if (!data.ok) {
         throw new Error(`Slack API error: ${data.error}`);
       }

       return data;
     }

     async getConversationHistory(
       channelId: string,
       options?: { oldest?: string; limit?: number }
     ): Promise<SlackMessage[]> {
       const data = await this.request('conversations.history', {
         channel: channelId,
         oldest: options?.oldest,
         limit: options?.limit || 100
       }) as { messages: SlackMessage[] };

       return data.messages;
     }

     async getUserInfo(userId: string): Promise<SlackUser> {
       const data = await this.request('users.info', { user: userId }) as { user: SlackUser };
       return data.user;
     }

     async postMessage(channelId: string, text: string): Promise<void> {
       await this.request('chat.postMessage', {
         channel: channelId,
         text
       });
     }

     async addReaction(channelId: string, timestamp: string, emoji: string): Promise<void> {
       await this.request('reactions.add', {
         channel: channelId,
         timestamp,
         name: emoji
       });
     }
   }
   ```

2. Create Slack event handler:
   ```typescript
   // POST /api/v1/webhooks/slack
   export async function handleSlackEvent(
     request: Request,
     env: Env
   ): Promise<Response> {
     const body = await request.json();

     // Verify Slack signature
     const signature = request.headers.get('X-Slack-Signature');
     const timestamp = request.headers.get('X-Slack-Request-Timestamp');

     if (!verifySlackSignature(body, signature!, timestamp!, env.SLACK_SIGNING_SECRET)) {
       return new Response('Invalid signature', { status: 401 });
     }

     // Handle URL verification
     if (body.type === 'url_verification') {
       return jsonResponse({ challenge: body.challenge });
     }

     // Handle events
     if (body.type === 'event_callback') {
       const event = body.event;

       // Emoji reaction added - trigger feedback capture
       if (event.type === 'reaction_added' && event.reaction === 'feedback') {
         await env.CHANNEL_QUEUE.send({
           type: 'slack_reaction_feedback',
           team_id: body.team_id,
           channel_id: event.item.channel,
           message_ts: event.item.ts,
           reacting_user: event.user
         });
       }

       // App mention - check for feedback command
       if (event.type === 'app_mention') {
         const text = event.text.toLowerCase();
         if (text.includes('feedback:') || text.includes('submit feedback')) {
           await env.CHANNEL_QUEUE.send({
             type: 'slack_mention_feedback',
             team_id: body.team_id,
             channel_id: event.channel,
             message_ts: event.ts,
             user_id: event.user,
             text: event.text
           });
         }
       }

       // Message in feedback channel
       if (event.type === 'message' && !event.subtype) {
         await env.CHANNEL_QUEUE.send({
           type: 'slack_channel_message',
           team_id: body.team_id,
           channel_id: event.channel,
           message_ts: event.ts,
           user_id: event.user,
           text: event.text
         });
       }
     }

     return jsonResponse({ ok: true });
   }
   ```

3. Create Slack shortcut/modal:
   ```typescript
   // Handle Slack interactive components (shortcuts, modals)
   export async function handleSlackInteractive(
     request: Request,
     env: Env
   ): Promise<Response> {
     const formData = await request.formData();
     const payload = JSON.parse(formData.get('payload') as string);

     // Global shortcut - open feedback modal
     if (payload.type === 'shortcut' && payload.callback_id === 'submit_feedback') {
       const slack = new SlackClient({ bot_token: env.SLACK_BOT_TOKEN, signing_secret: '' });

       await slack.request('views.open', {
         trigger_id: payload.trigger_id,
         view: {
           type: 'modal',
           callback_id: 'feedback_modal',
           title: { type: 'plain_text', text: 'Submit Feedback' },
           submit: { type: 'plain_text', text: 'Submit' },
           blocks: [
             {
               type: 'input',
               block_id: 'title_block',
               element: {
                 type: 'plain_text_input',
                 action_id: 'title',
                 placeholder: { type: 'plain_text', text: 'Brief summary...' }
               },
               label: { type: 'plain_text', text: 'Title' }
             },
             {
               type: 'input',
               block_id: 'description_block',
               element: {
                 type: 'plain_text_input',
                 action_id: 'description',
                 multiline: true,
                 placeholder: { type: 'plain_text', text: 'Describe your feedback in detail...' }
               },
               label: { type: 'plain_text', text: 'Description' },
               optional: true
             },
             {
               type: 'input',
               block_id: 'type_block',
               element: {
                 type: 'static_select',
                 action_id: 'type',
                 options: [
                   { text: { type: 'plain_text', text: 'Feature Request' }, value: 'feature' },
                   { text: { type: 'plain_text', text: 'Bug Report' }, value: 'bug' },
                   { text: { type: 'plain_text', text: 'Improvement' }, value: 'improvement' },
                   { text: { type: 'plain_text', text: 'Question' }, value: 'question' }
                 ]
               },
               label: { type: 'plain_text', text: 'Type' }
             }
           ]
         }
       });

       return new Response('', { status: 200 });
     }

     // Modal submission
     if (payload.type === 'view_submission' && payload.view.callback_id === 'feedback_modal') {
       const values = payload.view.state.values;
       const title = values.title_block.title.value;
       const description = values.description_block?.description?.value || '';
       const feedbackType = values.type_block.type.selected_option.value;

       // Find channel config for this team
       const channel = await env.DB.prepare(`
         SELECT * FROM channels
         WHERE type = 'slack' AND json_extract(config, '$.team_id') = ?
         LIMIT 1
       `).bind(payload.team.id).first();

       if (channel) {
         const item: ImportItem = {
           source_type: 'slack',
           source_id: `modal_${payload.id}`,
           title,
           description,
           category: feedbackType,
           author: {
             external_id: payload.user.id,
             name: payload.user.name
           }
         };

         await importChannelItem(env, channel.workspace_id as string, channel.id as string, item);
       }

       // Acknowledge submission
       return jsonResponse({ response_action: 'clear' });
     }

     return new Response('Unknown interaction', { status: 400 });
   }
   ```

**Acceptance Criteria**:
- [ ] Events received via webhook
- [ ] Emoji reactions trigger capture
- [ ] Modal submission works
- [ ] Messages from channels ingested

---

### 5.4.4 Support Ticket Webhooks (2h)
**Objective**: Ingest from support systems

**Steps**:
1. Create generic webhook handler:
   ```typescript
   // POST /api/v1/webhooks/support/:channelId
   export async function handleSupportWebhook(
     request: Request,
     env: Env
   ): Promise<Response> {
     const { channelId } = parseParams(request);

     // Get channel config
     const channel = await env.DB.prepare(`
       SELECT * FROM channels WHERE id = ? AND type = 'support' AND status = 'active'
     `).bind(channelId).first();

     if (!channel) {
       return errorResponse('NOT_FOUND', 'Channel not found', 404);
     }

     const config = JSON.parse(channel.config as string);

     // Verify webhook signature if configured
     if (config.webhook_secret) {
       const signature = request.headers.get('X-Webhook-Signature') ||
                        request.headers.get('X-Hub-Signature-256');

       if (!verifyWebhookSignature(await request.clone().text(), signature!, config.webhook_secret)) {
         return new Response('Invalid signature', { status: 401 });
       }
     }

     const body = await request.json();

     // Map based on platform type
     let item: ImportItem;

     switch (config.platform) {
       case 'zendesk':
         item = mapZendeskTicket(body, config);
         break;
       case 'intercom':
         item = mapIntercomConversation(body, config);
         break;
       case 'freshdesk':
         item = mapFreshdeskTicket(body, config);
         break;
       case 'helpscout':
         item = mapHelpScoutConversation(body, config);
         break;
       default:
         item = mapGenericWebhook(body, config);
     }

     await importChannelItem(env, channel.workspace_id as string, channelId, item);

     return jsonResponse({ ingested: true });
   }
   ```

2. Create platform-specific mappers:
   ```typescript
   // src/lib/channels/support-mappers.ts

   interface SupportConfig {
     platform: string;
     tag_filter?: string[];
     status_filter?: string[];
     extract_feedback?: boolean;
   }

   export function mapZendeskTicket(body: any, config: SupportConfig): ImportItem {
     const ticket = body.ticket || body;

     return {
       source_type: 'support',
       source_id: `zendesk_${ticket.id}`,
       source_url: ticket.url,
       title: ticket.subject || ticket.title,
       description: ticket.description || ticket.comment?.body,
       status: mapZendeskStatus(ticket.status),
       priority: mapZendeskPriority(ticket.priority),
       tags: ticket.tags,
       created_at: ticket.created_at,
       author: {
         external_id: ticket.requester_id?.toString(),
         name: ticket.requester?.name,
         email: ticket.requester?.email
       },
       source_metadata: {
         platform: 'zendesk',
         ticket_type: ticket.type,
         channel: ticket.via?.channel,
         satisfaction_rating: ticket.satisfaction_rating
       }
     };
   }

   export function mapIntercomConversation(body: any, config: SupportConfig): ImportItem {
     const convo = body.data?.item || body;

     // Get first user message
     const userParts = convo.conversation_parts?.conversation_parts?.filter(
       (p: any) => p.author?.type === 'user'
     ) || [];

     const firstMessage = userParts[0]?.body || convo.source?.body || '';

     return {
       source_type: 'support',
       source_id: `intercom_${convo.id}`,
       source_url: `https://app.intercom.com/a/apps/${body.app_id}/inbox/inbox/all/conversations/${convo.id}`,
       title: convo.source?.subject || firstMessage.slice(0, 100),
       description: firstMessage,
       created_at: convo.created_at ? new Date(convo.created_at * 1000).toISOString() : undefined,
       author: {
         external_id: convo.user?.id,
         name: convo.user?.name,
         email: convo.user?.email
       },
       source_metadata: {
         platform: 'intercom',
         state: convo.state,
         tags: convo.tags?.map((t: any) => t.name)
       }
     };
   }

   export function mapFreshdeskTicket(body: any, config: SupportConfig): ImportItem {
     const ticket = body.ticket || body;

     return {
       source_type: 'support',
       source_id: `freshdesk_${ticket.id}`,
       title: ticket.subject,
       description: ticket.description_text || ticket.description,
       status: mapFreshdeskStatus(ticket.status),
       priority: mapFreshdeskPriority(ticket.priority),
       tags: ticket.tags,
       created_at: ticket.created_at,
       author: {
         external_id: ticket.requester_id?.toString(),
         name: ticket.requester?.name,
         email: ticket.requester?.email
       },
       source_metadata: {
         platform: 'freshdesk',
         ticket_type: ticket.type,
         source: ticket.source
       }
     };
   }

   export function mapHelpScoutConversation(body: any, config: SupportConfig): ImportItem {
     const convo = body.conversation || body;

     return {
       source_type: 'support',
       source_id: `helpscout_${convo.id}`,
       title: convo.subject,
       description: convo.preview,
       status: convo.status,
       tags: convo.tags?.map((t: any) => t.tag),
       created_at: convo.createdAt,
       author: {
         external_id: convo.primaryCustomer?.id?.toString(),
         name: `${convo.primaryCustomer?.firstName} ${convo.primaryCustomer?.lastName}`.trim(),
         email: convo.primaryCustomer?.email
       },
       source_metadata: {
         platform: 'helpscout',
         mailbox: convo.mailboxId
       }
     };
   }

   export function mapGenericWebhook(body: any, config: SupportConfig): ImportItem {
     // Try common field names
     return {
       source_type: 'support',
       source_id: body.id || body.ticket_id || body.case_id || generateId('support'),
       title: body.title || body.subject || body.summary || 'Support Ticket',
       description: body.description || body.body || body.content || body.message || '',
       status: body.status,
       priority: body.priority,
       tags: body.tags || body.labels,
       created_at: body.created_at || body.createdAt || body.timestamp,
       author: {
         external_id: body.user_id || body.customer_id || body.requester_id,
         name: body.user_name || body.customer_name || body.author,
         email: body.user_email || body.customer_email || body.email
       },
       source_metadata: {
         platform: 'generic',
         raw: body
       }
     };
   }

   function mapZendeskStatus(status: string): string {
     const mapping: Record<string, string> = {
       'new': 'new',
       'open': 'in_progress',
       'pending': 'reviewing',
       'hold': 'reviewing',
       'solved': 'completed',
       'closed': 'completed'
     };
     return mapping[status] || 'new';
   }

   function mapZendeskPriority(priority: string): number {
     const mapping: Record<string, number> = {
       'urgent': 100,
       'high': 75,
       'normal': 50,
       'low': 25
     };
     return mapping[priority] || 50;
   }

   function mapFreshdeskStatus(status: number): string {
     const mapping: Record<number, string> = {
       2: 'new',        // Open
       3: 'reviewing',  // Pending
       4: 'completed',  // Resolved
       5: 'completed'   // Closed
     };
     return mapping[status] || 'new';
   }

   function mapFreshdeskPriority(priority: number): number {
     const mapping: Record<number, number> = {
       1: 25,   // Low
       2: 50,   // Medium
       3: 75,   // High
       4: 100   // Urgent
     };
     return mapping[priority] || 50;
   }
   ```

3. Create feedback extraction from tickets:
   ```typescript
   // src/lib/channels/feedback-extractor.ts

   export async function extractFeedbackFromTicket(
     env: Env,
     content: string,
     title: string
   ): Promise<{
     is_feedback: boolean;
     feedback_type: 'feature_request' | 'bug' | 'improvement' | 'praise' | null;
     extracted_feedback: string | null;
   }> {
     // Quick heuristic check first
     const feedbackIndicators = [
       'feature request', 'would be great', 'wish there was',
       'please add', 'bug', 'not working', 'broken',
       'improvement', 'suggestion', 'feedback'
     ];

     const hasIndicator = feedbackIndicators.some(i =>
       content.toLowerCase().includes(i) || title.toLowerCase().includes(i)
     );

     if (!hasIndicator) {
       return { is_feedback: false, feedback_type: null, extracted_feedback: null };
     }

     // Use AI for deeper analysis
     const prompt = `Analyze this support ticket and determine if it contains product feedback (feature request, bug report, improvement suggestion, or praise).

Title: ${title}
Content: ${content.slice(0, 1000)}

If it contains feedback, extract the core feedback as a clear, actionable statement.

Respond in JSON:
{
  "is_feedback": boolean,
  "feedback_type": "feature_request" | "bug" | "improvement" | "praise" | null,
  "extracted_feedback": "string or null"
}`;

     const response = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
       messages: [
         { role: 'system', content: 'You extract product feedback from support tickets. Respond only in valid JSON.' },
         { role: 'user', content: prompt }
       ],
       max_tokens: 200
     });

     try {
       return JSON.parse(response.response);
     } catch {
       return {
         is_feedback: hasIndicator,
         feedback_type: null,
         extracted_feedback: null
       };
     }
   }
   ```

**Acceptance Criteria**:
- [ ] Zendesk webhooks processed
- [ ] Intercom webhooks processed
- [ ] Generic webhook fallback works
- [ ] Feedback extracted from tickets

---

## Definition of Done
- [ ] Reddit monitoring working
- [ ] Discord bot functional
- [ ] Slack app integrated
- [ ] Support webhooks processing
- [ ] All channels respect rate limits
- [ ] Proper error handling

## Technical Notes
- Reddit: 60 requests/minute
- Discord: 50 requests/second
- Slack: Tier 3 (50+ req/min)
- Store last processed ID per channel
- Queue heavy processing

## Related Files
- `src/lib/channels/reddit.ts` - Reddit client
- `src/lib/channels/discord.ts` - Discord client
- `src/lib/channels/slack.ts` - Slack client
- `src/lib/channels/support-mappers.ts` - Support platform mappers
- `src/queues/channel-consumer.ts` - Channel processing queue
