# Epic 8.1: Multi-Language Support (i18n)

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Implement comprehensive internationalization with 5+ languages, auto-detection, and optional AI translation.

## Wave Context
**Wave 8**: Enterprise Polish (i18n, Performance, Testing, Security, DevOps)
**Dependencies**: All previous waves (final polish)
**Unlocks**: Global market reach, enterprise adoption, user experience

## Quality Requirements
- Support 5 initial languages (en, es, fr, de, ja, zh)
- Fallback chain: user → workspace → browser → English
- RTL support preparation
- Date/number formatting per locale

---

## Tasks

### Task 8.1.1: i18n Framework Setup (3h)

Set up internationalization infrastructure for Workers environment.

**Subtasks**:
- [ ] Choose and integrate i18n library
- [ ] Configure locale detection
- [ ] Set up translation file structure
- [ ] Implement fallback chain

**File Structure**:
```
src/locales/
├── en/
│   ├── common.json      # Shared strings
│   ├── widget.json      # Widget UI
│   ├── admin.json       # Admin dashboard
│   └── emails.json      # Email templates
├── es/
│   └── ... (same structure)
├── fr/
├── de/
├── ja/
└── zh/
```

**Implementation**:
```typescript
// src/i18n/index.ts
type Locale = 'en' | 'es' | 'fr' | 'de' | 'ja' | 'zh';
type Namespace = 'common' | 'widget' | 'admin' | 'emails';

interface I18nConfig {
  defaultLocale: Locale;
  supportedLocales: Locale[];
  fallbackLocale: Locale;
}

const config: I18nConfig = {
  defaultLocale: 'en',
  supportedLocales: ['en', 'es', 'fr', 'de', 'ja', 'zh'],
  fallbackLocale: 'en'
};

// Translation cache (per-request, stored in KV for persistence)
const translationCache = new Map<string, Record<string, string>>();

export async function loadTranslations(
  env: Env,
  locale: Locale,
  namespace: Namespace
): Promise<Record<string, string>> {
  const cacheKey = `${locale}:${namespace}`;

  // Check memory cache
  if (translationCache.has(cacheKey)) {
    return translationCache.get(cacheKey)!;
  }

  // Load from KV (or bundled JSON in production)
  const kvKey = `translations:${locale}:${namespace}`;
  let translations = await env.TRANSLATIONS_KV.get(kvKey, 'json');

  // Fallback to English if not found
  if (!translations && locale !== 'en') {
    const fallbackKey = `translations:en:${namespace}`;
    translations = await env.TRANSLATIONS_KV.get(fallbackKey, 'json');
  }

  if (translations) {
    translationCache.set(cacheKey, translations);
  }

  return translations || {};
}

// Detect user locale
export function detectLocale(request: Request, userPreference?: string): Locale {
  // Priority: 1. User preference
  if (userPreference && config.supportedLocales.includes(userPreference as Locale)) {
    return userPreference as Locale;
  }

  // 2. Query parameter
  const url = new URL(request.url);
  const queryLocale = url.searchParams.get('lang');
  if (queryLocale && config.supportedLocales.includes(queryLocale as Locale)) {
    return queryLocale as Locale;
  }

  // 3. Accept-Language header
  const acceptLanguage = request.headers.get('Accept-Language');
  if (acceptLanguage) {
    const parsed = parseAcceptLanguage(acceptLanguage);
    for (const lang of parsed) {
      const normalized = normalizeLocale(lang);
      if (config.supportedLocales.includes(normalized)) {
        return normalized;
      }
    }
  }

  // 4. Default
  return config.defaultLocale;
}

function parseAcceptLanguage(header: string): string[] {
  return header
    .split(',')
    .map(part => {
      const [lang, q = 'q=1'] = part.trim().split(';');
      return { lang, q: parseFloat(q.replace('q=', '')) };
    })
    .sort((a, b) => b.q - a.q)
    .map(item => item.lang);
}

function normalizeLocale(locale: string): Locale {
  // Handle variants like 'en-US' -> 'en'
  const base = locale.split('-')[0].toLowerCase();

  // Map Chinese variants
  if (base === 'zh') {
    if (locale.includes('TW') || locale.includes('Hant')) {
      return 'zh'; // Simplified for now, can add zh-TW later
    }
  }

  return config.supportedLocales.includes(base as Locale) ? (base as Locale) : 'en';
}

// Translation function
export function createTranslator(translations: Record<string, string>) {
  return function t(key: string, params?: Record<string, string | number>): string {
    let text = translations[key] || key;

    // Replace placeholders {{name}}
    if (params) {
      for (const [param, value] of Object.entries(params)) {
        text = text.replace(new RegExp(`{{${param}}}`, 'g'), String(value));
      }
    }

    return text;
  };
}

// Plural support
export function plural(
  count: number,
  forms: { zero?: string; one: string; other: string },
  locale: Locale = 'en'
): string {
  if (count === 0 && forms.zero) return forms.zero;
  if (count === 1) return forms.one;
  return forms.other.replace('{{count}}', String(count));
}

// Date formatting
export function formatDate(date: Date | string, locale: Locale, format: 'short' | 'long' = 'short'): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  const options: Intl.DateTimeFormatOptions = format === 'short'
    ? { year: 'numeric', month: 'short', day: 'numeric' }
    : { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' };

  return new Intl.DateTimeFormat(locale, options).format(d);
}

// Number formatting
export function formatNumber(num: number, locale: Locale, options?: Intl.NumberFormatOptions): string {
  return new Intl.NumberFormat(locale, options).format(num);
}

// Relative time
export function formatRelativeTime(date: Date | string, locale: Locale): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  const now = new Date();
  const diffMs = now.getTime() - d.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });

  if (diffDays > 30) return formatDate(d, locale);
  if (diffDays > 0) return rtf.format(-diffDays, 'day');
  if (diffHours > 0) return rtf.format(-diffHours, 'hour');
  if (diffMins > 0) return rtf.format(-diffMins, 'minute');
  return rtf.format(-diffSecs, 'second');
}
```

**Schema Addition**:
```sql
-- User language preference
ALTER TABLE end_users ADD COLUMN preferred_language TEXT DEFAULT 'en';

-- Workspace default language
ALTER TABLE workspaces ADD COLUMN default_language TEXT DEFAULT 'en';
```

**Acceptance Criteria**:
- [ ] i18n framework integrated
- [ ] 6 locales supported
- [ ] Fallback chain working
- [ ] Date/number formatting correct

---

### Task 8.1.2: Widget Translation (3h)

Extract and translate all widget strings.

**Subtasks**:
- [ ] Extract all hardcoded strings
- [ ] Create translation files
- [ ] Implement language selector
- [ ] Support auto-detection

**Widget Translation File** (en/widget.json):
```json
{
  "feedback": {
    "title": "Feedback",
    "submit_placeholder": "Share your feedback...",
    "submit_button": "Submit",
    "vote_button": "Vote",
    "votes": "{{count}} votes",
    "comments": "{{count}} comments",
    "status_open": "Open",
    "status_planned": "Planned",
    "status_in_progress": "In Progress",
    "status_done": "Done",
    "no_feedback": "No feedback yet. Be the first to share!",
    "load_more": "Load more",
    "loading": "Loading...",
    "error": "Something went wrong. Please try again.",
    "success": "Thank you for your feedback!",
    "login_required": "Please log in to submit feedback",
    "already_voted": "You've already voted",
    "powered_by": "Powered by Collective Vision"
  },
  "comments": {
    "title": "Comments",
    "placeholder": "Add a comment...",
    "submit": "Comment",
    "reply": "Reply",
    "show_replies": "Show {{count}} replies",
    "hide_replies": "Hide replies",
    "deleted": "[deleted]"
  },
  "form": {
    "title_label": "Title",
    "title_placeholder": "Brief description of your feedback",
    "description_label": "Description",
    "description_placeholder": "Tell us more...",
    "category_label": "Category",
    "category_bug": "Bug Report",
    "category_feature": "Feature Request",
    "category_improvement": "Improvement",
    "category_question": "Question",
    "email_label": "Email (optional)",
    "email_placeholder": "your@email.com",
    "cancel": "Cancel"
  },
  "languages": {
    "en": "English",
    "es": "Español",
    "fr": "Français",
    "de": "Deutsch",
    "ja": "日本語",
    "zh": "中文"
  }
}
```

**Widget Implementation**:
```typescript
// In widget.js - Add i18n support
(function() {
  const SUPPORTED_LANGUAGES = ['en', 'es', 'fr', 'de', 'ja', 'zh'];

  let translations = {};
  let currentLocale = 'en';

  // Get language from: 1. data-language, 2. localStorage, 3. browser
  function detectLanguage() {
    const script = document.currentScript;
    const dataLang = script?.getAttribute('data-language');

    if (dataLang && SUPPORTED_LANGUAGES.includes(dataLang)) {
      return dataLang;
    }

    const stored = localStorage.getItem('cv_language');
    if (stored && SUPPORTED_LANGUAGES.includes(stored)) {
      return stored;
    }

    const browserLang = navigator.language.split('-')[0];
    if (SUPPORTED_LANGUAGES.includes(browserLang)) {
      return browserLang;
    }

    return 'en';
  }

  async function loadTranslations(locale) {
    try {
      const res = await fetch(`${apiBase}/locales/${locale}/widget.json`);
      if (res.ok) {
        translations = await res.json();
        currentLocale = locale;
      }
    } catch (e) {
      console.warn('Failed to load translations, falling back to English');
    }
  }

  function t(key, params = {}) {
    const keys = key.split('.');
    let value = translations;

    for (const k of keys) {
      value = value?.[k];
    }

    if (typeof value !== 'string') {
      return key; // Fallback to key if not found
    }

    // Replace params
    return value.replace(/\{\{(\w+)\}\}/g, (_, param) => params[param] ?? '');
  }

  // Language selector HTML
  function renderLanguageSelector() {
    const languages = translations.languages || {};
    return `
      <select class="cv-language-select" onchange="cvChangeLanguage(this.value)">
        ${Object.entries(languages).map(([code, name]) => `
          <option value="${code}" ${code === currentLocale ? 'selected' : ''}>${name}</option>
        `).join('')}
      </select>
    `;
  }

  window.cvChangeLanguage = async function(locale) {
    await loadTranslations(locale);
    localStorage.setItem('cv_language', locale);
    renderWidget(); // Re-render with new translations
  };

  // Initialize
  async function init() {
    currentLocale = detectLanguage();
    await loadTranslations(currentLocale);
    renderWidget();
  }

  init();
})();
```

**Spanish Translation** (es/widget.json):
```json
{
  "feedback": {
    "title": "Comentarios",
    "submit_placeholder": "Comparte tu opinión...",
    "submit_button": "Enviar",
    "vote_button": "Votar",
    "votes": "{{count}} votos",
    "comments": "{{count}} comentarios",
    "status_open": "Abierto",
    "status_planned": "Planificado",
    "status_in_progress": "En progreso",
    "status_done": "Completado",
    "no_feedback": "Aún no hay comentarios. ¡Sé el primero en compartir!",
    "load_more": "Cargar más",
    "loading": "Cargando...",
    "error": "Algo salió mal. Por favor, inténtalo de nuevo.",
    "success": "¡Gracias por tu comentario!",
    "powered_by": "Desarrollado por Collective Vision"
  }
}
```

**Acceptance Criteria**:
- [ ] All widget strings extracted
- [ ] 5 languages translated
- [ ] Language selector working
- [ ] Browser auto-detection

---

### Task 8.1.3: Admin UI Localization (3h)

Translate admin dashboard with date/number formatting.

**Subtasks**:
- [ ] Extract all admin strings
- [ ] Create admin namespace translations
- [ ] Implement user preference storage
- [ ] Format dates and numbers per locale

**Implementation**:
```typescript
// src/i18n/admin.ts
// Admin translation keys (en/admin.json)
const adminTranslations = {
  nav: {
    dashboard: "Dashboard",
    feedback: "Feedback",
    roadmap: "Roadmap",
    analytics: "Analytics",
    settings: "Settings",
    team: "Team",
    billing: "Billing",
    integrations: "Integrations"
  },
  dashboard: {
    title: "Dashboard",
    feedback_count: "Total Feedback",
    votes_count: "Total Votes",
    active_users: "Active Users",
    this_week: "This Week",
    trend_up: "{{percent}}% from last week",
    trend_down: "{{percent}}% from last week",
    recent_feedback: "Recent Feedback",
    top_voted: "Top Voted",
    view_all: "View All"
  },
  feedback_list: {
    title: "All Feedback",
    filter_status: "Status",
    filter_category: "Category",
    filter_date: "Date Range",
    search_placeholder: "Search feedback...",
    sort_by: "Sort by",
    sort_newest: "Newest",
    sort_oldest: "Oldest",
    sort_votes: "Most Voted",
    bulk_actions: "Bulk Actions",
    select_all: "Select All",
    merge_selected: "Merge Selected",
    archive_selected: "Archive Selected",
    empty: "No feedback matching your filters"
  },
  feedback_detail: {
    title: "Feedback Details",
    submitted_by: "Submitted by {{name}}",
    submitted_at: "on {{date}}",
    votes: "{{count}} votes",
    status: "Status",
    change_status: "Change Status",
    category: "Category",
    tags: "Tags",
    add_tag: "Add Tag",
    comments: "Comments",
    internal_notes: "Internal Notes",
    add_to_roadmap: "Add to Roadmap",
    create_integration: "Create in {{name}}",
    merge_with: "Merge with...",
    archive: "Archive",
    delete: "Delete"
  },
  settings: {
    title: "Settings",
    general: "General",
    branding: "Branding",
    notifications: "Notifications",
    api: "API & Webhooks",
    danger_zone: "Danger Zone",
    workspace_name: "Workspace Name",
    workspace_slug: "Workspace URL",
    default_language: "Default Language",
    timezone: "Timezone",
    save_changes: "Save Changes",
    delete_workspace: "Delete Workspace",
    delete_warning: "This action cannot be undone."
  },
  billing: {
    title: "Billing",
    current_plan: "Current Plan",
    upgrade: "Upgrade",
    downgrade: "Downgrade",
    usage: "Usage This Month",
    ai_credits: "AI Credits",
    api_calls: "API Calls",
    storage: "Storage",
    invoices: "Invoices",
    payment_method: "Payment Method",
    billing_email: "Billing Email"
  },
  common: {
    save: "Save",
    cancel: "Cancel",
    delete: "Delete",
    edit: "Edit",
    create: "Create",
    confirm: "Confirm",
    loading: "Loading...",
    error: "Error",
    success: "Success",
    warning: "Warning",
    info: "Info"
  }
};

// React hook for admin translations (if using React)
export function useAdminTranslation() {
  const [locale, setLocale] = useState(() => {
    return localStorage.getItem('admin_language') || 'en';
  });

  const [translations, setTranslations] = useState({});

  useEffect(() => {
    loadTranslations(locale, 'admin').then(setTranslations);
  }, [locale]);

  const t = useCallback((key: string, params?: Record<string, string | number>) => {
    const keys = key.split('.');
    let value = translations;
    for (const k of keys) {
      value = value?.[k];
    }
    if (typeof value !== 'string') return key;

    if (params) {
      return value.replace(/\{\{(\w+)\}\}/g, (_, param) => String(params[param] ?? ''));
    }
    return value;
  }, [translations]);

  const formatDate = useCallback((date: Date | string, format?: 'short' | 'long') => {
    return formatDateLocale(date, locale as Locale, format);
  }, [locale]);

  const formatNumber = useCallback((num: number, options?: Intl.NumberFormatOptions) => {
    return formatNumberLocale(num, locale as Locale, options);
  }, [locale]);

  const changeLanguage = useCallback((newLocale: string) => {
    localStorage.setItem('admin_language', newLocale);
    setLocale(newLocale);
  }, []);

  return { t, formatDate, formatNumber, locale, changeLanguage };
}
```

**Acceptance Criteria**:
- [ ] All admin strings translatable
- [ ] User preference persisted
- [ ] Dates/numbers formatted
- [ ] 5 languages complete

---

### Task 8.1.4: Email Template Localization (1.5h)

Translate all email templates with locale-aware formatting.

**Subtasks**:
- [ ] Extract email template strings
- [ ] Create email namespace translations
- [ ] Implement locale detection for emails
- [ ] Format dates in email recipient's locale

**Email Translations** (en/emails.json):
```json
{
  "feedback_received": {
    "subject": "Thanks for your feedback: {{title}}",
    "greeting": "Hi {{name}},",
    "body": "Thank you for sharing your feedback with us!",
    "your_feedback": "Your feedback",
    "next_steps": "We'll review your feedback and keep you updated on any progress.",
    "view_button": "View Your Feedback",
    "footer": "If you have any questions, reply to this email."
  },
  "status_update": {
    "subject": "Update on your feedback: {{title}}",
    "greeting": "Hi {{name}},",
    "body": "We have an update on your feedback.",
    "new_status": "New Status",
    "view_button": "View Details"
  },
  "mention": {
    "subject": "{{author}} mentioned you in a comment",
    "greeting": "Hi {{name}},",
    "body": "{{author}} mentioned you in a comment on \"{{title}}\"",
    "comment_preview": "Comment",
    "view_button": "View Comment"
  },
  "roadmap_update": {
    "subject": "Roadmap update: {{item}}",
    "greeting": "Hi {{name}},",
    "body": "An item you're following has been updated.",
    "view_button": "View Roadmap"
  },
  "common": {
    "unsubscribe": "Unsubscribe from these emails",
    "powered_by": "Powered by Collective Vision"
  }
}
```

**Implementation**:
```typescript
// src/services/email-i18n.ts
export async function sendLocalizedEmail(
  env: Env,
  options: {
    to: string;
    template: string;
    variables: Record<string, string>;
    recipientLocale?: string;
    workspaceLocale?: string;
  }
): Promise<void> {
  // Determine locale: recipient > workspace > English
  const locale = options.recipientLocale || options.workspaceLocale || 'en';

  // Load email translations
  const translations = await loadTranslations(env, locale as Locale, 'emails');
  const t = createTranslator(translations);

  // Get template keys
  const templateKeys = translations[options.template] || translations.feedback_received;

  // Build email content
  const subject = interpolate(templateKeys.subject, options.variables);
  const html = buildEmailHtml({
    greeting: interpolate(templateKeys.greeting, options.variables),
    body: interpolate(templateKeys.body, options.variables),
    ...options.variables,
    // Localized footer
    unsubscribe: t('common.unsubscribe'),
    powered_by: t('common.powered_by')
  }, locale);

  await sendEmail(env, { to: options.to, subject, html });
}

function interpolate(template: string, variables: Record<string, string>): string {
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) => variables[key] || '');
}

function buildEmailHtml(content: Record<string, string>, locale: string): string {
  // Format any dates in the content
  // Return localized HTML
  return `<!DOCTYPE html>...`;
}
```

**Acceptance Criteria**:
- [ ] All email templates translated
- [ ] Recipient locale detected
- [ ] Fallback chain working
- [ ] Date formatting correct

---

### Task 8.1.5: Auto-Translation of Feedback (1.5h)

Optional AI-powered translation of user feedback.

**Subtasks**:
- [ ] Detect original language
- [ ] Translate via LLM
- [ ] Store original and translations
- [ ] Toggle between versions in UI

**Schema**:
```sql
ALTER TABLE feedback_items ADD COLUMN original_language TEXT;
ALTER TABLE feedback_items ADD COLUMN translations TEXT; -- JSON: { "es": { "title": "...", "description": "..." } }
```

**Implementation**:
```typescript
// src/services/ai/translation.ts
interface TranslationResult {
  detected_language: string;
  translations: Record<string, { title: string; description: string }>;
}

export async function translateFeedback(
  env: Env,
  feedbackId: string,
  targetLanguages: string[] = ['en', 'es', 'fr', 'de']
): Promise<TranslationResult> {
  const feedback = await env.DB.prepare(`
    SELECT title, description, original_language, translations
    FROM feedback_items WHERE id = ?
  `).bind(feedbackId).first();

  if (!feedback) throw new Error('Feedback not found');

  // Skip if already translated
  const existing = feedback.translations ? JSON.parse(feedback.translations) : {};
  const needed = targetLanguages.filter(lang => !existing[lang]);

  if (needed.length === 0) {
    return {
      detected_language: feedback.original_language || 'en',
      translations: existing
    };
  }

  // Detect original language if not set
  let detectedLanguage = feedback.original_language;
  if (!detectedLanguage) {
    detectedLanguage = await detectLanguage(env, feedback.title + ' ' + (feedback.description || ''));
  }

  // Translate to needed languages
  const newTranslations = await translateText(env, {
    text: {
      title: feedback.title,
      description: feedback.description || ''
    },
    sourceLanguage: detectedLanguage,
    targetLanguages: needed
  });

  // Merge with existing
  const allTranslations = { ...existing, ...newTranslations };

  // Store
  await env.DB.prepare(`
    UPDATE feedback_items
    SET original_language = ?, translations = ?, updated_at = datetime('now')
    WHERE id = ?
  `).bind(detectedLanguage, JSON.stringify(allTranslations), feedbackId).run();

  return {
    detected_language: detectedLanguage,
    translations: allTranslations
  };
}

async function detectLanguage(env: Env, text: string): Promise<string> {
  const response = await callLLM(env, {
    model: 'claude-3-haiku-20240307',
    messages: [{
      role: 'user',
      content: `Detect the language of this text and respond with ONLY the ISO 639-1 code (e.g., "en", "es", "fr"):\n\n${text.slice(0, 500)}`
    }],
    max_tokens: 10
  });

  const code = response.content.trim().toLowerCase().slice(0, 2);
  return ['en', 'es', 'fr', 'de', 'ja', 'zh', 'pt', 'it', 'ru', 'ko'].includes(code) ? code : 'en';
}

async function translateText(
  env: Env,
  options: {
    text: { title: string; description: string };
    sourceLanguage: string;
    targetLanguages: string[];
  }
): Promise<Record<string, { title: string; description: string }>> {
  const translations: Record<string, { title: string; description: string }> = {};

  for (const targetLang of options.targetLanguages) {
    if (targetLang === options.sourceLanguage) {
      translations[targetLang] = options.text;
      continue;
    }

    const response = await callLLM(env, {
      model: 'claude-3-haiku-20240307',
      messages: [{
        role: 'user',
        content: `Translate from ${options.sourceLanguage} to ${targetLang}. Return JSON only.

Title: ${options.text.title}
Description: ${options.text.description}

Format: {"title": "...", "description": "..."}`
      }],
      max_tokens: 500
    });

    try {
      const parsed = JSON.parse(response.content.match(/\{[\s\S]*\}/)?.[0] || '{}');
      translations[targetLang] = {
        title: parsed.title || options.text.title,
        description: parsed.description || options.text.description
      };
    } catch {
      translations[targetLang] = options.text; // Fallback to original
    }
  }

  return translations;
}

// API endpoint
// GET /api/v1/feedback/:id?lang=es
export async function getFeedbackWithTranslation(
  env: Env,
  feedbackId: string,
  requestedLang: string
): Promise<{ feedback: any; language: string; is_translated: boolean }> {
  const feedback = await env.DB.prepare(`
    SELECT * FROM feedback_items WHERE id = ?
  `).bind(feedbackId).first();

  if (!feedback) throw new Error('Not found');

  const originalLang = feedback.original_language || 'en';
  const translations = feedback.translations ? JSON.parse(feedback.translations) : {};

  // If requested language matches original or not translated, return original
  if (requestedLang === originalLang || !translations[requestedLang]) {
    return {
      feedback,
      language: originalLang,
      is_translated: false
    };
  }

  // Return translated version
  return {
    feedback: {
      ...feedback,
      title: translations[requestedLang].title,
      description: translations[requestedLang].description,
      _original_title: feedback.title,
      _original_description: feedback.description
    },
    language: requestedLang,
    is_translated: true
  };
}
```

**Acceptance Criteria**:
- [ ] Language auto-detected
- [ ] Translations stored
- [ ] Original preserved
- [ ] Toggle in UI

---

## Definition of Done
- [ ] 6 languages supported
- [ ] Widget fully translated
- [ ] Admin fully translated
- [ ] Emails localized
- [ ] Auto-translation working
- [ ] Date/number formatting correct

## Technical Notes
- Translations stored in KV for fast access
- LLM used for auto-translation (Claude Haiku)
- RTL support deferred to future epic
- Pluralization handled per-language

## Related Files
- `src/i18n/index.ts` - Core i18n framework
- `src/locales/` - Translation files
- `src/services/ai/translation.ts` - Auto-translation
- Widget JS updated for i18n
