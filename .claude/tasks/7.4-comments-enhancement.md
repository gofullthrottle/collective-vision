# Epic 7.4: Comments Enhancement

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Enhance comment system with threading, internal comments, mentions, and rich text support.

## Wave Context
**Wave 7**: Advanced Features (Roadmaps, PM Integrations, Comments)
**Dependencies**: Wave 1 (Core feedback with basic comments)
**Unlocks**: Team collaboration, user engagement, organized discussions

## Quality Requirements
- Threaded replies with collapsible UI
- Real-time mention autocomplete
- Secure markdown rendering
- Clear internal/public distinction

---

## Tasks

### Task 7.4.1: Threaded Comments (1.5h)

Add parent-child relationships for nested comment threads.

**Subtasks**:
- [ ] Add parent_id column to comments
- [ ] Implement nested retrieval
- [ ] Build threaded display
- [ ] Add collapse/expand functionality

**Schema**:
```sql
-- Add parent relationship
ALTER TABLE feedback_comments ADD COLUMN parent_id TEXT
  REFERENCES feedback_comments(id) ON DELETE CASCADE;

ALTER TABLE feedback_comments ADD COLUMN depth INTEGER DEFAULT 0;
ALTER TABLE feedback_comments ADD COLUMN reply_count INTEGER DEFAULT 0;

CREATE INDEX idx_comments_parent ON feedback_comments(parent_id);
CREATE INDEX idx_comments_thread ON feedback_comments(feedback_id, parent_id, created_at);
```

**Implementation**:
```typescript
// src/services/comments.ts
interface Comment {
  id: string;
  feedback_id: string;
  user_id: string;
  content: string;
  is_internal: boolean;
  parent_id: string | null;
  depth: number;
  reply_count: number;
  created_at: string;
  updated_at: string;
  author?: {
    id: string;
    name: string;
    avatar_url: string | null;
    is_team_member: boolean;
  };
  replies?: Comment[];
}

interface CreateCommentInput {
  feedback_id: string;
  user_id: string;
  content: string;
  is_internal?: boolean;
  parent_id?: string;
}

export async function createComment(
  env: Env,
  input: CreateCommentInput
): Promise<Comment> {
  const id = crypto.randomUUID();
  let depth = 0;

  // If replying, get parent depth and update reply count
  if (input.parent_id) {
    const parent = await env.DB.prepare(`
      SELECT depth FROM feedback_comments WHERE id = ?
    `).bind(input.parent_id).first<{ depth: number }>();

    if (!parent) {
      throw new Error('Parent comment not found');
    }

    depth = parent.depth + 1;

    // Limit nesting depth
    if (depth > 3) {
      throw new Error('Maximum reply depth reached');
    }

    // Update parent reply count
    await env.DB.prepare(`
      UPDATE feedback_comments SET reply_count = reply_count + 1
      WHERE id = ?
    `).bind(input.parent_id).run();
  }

  await env.DB.prepare(`
    INSERT INTO feedback_comments (
      id, feedback_id, user_id, content, is_internal, parent_id, depth
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
  `).bind(
    id, input.feedback_id, input.user_id, input.content,
    input.is_internal ? 1 : 0, input.parent_id || null, depth
  ).run();

  // Update feedback comment count
  await env.DB.prepare(`
    UPDATE feedback_items SET comment_count = comment_count + 1
    WHERE id = ?
  `).bind(input.feedback_id).run();

  return {
    id,
    feedback_id: input.feedback_id,
    user_id: input.user_id,
    content: input.content,
    is_internal: input.is_internal || false,
    parent_id: input.parent_id || null,
    depth,
    reply_count: 0,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
}

export async function getCommentsWithReplies(
  env: Env,
  feedbackId: string,
  options: {
    include_internal?: boolean;
    user_id?: string;
    collapse_after?: number; // Collapse replies after N
  }
): Promise<Comment[]> {
  // Get user's team status for internal visibility
  let canSeeInternal = false;
  if (options.user_id) {
    const teamMember = await env.DB.prepare(`
      SELECT 1 FROM team_members tm
      JOIN feedback_items f ON f.workspace_id = tm.workspace_id
      WHERE f.id = ? AND tm.user_id = ?
    `).bind(feedbackId, options.user_id).first();
    canSeeInternal = !!teamMember;
  }

  // Get all comments (flat)
  let query = `
    SELECT c.*,
           u.name as author_name,
           u.avatar_url as author_avatar,
           tm.id IS NOT NULL as is_team_member
    FROM feedback_comments c
    JOIN end_users u ON u.id = c.user_id
    LEFT JOIN team_members tm ON tm.user_id = c.user_id
    WHERE c.feedback_id = ?
  `;

  if (!canSeeInternal) {
    query += ' AND c.is_internal = 0';
  }

  query += ' ORDER BY c.created_at ASC';

  const comments = await env.DB.prepare(query).bind(feedbackId).all();

  // Build tree structure
  const commentMap = new Map<string, Comment>();
  const rootComments: Comment[] = [];

  // First pass: create map
  for (const c of comments.results) {
    const comment: Comment = {
      id: c.id,
      feedback_id: c.feedback_id,
      user_id: c.user_id,
      content: c.content,
      is_internal: !!c.is_internal,
      parent_id: c.parent_id,
      depth: c.depth,
      reply_count: c.reply_count,
      created_at: c.created_at,
      updated_at: c.updated_at,
      author: {
        id: c.user_id,
        name: c.author_name,
        avatar_url: c.author_avatar,
        is_team_member: !!c.is_team_member
      },
      replies: []
    };
    commentMap.set(c.id, comment);
  }

  // Second pass: build tree
  for (const comment of commentMap.values()) {
    if (comment.parent_id) {
      const parent = commentMap.get(comment.parent_id);
      if (parent) {
        parent.replies = parent.replies || [];
        parent.replies.push(comment);
      }
    } else {
      rootComments.push(comment);
    }
  }

  // Apply collapse if needed
  if (options.collapse_after) {
    for (const comment of commentMap.values()) {
      if (comment.replies && comment.replies.length > options.collapse_after) {
        // Mark as collapsed, keep first N visible
        (comment as any)._collapsed = true;
        (comment as any)._hidden_count = comment.replies.length - options.collapse_after;
      }
    }
  }

  return rootComments;
}

// Delete comment (soft delete or cascade)
export async function deleteComment(
  env: Env,
  commentId: string,
  userId: string
): Promise<{ deleted: boolean }> {
  const comment = await env.DB.prepare(`
    SELECT c.*, f.workspace_id
    FROM feedback_comments c
    JOIN feedback_items f ON f.id = c.feedback_id
    WHERE c.id = ?
  `).bind(commentId).first();

  if (!comment) {
    throw new Error('Comment not found');
  }

  // Check ownership or team membership
  const canDelete = comment.user_id === userId || await isTeamMember(env, comment.workspace_id, userId);

  if (!canDelete) {
    throw new Error('Not authorized to delete this comment');
  }

  // If has replies, soft delete (replace content)
  if (comment.reply_count > 0) {
    await env.DB.prepare(`
      UPDATE feedback_comments
      SET content = '[deleted]', updated_at = datetime('now')
      WHERE id = ?
    `).bind(commentId).run();
  } else {
    // Hard delete
    await env.DB.prepare(`DELETE FROM feedback_comments WHERE id = ?`)
      .bind(commentId).run();

    // Update parent reply count if applicable
    if (comment.parent_id) {
      await env.DB.prepare(`
        UPDATE feedback_comments SET reply_count = reply_count - 1
        WHERE id = ?
      `).bind(comment.parent_id).run();
    }

    // Update feedback comment count
    await env.DB.prepare(`
      UPDATE feedback_items SET comment_count = comment_count - 1
      WHERE id = ?
    `).bind(comment.feedback_id).run();
  }

  return { deleted: true };
}
```

**API Routes**:
```typescript
// POST /api/v1/feedback/:id/comments
// GET /api/v1/feedback/:id/comments?collapse_after=3
// DELETE /api/v1/comments/:id
// POST /api/v1/comments/:id/reply
```

**Acceptance Criteria**:
- [ ] Replies linked to parent
- [ ] Depth limited to 3 levels
- [ ] Tree structure retrieved efficiently
- [ ] Delete handles replies

---

### Task 7.4.2: Internal Team Comments (0.5h)

Distinguish internal team discussions from public comments.

**Subtasks**:
- [ ] Filter internal comments for non-team members
- [ ] Visual distinction in UI
- [ ] Quick toggle for team members
- [ ] Admin filter in dashboard

**Implementation**:
```typescript
// Internal comment handling is built into the main comments service
// This task focuses on the UI/API layer

// POST /api/v1/feedback/:id/comments (with is_internal flag)
export async function createCommentHandler(
  request: Request,
  env: Env,
  feedbackId: string
): Promise<Response> {
  const body = await request.json();
  const userId = await getUserId(request, env);

  // Verify user can create internal comments
  if (body.is_internal) {
    const feedback = await env.DB.prepare(`
      SELECT workspace_id FROM feedback_items WHERE id = ?
    `).bind(feedbackId).first<{ workspace_id: string }>();

    const isTeam = await isTeamMember(env, feedback!.workspace_id, userId);
    if (!isTeam) {
      return jsonResponse({ error: 'Only team members can create internal comments' }, 403);
    }
  }

  const comment = await createComment(env, {
    feedback_id: feedbackId,
    user_id: userId,
    content: body.content,
    is_internal: body.is_internal || false,
    parent_id: body.parent_id
  });

  return jsonResponse(comment, 201);
}

// Widget CSS for internal comments
const INTERNAL_COMMENT_STYLES = `
.cv-comment.internal {
  background: #fef3c7; /* Amber-100 */
  border-left: 3px solid #f59e0b; /* Amber-500 */
}

.cv-comment.internal::before {
  content: 'Internal';
  position: absolute;
  top: 5px;
  right: 5px;
  font-size: 10px;
  color: #92400e;
  background: #fde68a;
  padding: 2px 6px;
  border-radius: 4px;
}
`;
```

**Acceptance Criteria**:
- [ ] Internal flag enforced for team only
- [ ] Hidden from public users
- [ ] Clear visual distinction
- [ ] Filterable in admin

---

### Task 7.4.3: @Mentions & Notifications (1.5h)

Implement @mentions with autocomplete and notifications.

**Subtasks**:
- [ ] Parse @username in content
- [ ] Build autocomplete endpoint
- [ ] Send mention notifications
- [ ] Link to user in rendered content

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS comment_mentions (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  comment_id TEXT NOT NULL REFERENCES feedback_comments(id) ON DELETE CASCADE,
  mentioned_user_id TEXT NOT NULL REFERENCES end_users(id) ON DELETE CASCADE,
  notified_at TEXT,
  read_at TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  UNIQUE(comment_id, mentioned_user_id)
);

CREATE INDEX idx_mentions_user ON comment_mentions(mentioned_user_id, read_at);
```

**Implementation**:
```typescript
// src/services/mentions.ts
interface Mention {
  username: string;
  user_id: string;
  start_index: number;
  end_index: number;
}

// Parse @mentions from content
export function parseMentions(content: string): Array<{ username: string; start: number; end: number }> {
  const mentions: Array<{ username: string; start: number; end: number }> = [];
  const regex = /@(\w+)/g;
  let match;

  while ((match = regex.exec(content)) !== null) {
    mentions.push({
      username: match[1],
      start: match.index,
      end: match.index + match[0].length
    });
  }

  return mentions;
}

// Resolve usernames to user IDs
export async function resolveMentions(
  env: Env,
  workspaceId: string,
  mentions: Array<{ username: string }>
): Promise<Map<string, string>> {
  const resolved = new Map<string, string>();

  for (const mention of mentions) {
    // Check team members first
    const teamMember = await env.DB.prepare(`
      SELECT u.id FROM end_users u
      JOIN team_members tm ON tm.user_id = u.id
      WHERE tm.workspace_id = ? AND u.name LIKE ?
      LIMIT 1
    `).bind(workspaceId, `%${mention.username}%`).first<{ id: string }>();

    if (teamMember) {
      resolved.set(mention.username, teamMember.id);
    }
  }

  return resolved;
}

// Process mentions after comment creation
export async function processMentions(
  env: Env,
  commentId: string,
  workspaceId: string,
  content: string
): Promise<void> {
  const mentions = parseMentions(content);
  if (!mentions.length) return;

  const resolved = await resolveMentions(env, workspaceId, mentions);

  for (const [username, userId] of resolved) {
    await env.DB.prepare(`
      INSERT INTO comment_mentions (id, comment_id, mentioned_user_id)
      VALUES (?, ?, ?)
      ON CONFLICT(comment_id, mentioned_user_id) DO NOTHING
    `).bind(crypto.randomUUID(), commentId, userId).run();

    // Queue notification
    await env.QUEUES.send({
      type: 'mention_notification',
      comment_id: commentId,
      mentioned_user_id: userId
    });
  }
}

// Autocomplete endpoint
// GET /api/v1/workspaces/:id/users/autocomplete?q=joh
export async function autocompleteUsers(
  env: Env,
  workspaceId: string,
  query: string,
  limit = 5
): Promise<Array<{ id: string; name: string; avatar_url: string | null }>> {
  // Search team members and active commenters
  const results = await env.DB.prepare(`
    SELECT DISTINCT u.id, u.name, u.avatar_url
    FROM end_users u
    LEFT JOIN team_members tm ON tm.user_id = u.id AND tm.workspace_id = ?
    LEFT JOIN feedback_comments c ON c.user_id = u.id
    LEFT JOIN feedback_items f ON f.id = c.feedback_id AND f.workspace_id = ?
    WHERE u.name LIKE ? AND (tm.id IS NOT NULL OR f.id IS NOT NULL)
    ORDER BY tm.id IS NOT NULL DESC, u.name
    LIMIT ?
  `).bind(workspaceId, workspaceId, `%${query}%`, limit).all();

  return results.results;
}

// Get unread mentions for user
export async function getUnreadMentions(
  env: Env,
  userId: string
): Promise<Array<{ comment_id: string; feedback_id: string; content_preview: string; created_at: string }>> {
  const results = await env.DB.prepare(`
    SELECT m.*, c.feedback_id, SUBSTR(c.content, 1, 100) as content_preview
    FROM comment_mentions m
    JOIN feedback_comments c ON c.id = m.comment_id
    WHERE m.mentioned_user_id = ? AND m.read_at IS NULL
    ORDER BY m.created_at DESC
    LIMIT 20
  `).bind(userId).all();

  return results.results;
}

// Mark mention as read
export async function markMentionRead(
  env: Env,
  commentId: string,
  userId: string
): Promise<void> {
  await env.DB.prepare(`
    UPDATE comment_mentions SET read_at = datetime('now')
    WHERE comment_id = ? AND mentioned_user_id = ?
  `).bind(commentId, userId).run();
}

// Render mentions as links in content
export function renderMentions(content: string, mentions: Map<string, string>): string {
  let result = content;

  for (const [username, userId] of mentions) {
    result = result.replace(
      new RegExp(`@${username}\\b`, 'g'),
      `<a href="/users/${userId}" class="cv-mention">@${username}</a>`
    );
  }

  return result;
}
```

**Notification Queue Handler**:
```typescript
// src/workers/mention-notifications.ts
export async function handleMentionNotification(
  env: Env,
  data: { comment_id: string; mentioned_user_id: string }
): Promise<void> {
  const comment = await env.DB.prepare(`
    SELECT c.*, f.title as feedback_title, u.name as author_name
    FROM feedback_comments c
    JOIN feedback_items f ON f.id = c.feedback_id
    JOIN end_users u ON u.id = c.user_id
    WHERE c.id = ?
  `).bind(data.comment_id).first();

  const mentionedUser = await env.DB.prepare(`
    SELECT * FROM end_users WHERE id = ?
  `).bind(data.mentioned_user_id).first();

  if (!comment || !mentionedUser?.email) return;

  // Send email notification
  await sendEmail(env, {
    to: mentionedUser.email,
    subject: `${comment.author_name} mentioned you in "${comment.feedback_title}"`,
    html: `
      <p><strong>${comment.author_name}</strong> mentioned you in a comment:</p>
      <blockquote>${comment.content}</blockquote>
      <p><a href="${env.APP_URL}/feedback/${comment.feedback_id}#comment-${comment.id}">View comment</a></p>
    `
  });

  // Mark as notified
  await env.DB.prepare(`
    UPDATE comment_mentions SET notified_at = datetime('now')
    WHERE comment_id = ? AND mentioned_user_id = ?
  `).bind(data.comment_id, data.mentioned_user_id).run();
}
```

**Acceptance Criteria**:
- [ ] @mentions parsed from content
- [ ] Autocomplete with 5 suggestions
- [ ] Email notification sent
- [ ] Rendered as clickable links

---

### Task 7.4.4: Rich Text Editing (0.5h)

Support markdown in comments with preview and formatting toolbar.

**Subtasks**:
- [ ] Markdown parsing on display
- [ ] Preview mode toggle
- [ ] Basic formatting toolbar
- [ ] Secure HTML output

**Implementation**:
```typescript
// src/services/markdown.ts
// Using a lightweight markdown parser suitable for Workers

// Sanitize and render markdown
export function renderMarkdown(content: string): string {
  // Simple markdown rules (can use marked.js or similar)
  let html = escapeHtml(content);

  // Bold: **text** or __text__
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

  // Italic: *text* or _text_
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  html = html.replace(/_(.+?)_/g, '<em>$1</em>');

  // Code: `code`
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

  // Code blocks: ```code```
  html = html.replace(/```([\s\S]+?)```/g, '<pre><code>$1</code></pre>');

  // Links: [text](url) - only allow safe protocols
  html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, '<a href="$2" rel="noopener noreferrer" target="_blank">$1</a>');

  // Lists: - item or * item
  html = html.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

  // Line breaks
  html = html.replace(/\n/g, '<br>');

  return html;
}

function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

// Preview endpoint
// POST /api/v1/markdown/preview
export async function handleMarkdownPreview(
  request: Request
): Promise<Response> {
  const { content } = await request.json();

  if (!content || typeof content !== 'string') {
    return new Response(JSON.stringify({ error: 'Content required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const html = renderMarkdown(content);

  return new Response(JSON.stringify({ html }), {
    headers: { 'Content-Type': 'application/json' }
  });
}

// Widget formatting toolbar HTML
const TOOLBAR_HTML = `
<div class="cv-comment-toolbar">
  <button type="button" data-format="bold" title="Bold (Ctrl+B)">
    <svg viewBox="0 0 24 24" width="16" height="16"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </button>
  <button type="button" data-format="italic" title="Italic (Ctrl+I)">
    <svg viewBox="0 0 24 24" width="16" height="16"><path d="M10 4h4m-2 16h4m-7-16l4 16" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </button>
  <button type="button" data-format="code" title="Code">
    <svg viewBox="0 0 24 24" width="16" height="16"><path d="M16 18l6-6-6-6M8 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </button>
  <button type="button" data-format="link" title="Link">
    <svg viewBox="0 0 24 24" width="16" height="16"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </button>
  <span class="cv-toolbar-spacer"></span>
  <button type="button" data-action="preview" title="Preview">
    <svg viewBox="0 0 24 24" width="16" height="16"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z M12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
  </button>
</div>
`;

// Widget JavaScript for toolbar
const TOOLBAR_JS = `
function initToolbar(toolbar, textarea) {
  toolbar.querySelectorAll('[data-format]').forEach(btn => {
    btn.addEventListener('click', () => {
      const format = btn.dataset.format;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value.substring(start, end);

      const formats = {
        bold: ['**', '**'],
        italic: ['*', '*'],
        code: ['\`', '\`'],
        link: ['[', '](url)']
      };

      const [prefix, suffix] = formats[format];
      textarea.value = textarea.value.substring(0, start) + prefix + text + suffix + textarea.value.substring(end);
      textarea.focus();
      textarea.setSelectionRange(start + prefix.length, end + prefix.length);
    });
  });

  toolbar.querySelector('[data-action="preview"]').addEventListener('click', async () => {
    const preview = toolbar.parentElement.querySelector('.cv-preview');
    if (preview.style.display === 'none') {
      const res = await fetch(apiBase + '/api/v1/markdown/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: textarea.value })
      });
      const { html } = await res.json();
      preview.innerHTML = html;
      preview.style.display = 'block';
      textarea.style.display = 'none';
    } else {
      preview.style.display = 'none';
      textarea.style.display = 'block';
    }
  });
}
`;
```

**CSS for rendered markdown**:
```css
.cv-comment-content code {
  background: #f3f4f6;
  padding: 2px 4px;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.9em;
}

.cv-comment-content pre {
  background: #1f2937;
  color: #f9fafb;
  padding: 12px;
  border-radius: 6px;
  overflow-x: auto;
}

.cv-comment-content pre code {
  background: none;
  padding: 0;
  color: inherit;
}

.cv-comment-content a {
  color: var(--cv-primary);
  text-decoration: none;
}

.cv-comment-content a:hover {
  text-decoration: underline;
}

.cv-comment-content ul {
  margin-left: 20px;
}

.cv-comment-toolbar {
  display: flex;
  gap: 4px;
  padding: 4px;
  border-bottom: 1px solid #e5e7eb;
  background: #f9fafb;
}

.cv-comment-toolbar button {
  padding: 4px 8px;
  border: none;
  background: none;
  cursor: pointer;
  border-radius: 4px;
}

.cv-comment-toolbar button:hover {
  background: #e5e7eb;
}

.cv-toolbar-spacer {
  flex: 1;
}
```

**Acceptance Criteria**:
- [ ] Markdown renders safely
- [ ] Preview toggle works
- [ ] Toolbar inserts formatting
- [ ] Code blocks highlighted

---

## Definition of Done
- [ ] Threaded replies working
- [ ] Internal comments team-only
- [ ] @mentions with notifications
- [ ] Rich text editing
- [ ] All comment features tested

## Technical Notes
- Markdown sanitized to prevent XSS
- Mention resolution workspace-scoped
- Thread depth limited to prevent deep nesting
- Lazy load replies for performance

## Related Files
- `src/services/comments.ts` - Core comment logic
- `src/services/mentions.ts` - Mention parsing and notifications
- `src/services/markdown.ts` - Markdown rendering
- `src/routes/comments.ts` - API endpoints
