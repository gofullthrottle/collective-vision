# Epic 7.3: AI Roadmap Features

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Build AI-powered roadmap assistance including draft generation, priority recommendations, and status update writing.

## Wave Context
**Wave 7**: Advanced Features (Roadmaps, PM Integrations, AI Features)
**Dependencies**: Wave 2 (AI Classification), Wave 7.1 (Roadmaps)
**Unlocks**: Automated roadmap drafting, intelligent prioritization, changelog generation

## Quality Requirements
- LLM responses structured for easy review
- Human-in-the-loop for all publishing actions
- Reasoning transparent and auditable
- Graceful fallback when AI unavailable

---

## Tasks

### Task 7.3.1: AI-Powered Roadmap Drafting (3h)

Generate roadmap drafts from top feedback and themes.

**Subtasks**:
- [ ] Aggregate top feedback by theme
- [ ] Generate roadmap structure via LLM
- [ ] Suggest phase assignments
- [ ] Create draft for human review

**Implementation**:
```typescript
// src/services/ai/roadmap-drafting.ts
import { callLLM } from '../llm';

interface ThemeSummary {
  id: string;
  name: string;
  feedback_count: number;
  total_votes: number;
  avg_urgency: number;
  avg_sentiment: number;
  sample_titles: string[];
}

interface RoadmapDraft {
  id: string;
  workspace_id: string;
  status: 'generating' | 'ready' | 'applied' | 'discarded';
  phases: Array<{
    name: string;
    description: string;
    items: Array<{
      title: string;
      description: string;
      source_theme_id?: string;
      source_feedback_ids: string[];
      priority: number;
      estimated_effort?: 'small' | 'medium' | 'large';
    }>;
  }>;
  reasoning: string;
  generated_at: string;
  applied_at?: string;
}

interface DraftInput {
  workspace_id: string;
  feedback_limit?: number; // How many top items to consider
  time_horizon?: 'quarter' | 'half' | 'year';
  phase_count?: number;
  focus_areas?: string[]; // Optional filter by category
}

export async function generateRoadmapDraft(
  env: Env,
  input: DraftInput
): Promise<RoadmapDraft> {
  const draftId = crypto.randomUUID();

  // Record draft as generating
  await env.DB.prepare(`
    INSERT INTO roadmap_drafts (id, workspace_id, status, generated_at)
    VALUES (?, ?, 'generating', datetime('now'))
  `).bind(draftId, input.workspace_id).run();

  try {
    // Get top feedback themes
    const themes = await getTopThemes(env, input.workspace_id, input.feedback_limit || 50);

    // Get recent feedback stats
    const stats = await getFeedbackStats(env, input.workspace_id);

    // Build LLM prompt
    const prompt = buildRoadmapPrompt(themes, stats, input);

    // Call LLM
    const response = await callLLM(env, {
      model: 'claude-3-haiku-20240307',
      messages: [
        {
          role: 'system',
          content: `You are a product manager assistant. Generate structured roadmap suggestions based on user feedback data. Output JSON only.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 4000
    });

    // Parse structured output
    const parsed = parseRoadmapResponse(response.content);

    // Store draft
    await env.DB.prepare(`
      UPDATE roadmap_drafts
      SET status = 'ready', phases = ?, reasoning = ?
      WHERE id = ?
    `).bind(JSON.stringify(parsed.phases), parsed.reasoning, draftId).run();

    return {
      id: draftId,
      workspace_id: input.workspace_id,
      status: 'ready',
      phases: parsed.phases,
      reasoning: parsed.reasoning,
      generated_at: new Date().toISOString()
    };
  } catch (error) {
    await env.DB.prepare(`
      UPDATE roadmap_drafts SET status = 'error', reasoning = ?
      WHERE id = ?
    `).bind(String(error), draftId).run();

    throw error;
  }
}

async function getTopThemes(
  env: Env,
  workspaceId: string,
  limit: number
): Promise<ThemeSummary[]> {
  const themes = await env.DB.prepare(`
    SELECT
      t.id,
      t.name,
      COUNT(ftm.feedback_id) as feedback_count,
      SUM(f.vote_count) as total_votes,
      AVG(f.urgency_score) as avg_urgency,
      AVG(f.sentiment_score) as avg_sentiment
    FROM themes t
    JOIN feedback_theme_memberships ftm ON ftm.theme_id = t.id
    JOIN feedback_items f ON f.id = ftm.feedback_id
    WHERE t.workspace_id = ?
    GROUP BY t.id
    ORDER BY total_votes DESC, feedback_count DESC
    LIMIT ?
  `).bind(workspaceId, limit).all<ThemeSummary>();

  // Get sample titles for each theme
  for (const theme of themes.results) {
    const samples = await env.DB.prepare(`
      SELECT f.title FROM feedback_items f
      JOIN feedback_theme_memberships ftm ON ftm.feedback_id = f.id
      WHERE ftm.theme_id = ?
      ORDER BY f.vote_count DESC
      LIMIT 3
    `).bind(theme.id).all<{ title: string }>();

    theme.sample_titles = samples.results.map(s => s.title);
  }

  return themes.results;
}

async function getFeedbackStats(
  env: Env,
  workspaceId: string
): Promise<{
  total_feedback: number;
  total_votes: number;
  top_categories: Array<{ category: string; count: number }>;
  avg_urgency: number;
  open_count: number;
}> {
  const stats = await env.DB.prepare(`
    SELECT
      COUNT(*) as total_feedback,
      SUM(vote_count) as total_votes,
      AVG(urgency_score) as avg_urgency,
      SUM(CASE WHEN status = 'open' THEN 1 ELSE 0 END) as open_count
    FROM feedback_items
    WHERE workspace_id = ?
  `).bind(workspaceId).first();

  const categories = await env.DB.prepare(`
    SELECT category, COUNT(*) as count
    FROM feedback_items
    WHERE workspace_id = ?
    GROUP BY category
    ORDER BY count DESC
    LIMIT 5
  `).bind(workspaceId).all<{ category: string; count: number }>();

  return {
    total_feedback: stats?.total_feedback || 0,
    total_votes: stats?.total_votes || 0,
    top_categories: categories.results,
    avg_urgency: stats?.avg_urgency || 0.5,
    open_count: stats?.open_count || 0
  };
}

function buildRoadmapPrompt(
  themes: ThemeSummary[],
  stats: { total_feedback: number; total_votes: number; top_categories: Array<{ category: string; count: number }> },
  input: DraftInput
): string {
  return `
Based on user feedback analysis, create a product roadmap draft.

## Feedback Overview
- Total feedback items: ${stats.total_feedback}
- Total votes: ${stats.total_votes}
- Top categories: ${stats.top_categories.map(c => `${c.category} (${c.count})`).join(', ')}

## Top Themes by Priority
${themes.map((t, i) => `
${i + 1}. **${t.name}**
   - Feedback items: ${t.feedback_count}
   - Total votes: ${t.total_votes}
   - Urgency: ${(t.avg_urgency * 100).toFixed(0)}%
   - Sample requests: ${t.sample_titles.join('; ')}
`).join('\n')}

## Requirements
- Time horizon: ${input.time_horizon || 'quarter'}
- Number of phases: ${input.phase_count || 4} (e.g., Now, Next, Later, Future)
${input.focus_areas?.length ? `- Focus areas: ${input.focus_areas.join(', ')}` : ''}

## Output Format
Return JSON with this structure:
{
  "phases": [
    {
      "name": "Now",
      "description": "Immediate priorities for this quarter",
      "items": [
        {
          "title": "Clear title for roadmap item",
          "description": "Brief description of what will be delivered",
          "source_theme_id": "theme_id_if_applicable",
          "priority": 1,
          "estimated_effort": "small|medium|large"
        }
      ]
    }
  ],
  "reasoning": "Explanation of prioritization decisions"
}

Prioritize by:
1. Urgency score (higher = more urgent)
2. Vote count (more votes = higher demand)
3. Theme cohesion (group related items)
4. Balance quick wins with strategic initiatives
`;
}

function parseRoadmapResponse(content: string): {
  phases: RoadmapDraft['phases'];
  reasoning: string;
} {
  // Extract JSON from response
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Failed to parse roadmap response');
  }

  const parsed = JSON.parse(jsonMatch[0]);

  return {
    phases: parsed.phases || [],
    reasoning: parsed.reasoning || ''
  };
}

// Apply draft to actual roadmap
export async function applyRoadmapDraft(
  env: Env,
  draftId: string,
  roadmapId: string
): Promise<void> {
  const draft = await env.DB.prepare(`
    SELECT * FROM roadmap_drafts WHERE id = ? AND status = 'ready'
  `).bind(draftId).first<RoadmapDraft>();

  if (!draft) {
    throw new Error('Draft not found or not ready');
  }

  const phases = JSON.parse(draft.phases as unknown as string);

  // Create phases and items
  for (let i = 0; i < phases.length; i++) {
    const phase = phases[i];
    const phaseId = crypto.randomUUID();

    await env.DB.prepare(`
      INSERT INTO roadmap_phases (id, roadmap_id, name, description, sort_order)
      VALUES (?, ?, ?, ?, ?)
    `).bind(phaseId, roadmapId, phase.name, phase.description, i).run();

    for (let j = 0; j < phase.items.length; j++) {
      const item = phase.items[j];
      await env.DB.prepare(`
        INSERT INTO roadmap_items (
          id, roadmap_id, phase_id, title, description, priority, sort_order
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `).bind(
        crypto.randomUUID(), roadmapId, phaseId,
        item.title, item.description, item.priority, j
      ).run();
    }
  }

  // Mark draft as applied
  await env.DB.prepare(`
    UPDATE roadmap_drafts SET status = 'applied', applied_at = datetime('now')
    WHERE id = ?
  `).bind(draftId).run();
}
```

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS roadmap_drafts (
  id TEXT PRIMARY KEY,
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'generating', -- 'generating', 'ready', 'applied', 'discarded', 'error'
  phases TEXT, -- JSON
  reasoning TEXT,
  input_params TEXT, -- JSON of generation parameters
  generated_at TEXT,
  applied_at TEXT,
  applied_to_roadmap_id TEXT REFERENCES roadmaps(id)
);
```

**Acceptance Criteria**:
- [ ] Draft generated from feedback themes
- [ ] Phases and items structured
- [ ] Reasoning transparent
- [ ] Draft reviewable before applying

---

### Task 7.3.2: Priority Recommendations (2h)

Generate intelligent priority recommendations with reasoning.

**Subtasks**:
- [ ] Analyze feedback corpus
- [ ] Consider multiple signals
- [ ] Generate recommendations
- [ ] Explain reasoning

**Implementation**:
```typescript
// src/services/ai/priority-recommendations.ts
interface PriorityRecommendation {
  feedback_id: string;
  title: string;
  current_status: string;
  recommended_priority: number; // 1-100
  signals: {
    vote_score: number;
    urgency_score: number;
    sentiment_impact: number;
    theme_size: number;
    recency_boost: number;
  };
  reasoning: string;
  suggested_action: 'prioritize' | 'investigate' | 'defer' | 'close';
}

export async function generatePriorityRecommendations(
  env: Env,
  workspaceId: string,
  limit = 10
): Promise<PriorityRecommendation[]> {
  // Get all open feedback with signals
  const feedback = await env.DB.prepare(`
    SELECT
      f.*,
      COALESCE(f.vote_count, 0) as votes,
      COALESCE(f.urgency_score, 0.5) as urgency,
      COALESCE(f.sentiment_score, 0) as sentiment,
      (SELECT COUNT(*) FROM feedback_theme_memberships WHERE feedback_id = f.id) as theme_count,
      julianday('now') - julianday(f.created_at) as age_days
    FROM feedback_items f
    WHERE f.workspace_id = ? AND f.status IN ('open', 'planned')
    ORDER BY f.vote_count DESC
    LIMIT 100
  `).bind(workspaceId).all();

  if (!feedback.results.length) {
    return [];
  }

  // Calculate composite scores
  const scored = feedback.results.map(f => {
    // Normalize signals to 0-1
    const maxVotes = Math.max(...feedback.results.map(x => x.votes));
    const voteScore = maxVotes > 0 ? f.votes / maxVotes : 0;
    const urgencyScore = f.urgency;
    const sentimentImpact = (1 - f.sentiment) / 2; // -1 to 1 -> 0 to 1, inverted
    const themeSize = Math.min(f.theme_count / 3, 1); // Cap at 3 themes
    const recencyBoost = Math.max(0, 1 - (f.age_days / 90)); // Decay over 90 days

    // Weighted composite
    const priority = Math.round(
      (voteScore * 0.3 +
       urgencyScore * 0.25 +
       sentimentImpact * 0.2 +
       themeSize * 0.15 +
       recencyBoost * 0.1) * 100
    );

    return {
      ...f,
      signals: {
        vote_score: voteScore,
        urgency_score: urgencyScore,
        sentiment_impact: sentimentImpact,
        theme_size: themeSize,
        recency_boost: recencyBoost
      },
      priority
    };
  });

  // Sort by composite priority
  scored.sort((a, b) => b.priority - a.priority);

  // Get top items for LLM reasoning
  const top = scored.slice(0, limit);

  // Generate reasoning via LLM
  const prompt = `
Analyze these prioritized feedback items and provide reasoning for each:

${top.map((f, i) => `
${i + 1}. "${f.title}"
   - Priority Score: ${f.priority}/100
   - Votes: ${f.votes}
   - Urgency: ${(f.urgency * 100).toFixed(0)}%
   - Sentiment: ${f.sentiment > 0 ? 'Positive' : f.sentiment < 0 ? 'Negative' : 'Neutral'}
   - Age: ${Math.round(f.age_days)} days
`).join('\n')}

For each item, provide:
1. A brief reasoning (1-2 sentences) explaining the priority
2. A suggested action: prioritize, investigate, defer, or close

Output JSON array:
[
  {
    "index": 0,
    "reasoning": "High votes and urgent...",
    "suggested_action": "prioritize"
  }
]
`;

  const response = await callLLM(env, {
    model: 'claude-3-haiku-20240307',
    messages: [
      { role: 'system', content: 'You are a product prioritization assistant. Output JSON only.' },
      { role: 'user', content: prompt }
    ],
    max_tokens: 2000
  });

  // Parse reasoning
  const reasonings = parseReasoningResponse(response.content);

  // Combine scores with reasoning
  return top.map((f, i) => ({
    feedback_id: f.id,
    title: f.title,
    current_status: f.status,
    recommended_priority: f.priority,
    signals: f.signals,
    reasoning: reasonings[i]?.reasoning || 'Based on composite score of votes, urgency, and sentiment.',
    suggested_action: reasonings[i]?.suggested_action || 'investigate'
  }));
}

function parseReasoningResponse(content: string): Array<{ reasoning: string; suggested_action: string }> {
  try {
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch {
    // Fallback
  }
  return [];
}

// API endpoint
// GET /api/v1/workspaces/:id/ai/priority-recommendations
export async function handlePriorityRecommendations(
  request: Request,
  env: Env,
  workspaceId: string
): Promise<Response> {
  const url = new URL(request.url);
  const limit = parseInt(url.searchParams.get('limit') || '10');

  const recommendations = await generatePriorityRecommendations(env, workspaceId, limit);

  return new Response(JSON.stringify({ recommendations }), {
    headers: { 'Content-Type': 'application/json' }
  });
}
```

**Acceptance Criteria**:
- [ ] Multi-signal priority scoring
- [ ] LLM-generated reasoning
- [ ] Actionable recommendations
- [ ] Transparent scoring breakdown

---

### Task 7.3.3: Status Update Generation (1.5h)

Generate status updates for roadmap items.

**Subtasks**:
- [ ] Analyze item progress
- [ ] Draft user-facing message
- [ ] Support one-click publish
- [ ] Link to changelogs

**Implementation**:
```typescript
// src/services/ai/status-updates.ts
interface StatusUpdateDraft {
  item_id: string;
  item_title: string;
  old_status: string;
  new_status: string;
  draft_message: string;
  tone: 'professional' | 'casual' | 'enthusiastic';
  include_stats: boolean;
}

export async function generateStatusUpdate(
  env: Env,
  itemId: string,
  newStatus: string,
  context?: {
    what_was_done?: string;
    blockers?: string;
    next_steps?: string;
  }
): Promise<StatusUpdateDraft> {
  // Get item details
  const item = await env.DB.prepare(`
    SELECT ri.*, f.vote_count, f.id as feedback_id
    FROM roadmap_items ri
    LEFT JOIN feedback_items f ON f.id = ri.feedback_id
    WHERE ri.id = ?
  `).bind(itemId).first();

  if (!item) {
    throw new Error('Item not found');
  }

  const prompt = `
Generate a status update message for this roadmap item:

**Item:** ${item.title}
**Previous Status:** ${item.status}
**New Status:** ${newStatus}
${item.vote_count ? `**Votes:** ${item.vote_count} users requested this` : ''}
${context?.what_was_done ? `**What was done:** ${context.what_was_done}` : ''}
${context?.blockers ? `**Blockers:** ${context.blockers}` : ''}
${context?.next_steps ? `**Next steps:** ${context.next_steps}` : ''}

Write a brief, user-friendly update (2-3 sentences) that:
1. Acknowledges the status change
2. Thanks users if relevant
3. Sets expectations for next steps

Tone: Professional but friendly
`;

  const response = await callLLM(env, {
    model: 'claude-3-haiku-20240307',
    messages: [
      { role: 'system', content: 'You are a product communications assistant. Write clear, friendly status updates.' },
      { role: 'user', content: prompt }
    ],
    max_tokens: 300
  });

  return {
    item_id: itemId,
    item_title: item.title,
    old_status: item.status,
    new_status: newStatus,
    draft_message: response.content.trim(),
    tone: 'professional',
    include_stats: !!item.vote_count
  };
}

// Publish status update
export async function publishStatusUpdate(
  env: Env,
  itemId: string,
  message: string,
  notifySubscribers = true
): Promise<void> {
  // Get item and roadmap
  const item = await env.DB.prepare(`
    SELECT ri.*, rm.workspace_id, rm.id as roadmap_id
    FROM roadmap_items ri
    JOIN roadmaps rm ON rm.id = ri.roadmap_id
    WHERE ri.id = ?
  `).bind(itemId).first();

  if (!item) throw new Error('Item not found');

  // Create status update record
  await env.DB.prepare(`
    INSERT INTO roadmap_item_updates (id, item_id, message, published_at)
    VALUES (?, ?, ?, datetime('now'))
  `).bind(crypto.randomUUID(), itemId, message).run();

  // Notify subscribers
  if (notifySubscribers) {
    await env.QUEUES.send({
      type: 'roadmap_item_update',
      roadmap_id: item.roadmap_id,
      item_id: itemId,
      item_title: item.title,
      message
    });
  }
}
```

**Schema Addition**:
```sql
CREATE TABLE IF NOT EXISTS roadmap_item_updates (
  id TEXT PRIMARY KEY,
  item_id TEXT NOT NULL REFERENCES roadmap_items(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  published_at TEXT DEFAULT (datetime('now'))
);
```

**Acceptance Criteria**:
- [ ] Status updates generated with context
- [ ] Tone appropriate for users
- [ ] One-click publish
- [ ] Subscriber notification

---

### Task 7.3.4: Release Notes Generation (1.5h)

Generate comprehensive release notes from completed items.

**Subtasks**:
- [ ] Aggregate completed items by period
- [ ] Generate formatted notes
- [ ] Include feedback links
- [ ] Support multiple formats

**Implementation**:
```typescript
// src/services/ai/release-notes.ts
interface ReleaseNotesInput {
  workspace_id: string;
  version?: string;
  start_date?: string;
  end_date?: string;
  item_ids?: string[]; // Specific items to include
  format: 'markdown' | 'html' | 'slack';
}

interface ReleaseNotes {
  version: string;
  date: string;
  sections: Array<{
    category: string; // 'Features', 'Improvements', 'Bug Fixes'
    items: Array<{
      title: string;
      description: string;
      feedback_links?: string[];
      vote_count?: number;
    }>;
  }>;
  summary: string;
  acknowledgment: string;
  raw_content: string;
}

export async function generateReleaseNotes(
  env: Env,
  input: ReleaseNotesInput
): Promise<ReleaseNotes> {
  // Get completed items
  let query = `
    SELECT ri.*, f.id as feedback_id, f.vote_count, f.category as feedback_category
    FROM roadmap_items ri
    LEFT JOIN feedback_items f ON f.id = ri.feedback_id
    WHERE ri.roadmap_id IN (SELECT id FROM roadmaps WHERE workspace_id = ?)
      AND ri.status = 'completed'
  `;
  const params: any[] = [input.workspace_id];

  if (input.start_date) {
    query += ' AND ri.completed_at >= ?';
    params.push(input.start_date);
  }
  if (input.end_date) {
    query += ' AND ri.completed_at < ?';
    params.push(input.end_date);
  }
  if (input.item_ids?.length) {
    query += ` AND ri.id IN (${input.item_ids.map(() => '?').join(',')})`;
    params.push(...input.item_ids);
  }

  query += ' ORDER BY ri.completed_at DESC';

  const items = await env.DB.prepare(query).bind(...params).all();

  if (!items.results.length) {
    throw new Error('No completed items found for release notes');
  }

  // Group by category
  const byCategory: Record<string, typeof items.results> = {
    'Features': [],
    'Improvements': [],
    'Bug Fixes': [],
    'Other': []
  };

  for (const item of items.results) {
    const category = item.feedback_category;
    if (category === 'feature_request') {
      byCategory['Features'].push(item);
    } else if (category === 'bug') {
      byCategory['Bug Fixes'].push(item);
    } else if (category === 'enhancement') {
      byCategory['Improvements'].push(item);
    } else {
      byCategory['Other'].push(item);
    }
  }

  // Calculate stats
  const totalVotes = items.results.reduce((sum, i) => sum + (i.vote_count || 0), 0);
  const feedbackCount = items.results.filter(i => i.feedback_id).length;

  // Generate via LLM
  const prompt = `
Generate release notes for these completed items:

${Object.entries(byCategory)
  .filter(([_, items]) => items.length > 0)
  .map(([category, items]) => `
## ${category}
${items.map(i => `- ${i.title}${i.description ? `: ${i.description}` : ''}`).join('\n')}
`).join('\n')}

Stats:
- Total items: ${items.results.length}
- User feedback addressed: ${feedbackCount}
- Total votes represented: ${totalVotes}

Generate:
1. A brief summary (1-2 sentences)
2. Formatted release notes with clear descriptions
3. An acknowledgment thanking users for feedback

Version: ${input.version || 'Latest'}
Format: ${input.format}
`;

  const response = await callLLM(env, {
    model: 'claude-3-haiku-20240307',
    messages: [
      { role: 'system', content: 'You are a technical writer creating release notes. Be clear and user-friendly.' },
      { role: 'user', content: prompt }
    ],
    max_tokens: 2000
  });

  // Format output
  const sections = Object.entries(byCategory)
    .filter(([_, items]) => items.length > 0)
    .map(([category, categoryItems]) => ({
      category,
      items: categoryItems.map(i => ({
        title: i.title,
        description: i.description || '',
        feedback_links: i.feedback_id ? [`/feedback/${i.feedback_id}`] : undefined,
        vote_count: i.vote_count
      }))
    }));

  return {
    version: input.version || new Date().toISOString().slice(0, 10),
    date: new Date().toISOString(),
    sections,
    summary: extractSummary(response.content),
    acknowledgment: `Thank you to the ${totalVotes} users who voted on these features!`,
    raw_content: response.content
  };
}

function extractSummary(content: string): string {
  // Extract first paragraph as summary
  const lines = content.split('\n').filter(l => l.trim());
  return lines[0] || 'Release notes for recent updates.';
}

// Format for different outputs
export function formatReleaseNotes(notes: ReleaseNotes, format: 'markdown' | 'html' | 'slack'): string {
  if (format === 'markdown') {
    return `
# Release ${notes.version}
*${new Date(notes.date).toLocaleDateString()}*

${notes.summary}

${notes.sections.map(s => `
## ${s.category}
${s.items.map(i => `- **${i.title}**${i.vote_count ? ` (${i.vote_count} votes)` : ''}\n  ${i.description}`).join('\n')}
`).join('\n')}

---
${notes.acknowledgment}
    `.trim();
  }

  if (format === 'slack') {
    return `
:rocket: *Release ${notes.version}*

${notes.summary}

${notes.sections.map(s => `
*${s.category}*
${s.items.map(i => `â€¢ ${i.title}`).join('\n')}
`).join('\n')}

${notes.acknowledgment}
    `.trim();
  }

  // HTML format
  return `<div class="release-notes">...</div>`;
}
```

**Acceptance Criteria**:
- [ ] Release notes from completed items
- [ ] Multiple format outputs
- [ ] Feedback attribution
- [ ] User acknowledgment

---

## Definition of Done
- [ ] Roadmap drafts generated from feedback
- [ ] Priority recommendations with reasoning
- [ ] Status updates one-click publish
- [ ] Release notes generation working
- [ ] All outputs human-reviewable

## Technical Notes
- Claude 3 Haiku for speed/cost efficiency
- JSON output parsing with fallbacks
- Human-in-the-loop for all publishing
- Cache LLM responses for similar queries

## Related Files
- `src/services/ai/roadmap-drafting.ts` - Draft generation
- `src/services/ai/priority-recommendations.ts` - Priority analysis
- `src/services/ai/status-updates.ts` - Update generation
- `src/services/ai/release-notes.ts` - Release notes
