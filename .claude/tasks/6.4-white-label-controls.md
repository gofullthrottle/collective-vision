# Epic 6.4: White-Label Controls

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Implement customization options for paid tiers including branding removal, custom domains, and visual theming.

## Wave Context
**Wave 6**: Monetization & Pricing (Stripe Integration, Subscription Tiers, White-Label)
**Dependencies**: 6.2 (Tier Management with feature flags)
**Unlocks**: Enterprise branding, agency resale, premium differentiation

## Quality Requirements
- Custom domains with automatic SSL (Cloudflare for SaaS)
- Theme system with CSS variable injection
- Email template customization
- Zero "Powered by" leakage on enterprise tier

---

## Tasks

### Task 6.4.1: Branding & Badge Removal (1h)

Control "Powered by Collective Vision" badge visibility based on subscription tier.

**Subtasks**:
- [ ] Add branding config to workspace settings
- [ ] Implement badge visibility logic in widget
- [ ] Add custom logo upload support
- [ ] Track badge removal as feature flag

**Schema**:
```sql
-- Workspace branding settings
CREATE TABLE IF NOT EXISTS workspace_branding (
  workspace_id TEXT PRIMARY KEY REFERENCES workspaces(id) ON DELETE CASCADE,
  show_powered_by INTEGER DEFAULT 1, -- 0 = hidden (paid feature)
  custom_logo_url TEXT,
  custom_logo_alt TEXT,
  custom_favicon_url TEXT,
  primary_color TEXT DEFAULT '#6366f1', -- Indigo-500
  accent_color TEXT DEFAULT '#8b5cf6', -- Violet-500
  background_color TEXT DEFAULT '#ffffff',
  text_color TEXT DEFAULT '#1f2937', -- Gray-800
  font_family TEXT DEFAULT 'Inter, system-ui, sans-serif',
  border_radius TEXT DEFAULT '8px',
  custom_css TEXT, -- Advanced CSS overrides (enterprise only)
  updated_at TEXT DEFAULT (datetime('now'))
);
```

**Implementation**:
```typescript
// src/services/branding.ts
import { checkFeatureFlag } from './tier-management';

interface BrandingConfig {
  show_powered_by: boolean;
  custom_logo_url: string | null;
  custom_logo_alt: string | null;
  colors: {
    primary: string;
    accent: string;
    background: string;
    text: string;
  };
  font_family: string;
  border_radius: string;
  custom_css: string | null;
}

export async function getBrandingConfig(
  env: Env,
  workspaceId: string
): Promise<BrandingConfig> {
  const branding = await env.DB.prepare(`
    SELECT * FROM workspace_branding WHERE workspace_id = ?
  `).bind(workspaceId).first();

  const workspace = await env.DB.prepare(`
    SELECT subscription_tier FROM workspaces WHERE id = ?
  `).bind(workspaceId).first<{ subscription_tier: string }>();

  const tier = workspace?.subscription_tier || 'free';

  // Feature flag checks
  const canRemoveBadge = checkFeatureFlag(tier, 'remove_powered_by');
  const canCustomize = checkFeatureFlag(tier, 'white_label');
  const canUseCustomCSS = checkFeatureFlag(tier, 'custom_css');

  // Default config
  const defaults: BrandingConfig = {
    show_powered_by: true,
    custom_logo_url: null,
    custom_logo_alt: null,
    colors: {
      primary: '#6366f1',
      accent: '#8b5cf6',
      background: '#ffffff',
      text: '#1f2937'
    },
    font_family: 'Inter, system-ui, sans-serif',
    border_radius: '8px',
    custom_css: null
  };

  if (!branding) return defaults;

  return {
    show_powered_by: canRemoveBadge ? !branding.show_powered_by : true,
    custom_logo_url: canCustomize ? branding.custom_logo_url : null,
    custom_logo_alt: canCustomize ? branding.custom_logo_alt : null,
    colors: canCustomize ? {
      primary: branding.primary_color || defaults.colors.primary,
      accent: branding.accent_color || defaults.colors.accent,
      background: branding.background_color || defaults.colors.background,
      text: branding.text_color || defaults.colors.text
    } : defaults.colors,
    font_family: canCustomize ? (branding.font_family || defaults.font_family) : defaults.font_family,
    border_radius: canCustomize ? (branding.border_radius || defaults.border_radius) : defaults.border_radius,
    custom_css: canUseCustomCSS ? branding.custom_css : null
  };
}

// Widget config endpoint
// GET /api/v1/:workspace/branding
export async function handleGetBranding(
  request: Request,
  env: Env,
  workspaceId: string
): Promise<Response> {
  const config = await getBrandingConfig(env, workspaceId);

  // Generate CSS variables
  const cssVariables = `
    :root {
      --cv-primary: ${config.colors.primary};
      --cv-accent: ${config.colors.accent};
      --cv-background: ${config.colors.background};
      --cv-text: ${config.colors.text};
      --cv-font-family: ${config.font_family};
      --cv-border-radius: ${config.border_radius};
    }
  `.trim();

  return new Response(JSON.stringify({
    ...config,
    css_variables: cssVariables
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
}
```

**Widget Integration**:
```typescript
// In widget.js - Update to fetch and apply branding
async function loadBranding(apiBase, workspace) {
  try {
    const res = await fetch(`${apiBase}/api/v1/${workspace}/branding`);
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

function applyBranding(branding, container) {
  if (!branding) return;

  // Apply CSS variables
  if (branding.css_variables) {
    const style = document.createElement('style');
    style.textContent = branding.css_variables;
    container.appendChild(style);
  }

  // Apply custom CSS (enterprise)
  if (branding.custom_css) {
    const customStyle = document.createElement('style');
    customStyle.textContent = branding.custom_css;
    container.appendChild(customStyle);
  }

  // Hide/show powered by badge
  const badge = container.querySelector('.cv-powered-by');
  if (badge) {
    badge.style.display = branding.show_powered_by ? 'block' : 'none';
  }

  // Custom logo
  if (branding.custom_logo_url) {
    const logo = container.querySelector('.cv-logo');
    if (logo) {
      logo.src = branding.custom_logo_url;
      logo.alt = branding.custom_logo_alt || 'Logo';
    }
  }
}
```

**Acceptance Criteria**:
- [ ] Badge hidden for Pro+ tiers with feature enabled
- [ ] Custom logo displayed when configured
- [ ] Colors applied via CSS variables
- [ ] Feature flags enforce tier restrictions

---

### Task 6.4.2: Custom Domain Support (1.5h)

Enable custom domains for feedback portals using Cloudflare for SaaS.

**Subtasks**:
- [ ] Add custom domain to workspace settings
- [ ] Implement domain verification
- [ ] Configure Cloudflare for SaaS SSL
- [ ] Route requests by hostname

**Schema**:
```sql
-- Custom domains
CREATE TABLE IF NOT EXISTS workspace_domains (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  domain TEXT NOT NULL UNIQUE,
  verification_status TEXT DEFAULT 'pending', -- 'pending', 'verified', 'failed'
  verification_token TEXT,
  ssl_status TEXT DEFAULT 'pending', -- 'pending', 'active', 'error'
  cloudflare_custom_hostname_id TEXT,
  is_primary INTEGER DEFAULT 0,
  created_at TEXT DEFAULT (datetime('now')),
  verified_at TEXT,
  UNIQUE(workspace_id, domain)
);

CREATE INDEX idx_domains_lookup ON workspace_domains(domain);
```

**Implementation**:
```typescript
// src/services/custom-domains.ts
interface DomainSetup {
  workspace_id: string;
  domain: string;
}

interface DomainStatus {
  domain: string;
  verification_status: 'pending' | 'verified' | 'failed';
  ssl_status: 'pending' | 'active' | 'error';
  verification_instructions?: string;
}

export async function addCustomDomain(
  env: Env,
  setup: DomainSetup
): Promise<DomainStatus> {
  // Check feature flag
  const workspace = await env.DB.prepare(`
    SELECT subscription_tier FROM workspaces WHERE id = ?
  `).bind(setup.workspace_id).first<{ subscription_tier: string }>();

  if (!checkFeatureFlag(workspace?.subscription_tier || 'free', 'custom_domain')) {
    throw new Error('Custom domains require Pro or Enterprise plan');
  }

  // Generate verification token
  const verificationToken = crypto.randomUUID();

  // Create Cloudflare Custom Hostname (Cloudflare for SaaS)
  const cfResponse = await fetch(
    `https://api.cloudflare.com/client/v4/zones/${env.CF_ZONE_ID}/custom_hostnames`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.CF_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        hostname: setup.domain,
        ssl: {
          method: 'http',
          type: 'dv',
          settings: {
            min_tls_version: '1.2'
          }
        }
      })
    }
  );

  const cfResult = await cfResponse.json();

  if (!cfResult.success) {
    throw new Error(`Cloudflare error: ${cfResult.errors?.[0]?.message || 'Unknown error'}`);
  }

  // Store domain
  await env.DB.prepare(`
    INSERT INTO workspace_domains (
      workspace_id, domain, verification_token, cloudflare_custom_hostname_id
    ) VALUES (?, ?, ?, ?)
  `).bind(
    setup.workspace_id,
    setup.domain,
    verificationToken,
    cfResult.result.id
  ).run();

  return {
    domain: setup.domain,
    verification_status: 'pending',
    ssl_status: 'pending',
    verification_instructions: `
      Add a CNAME record pointing ${setup.domain} to feedback.collective-vision.com

      OR add a TXT record:
      Name: _cv-verify.${setup.domain}
      Value: ${verificationToken}
    `
  };
}

export async function verifyDomain(
  env: Env,
  domain: string
): Promise<DomainStatus> {
  const domainRecord = await env.DB.prepare(`
    SELECT * FROM workspace_domains WHERE domain = ?
  `).bind(domain).first();

  if (!domainRecord) {
    throw new Error('Domain not found');
  }

  // Check Cloudflare status
  const cfResponse = await fetch(
    `https://api.cloudflare.com/client/v4/zones/${env.CF_ZONE_ID}/custom_hostnames/${domainRecord.cloudflare_custom_hostname_id}`,
    {
      headers: {
        'Authorization': `Bearer ${env.CF_API_TOKEN}`
      }
    }
  );

  const cfResult = await cfResponse.json();

  if (!cfResult.success) {
    throw new Error('Failed to check domain status');
  }

  const hostname = cfResult.result;
  const verificationStatus = hostname.status === 'active' ? 'verified' :
    hostname.status === 'pending' ? 'pending' : 'failed';
  const sslStatus = hostname.ssl?.status === 'active' ? 'active' :
    hostname.ssl?.status === 'pending_validation' ? 'pending' : 'error';

  // Update database
  await env.DB.prepare(`
    UPDATE workspace_domains
    SET verification_status = ?, ssl_status = ?, verified_at = CASE WHEN ? = 'verified' THEN datetime('now') ELSE verified_at END
    WHERE domain = ?
  `).bind(verificationStatus, sslStatus, verificationStatus, domain).run();

  return {
    domain,
    verification_status: verificationStatus,
    ssl_status: sslStatus
  };
}

// Request routing by hostname
export async function resolveWorkspaceByDomain(
  env: Env,
  hostname: string
): Promise<string | null> {
  // Check custom domains
  const domain = await env.DB.prepare(`
    SELECT workspace_id FROM workspace_domains
    WHERE domain = ? AND verification_status = 'verified'
  `).bind(hostname).first<{ workspace_id: string }>();

  if (domain) {
    return domain.workspace_id;
  }

  // Check subdomain pattern (workspace.feedback.collective-vision.com)
  const match = hostname.match(/^([^.]+)\.feedback\.collective-vision\.com$/);
  if (match) {
    const workspace = await env.DB.prepare(`
      SELECT id FROM workspaces WHERE slug = ?
    `).bind(match[1]).first<{ id: string }>();
    return workspace?.id || null;
  }

  return null;
}
```

**Acceptance Criteria**:
- [ ] Custom domains added via admin UI
- [ ] Cloudflare for SaaS integration working
- [ ] SSL automatically provisioned
- [ ] Requests routed by hostname

---

### Task 6.4.3: CSS Theme System (1h)

Enable comprehensive visual customization through theme presets and custom CSS.

**Subtasks**:
- [ ] Create theme preset library
- [ ] Implement theme preview endpoint
- [ ] Add custom CSS editor (enterprise)
- [ ] Validate CSS for security

**Implementation**:
```typescript
// src/services/themes.ts
interface ThemePreset {
  id: string;
  name: string;
  colors: {
    primary: string;
    accent: string;
    background: string;
    text: string;
    muted: string;
    border: string;
  };
  font_family: string;
  border_radius: string;
}

export const THEME_PRESETS: ThemePreset[] = [
  {
    id: 'default',
    name: 'Default',
    colors: {
      primary: '#6366f1',
      accent: '#8b5cf6',
      background: '#ffffff',
      text: '#1f2937',
      muted: '#6b7280',
      border: '#e5e7eb'
    },
    font_family: 'Inter, system-ui, sans-serif',
    border_radius: '8px'
  },
  {
    id: 'dark',
    name: 'Dark Mode',
    colors: {
      primary: '#818cf8',
      accent: '#a78bfa',
      background: '#1f2937',
      text: '#f9fafb',
      muted: '#9ca3af',
      border: '#374151'
    },
    font_family: 'Inter, system-ui, sans-serif',
    border_radius: '8px'
  },
  {
    id: 'minimal',
    name: 'Minimal',
    colors: {
      primary: '#000000',
      accent: '#404040',
      background: '#ffffff',
      text: '#171717',
      muted: '#737373',
      border: '#e5e5e5'
    },
    font_family: 'system-ui, -apple-system, sans-serif',
    border_radius: '4px'
  },
  {
    id: 'ocean',
    name: 'Ocean',
    colors: {
      primary: '#0ea5e9',
      accent: '#06b6d4',
      background: '#f0f9ff',
      text: '#0c4a6e',
      muted: '#64748b',
      border: '#bae6fd'
    },
    font_family: 'Inter, system-ui, sans-serif',
    border_radius: '12px'
  },
  {
    id: 'forest',
    name: 'Forest',
    colors: {
      primary: '#22c55e',
      accent: '#10b981',
      background: '#f0fdf4',
      text: '#14532d',
      muted: '#6b7280',
      border: '#bbf7d0'
    },
    font_family: 'Inter, system-ui, sans-serif',
    border_radius: '8px'
  }
];

export function getThemePreset(id: string): ThemePreset | null {
  return THEME_PRESETS.find(t => t.id === id) || null;
}

export function generateThemeCSS(theme: ThemePreset): string {
  return `
    :root {
      --cv-primary: ${theme.colors.primary};
      --cv-accent: ${theme.colors.accent};
      --cv-background: ${theme.colors.background};
      --cv-text: ${theme.colors.text};
      --cv-muted: ${theme.colors.muted};
      --cv-border: ${theme.colors.border};
      --cv-font-family: ${theme.font_family};
      --cv-border-radius: ${theme.border_radius};
    }
  `;
}

// CSS validation for security (prevent XSS via CSS)
export function validateCustomCSS(css: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Disallow javascript: URLs
  if (/javascript:/i.test(css)) {
    errors.push('JavaScript URLs are not allowed');
  }

  // Disallow expression() (IE)
  if (/expression\s*\(/i.test(css)) {
    errors.push('CSS expressions are not allowed');
  }

  // Disallow behavior: (IE)
  if (/behavior\s*:/i.test(css)) {
    errors.push('CSS behaviors are not allowed');
  }

  // Disallow @import (prevent external loading)
  if (/@import/i.test(css)) {
    errors.push('@import is not allowed');
  }

  // Disallow url() pointing outside (allow data: URIs)
  const urlMatches = css.match(/url\s*\([^)]+\)/gi) || [];
  for (const urlMatch of urlMatches) {
    if (!/url\s*\(\s*['"]?data:/i.test(urlMatch) &&
        !/url\s*\(\s*['"]?#/i.test(urlMatch)) {
      errors.push('External URLs in CSS are not allowed');
      break;
    }
  }

  // Max size check (50KB)
  if (css.length > 50000) {
    errors.push('Custom CSS exceeds 50KB limit');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

// Apply theme to workspace
// PUT /api/v1/admin/:workspace/theme
export async function updateWorkspaceTheme(
  env: Env,
  workspaceId: string,
  input: {
    preset_id?: string;
    custom_colors?: Partial<ThemePreset['colors']>;
    custom_css?: string;
  }
): Promise<{ success: boolean; theme: ThemePreset }> {
  const workspace = await env.DB.prepare(`
    SELECT subscription_tier FROM workspaces WHERE id = ?
  `).bind(workspaceId).first<{ subscription_tier: string }>();

  const tier = workspace?.subscription_tier || 'free';

  // Get base theme
  let theme = input.preset_id ? getThemePreset(input.preset_id) : THEME_PRESETS[0];
  if (!theme) theme = THEME_PRESETS[0];

  // Apply custom colors (pro+)
  if (input.custom_colors && checkFeatureFlag(tier, 'white_label')) {
    theme = {
      ...theme,
      colors: { ...theme.colors, ...input.custom_colors }
    };
  }

  // Validate custom CSS (enterprise only)
  if (input.custom_css) {
    if (!checkFeatureFlag(tier, 'custom_css')) {
      throw new Error('Custom CSS requires Enterprise plan');
    }
    const validation = validateCustomCSS(input.custom_css);
    if (!validation.valid) {
      throw new Error(`Invalid CSS: ${validation.errors.join(', ')}`);
    }
  }

  // Update database
  await env.DB.prepare(`
    INSERT INTO workspace_branding (
      workspace_id, primary_color, accent_color, background_color, text_color,
      font_family, border_radius, custom_css
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(workspace_id) DO UPDATE SET
      primary_color = ?, accent_color = ?, background_color = ?, text_color = ?,
      font_family = ?, border_radius = ?, custom_css = ?, updated_at = datetime('now')
  `).bind(
    workspaceId,
    theme.colors.primary, theme.colors.accent, theme.colors.background, theme.colors.text,
    theme.font_family, theme.border_radius, input.custom_css || null,
    theme.colors.primary, theme.colors.accent, theme.colors.background, theme.colors.text,
    theme.font_family, theme.border_radius, input.custom_css || null
  ).run();

  return { success: true, theme };
}
```

**Acceptance Criteria**:
- [ ] 5+ theme presets available
- [ ] Custom color overrides for Pro+
- [ ] Custom CSS for Enterprise
- [ ] CSS validated for security

---

### Task 6.4.4: Email Template Customization (0.5h)

Allow customization of transactional email templates.

**Subtasks**:
- [ ] Create email template system
- [ ] Add customizable header/footer
- [ ] Support logo in emails
- [ ] Preview email templates

**Implementation**:
```typescript
// src/services/email-templates.ts
interface EmailTemplate {
  type: 'feedback_received' | 'status_update' | 'comment_reply' | 'vote_milestone';
  subject: string;
  html: string;
  text: string;
}

interface EmailBranding {
  logo_url: string | null;
  primary_color: string;
  company_name: string;
  support_email: string;
  footer_text: string;
  show_powered_by: boolean;
}

export function renderEmailTemplate(
  template: EmailTemplate,
  branding: EmailBranding,
  variables: Record<string, string>
): { subject: string; html: string; text: string } {
  // Replace variables in subject
  let subject = template.subject;
  for (const [key, value] of Object.entries(variables)) {
    subject = subject.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }

  // Build HTML email
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #1f2937; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; padding: 20px 0; border-bottom: 1px solid #e5e7eb; }
    .logo { max-height: 40px; }
    .content { padding: 30px 0; }
    .button { display: inline-block; background: ${branding.primary_color}; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; }
    .footer { text-align: center; padding: 20px 0; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 12px; }
    .powered-by { margin-top: 10px; }
    .powered-by a { color: #6b7280; text-decoration: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      ${branding.logo_url ? `<img src="${branding.logo_url}" alt="${branding.company_name}" class="logo">` : `<h2>${branding.company_name}</h2>`}
    </div>
    <div class="content">
      ${interpolateVariables(template.html, variables)}
    </div>
    <div class="footer">
      <p>${branding.footer_text}</p>
      <p>Questions? Contact <a href="mailto:${branding.support_email}">${branding.support_email}</a></p>
      ${branding.show_powered_by ? `
        <p class="powered-by">
          Powered by <a href="https://collective-vision.com">Collective Vision</a>
        </p>
      ` : ''}
    </div>
  </div>
</body>
</html>
  `;

  // Plain text version
  const text = interpolateVariables(template.text, variables) + `

---
${branding.footer_text}
Questions? Contact ${branding.support_email}
${branding.show_powered_by ? '\nPowered by Collective Vision - https://collective-vision.com' : ''}
  `;

  return { subject, html, text };
}

function interpolateVariables(template: string, variables: Record<string, string>): string {
  let result = template;
  for (const [key, value] of Object.entries(variables)) {
    result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }
  return result;
}

// Default templates
export const DEFAULT_TEMPLATES: Record<string, EmailTemplate> = {
  feedback_received: {
    type: 'feedback_received',
    subject: 'Thanks for your feedback: {{title}}',
    html: `
      <h3>We received your feedback!</h3>
      <p>Thank you for taking the time to share your thoughts with us.</p>
      <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
        <strong>{{title}}</strong>
        <p style="color: #6b7280; margin: 10px 0 0 0;">{{description}}</p>
      </div>
      <p>We'll review your feedback and keep you updated on any progress.</p>
      <p style="margin-top: 20px;">
        <a href="{{feedback_url}}" class="button">View Your Feedback</a>
      </p>
    `,
    text: `
We received your feedback!

Thank you for taking the time to share your thoughts with us.

Your feedback: {{title}}
{{description}}

We'll review your feedback and keep you updated on any progress.

View your feedback: {{feedback_url}}
    `
  },
  status_update: {
    type: 'status_update',
    subject: 'Update on your feedback: {{title}}',
    html: `
      <h3>Your feedback status has changed</h3>
      <p>We wanted to let you know that there's been an update to your feedback.</p>
      <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
        <strong>{{title}}</strong>
        <p style="margin: 10px 0;">Status: <span style="color: {{status_color}}; font-weight: 600;">{{status}}</span></p>
      </div>
      <p style="margin-top: 20px;">
        <a href="{{feedback_url}}" class="button">View Details</a>
      </p>
    `,
    text: `
Your feedback status has changed

We wanted to let you know that there's been an update to your feedback.

Feedback: {{title}}
New Status: {{status}}

View details: {{feedback_url}}
    `
  }
};
```

**Acceptance Criteria**:
- [ ] Email templates use workspace branding
- [ ] Logo included in email headers
- [ ] Powered by badge respects settings
- [ ] Preview available before sending

---

## Definition of Done
- [ ] Badge removal working for paid tiers
- [ ] Custom domains with SSL
- [ ] Theme system with presets and custom CSS
- [ ] Email templates branded
- [ ] Feature flags enforce tier restrictions

## Technical Notes
- Cloudflare for SaaS handles custom domain SSL
- CSS validated to prevent XSS
- Email templates compatible with major clients
- Theme changes reflected in widget within 60s (KV TTL)

## Related Files
- `src/services/branding.ts` - Branding configuration
- `src/services/custom-domains.ts` - Domain management
- `src/services/themes.ts` - Theme presets
- `src/services/email-templates.ts` - Email customization
