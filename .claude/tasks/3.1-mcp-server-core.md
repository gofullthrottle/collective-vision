# Epic 3.1: MCP Server Core

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Build MCP-compliant server endpoint on Cloudflare Workers
**Tools**: TypeScript MCP SDK, JSON-RPC 2.0, Cloudflare Workers

## Wave Context
**Wave**: 3 - MCP Server + Agent Integration
**Priority**: P1 (enables agent ecosystem)
**Dependencies**: Epic 2.1 (AI infrastructure), Epic 1.6 (API authentication)
**Estimated Duration**: 8 hours

## Quality Requirements
- MCP protocol compliance (initialize, tools/list, tools/call)
- Sub-100ms response for tool listing
- Proper error codes for agent consumption
- Rate limiting per API key

---

## Tasks

### 3.1.1 MCP SDK Setup (2h)
**Objective**: Configure MCP server as Cloudflare Worker endpoint

**Steps**:
1. Install TypeScript MCP SDK:
   ```bash
   npm install @modelcontextprotocol/sdk
   ```

2. Create MCP server entry point:
   ```typescript
   // src/mcp/server.ts

   import { Server } from '@modelcontextprotocol/sdk/server/index.js';
   import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

   export interface MCPContext {
     workspaceId: string;
     apiKeyId: string;
     scopes: string[];
     env: Env;
   }

   export async function handleMCPRequest(
     request: Request,
     env: Env
   ): Promise<Response> {
     const body = await request.json();

     // JSON-RPC 2.0 handling
     if (!body.jsonrpc || body.jsonrpc !== '2.0') {
       return jsonRPCError(-32600, 'Invalid JSON-RPC version');
     }

     const { method, params, id } = body;

     switch (method) {
       case 'initialize':
         return handleInitialize(params, id);
       case 'tools/list':
         return handleToolsList(id);
       case 'tools/call':
         return handleToolsCall(params, id, env);
       default:
         return jsonRPCError(-32601, `Method not found: ${method}`, id);
     }
   }
   ```

3. Implement JSON-RPC response helpers:
   ```typescript
   // src/mcp/rpc.ts

   export function jsonRPCSuccess(result: unknown, id: string | number): Response {
     return new Response(JSON.stringify({
       jsonrpc: '2.0',
       result,
       id
     }), {
       headers: { 'Content-Type': 'application/json' }
     });
   }

   export function jsonRPCError(
     code: number,
     message: string,
     id?: string | number,
     data?: unknown
   ): Response {
     return new Response(JSON.stringify({
       jsonrpc: '2.0',
       error: { code, message, data },
       id: id ?? null
     }), {
       status: code === -32600 || code === -32700 ? 400 : 200,
       headers: { 'Content-Type': 'application/json' }
     });
   }
   ```

4. Add MCP routes to worker:
   ```typescript
   // src/worker.ts - add to router

   if (url.pathname === '/mcp' && request.method === 'POST') {
     return handleMCPRequest(request, env);
   }

   if (url.pathname === '/mcp/.well-known/mcp.json') {
     return new Response(JSON.stringify({
       name: 'collective-vision',
       version: '1.0.0',
       description: 'AI-native feedback platform MCP server',
       tools: getToolDefinitions()
     }), {
       headers: { 'Content-Type': 'application/json' }
     });
   }
   ```

**Acceptance Criteria**:
- [ ] MCP endpoint responds at POST /mcp
- [ ] Initialize method returns server info
- [ ] Discovery endpoint at /mcp/.well-known/mcp.json
- [ ] JSON-RPC 2.0 error handling works

---

### 3.1.2 MCP Authentication (2h)
**Objective**: Secure MCP requests with API key authentication

**Steps**:
1. Create MCP API key table:
   ```sql
   CREATE TABLE mcp_api_keys (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     key_hash TEXT NOT NULL,  -- SHA-256 of key
     key_prefix TEXT NOT NULL,  -- First 8 chars for identification
     scopes TEXT NOT NULL,  -- JSON array: ["read", "write", "admin"]
     created_by TEXT NOT NULL,
     created_at TEXT DEFAULT (datetime('now')),
     last_used_at TEXT,
     expires_at TEXT,
     is_revoked INTEGER DEFAULT 0,
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
     FOREIGN KEY (created_by) REFERENCES workspace_members(id)
   );

   CREATE INDEX idx_mcp_keys_hash ON mcp_api_keys(key_hash);
   CREATE INDEX idx_mcp_keys_workspace ON mcp_api_keys(workspace_id, is_revoked);
   ```

2. Create key generation utility:
   ```typescript
   // src/lib/api-keys.ts

   export async function generateMCPApiKey(
     workspaceId: string,
     name: string,
     scopes: string[],
     createdBy: string,
     env: Env
   ): Promise<{ id: string; key: string }> {
     const id = generateId('mcp_key');
     // Format: cv_mcp_<random 32 chars>
     const key = `cv_mcp_${crypto.randomUUID().replace(/-/g, '')}`;
     const keyHash = await hashKey(key);
     const keyPrefix = key.substring(0, 15);

     await env.DB.prepare(`
       INSERT INTO mcp_api_keys (id, workspace_id, name, key_hash, key_prefix, scopes, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?)
     `).bind(id, workspaceId, name, keyHash, keyPrefix, JSON.stringify(scopes), createdBy).run();

     return { id, key };  // Key only returned once at creation
   }

   async function hashKey(key: string): Promise<string> {
     const encoder = new TextEncoder();
     const data = encoder.encode(key);
     const hash = await crypto.subtle.digest('SHA-256', data);
     return Array.from(new Uint8Array(hash))
       .map(b => b.toString(16).padStart(2, '0'))
       .join('');
   }
   ```

3. Implement authentication middleware:
   ```typescript
   // src/mcp/auth.ts

   export async function authenticateMCPRequest(
     request: Request,
     env: Env
   ): Promise<MCPContext | null> {
     // Check header first
     let apiKey = request.headers.get('Authorization')?.replace('Bearer ', '');

     // Or from request body
     if (!apiKey) {
       try {
         const body = await request.clone().json();
         apiKey = body.params?.api_key;
       } catch {}
     }

     if (!apiKey || !apiKey.startsWith('cv_mcp_')) {
       return null;
     }

     const keyHash = await hashKey(apiKey);

     const keyRecord = await env.DB.prepare(`
       SELECT mk.*, w.id as workspace_id
       FROM mcp_api_keys mk
       JOIN workspaces w ON mk.workspace_id = w.id
       WHERE mk.key_hash = ? AND mk.is_revoked = 0
         AND (mk.expires_at IS NULL OR mk.expires_at > datetime('now'))
     `).bind(keyHash).first();

     if (!keyRecord) return null;

     // Update last used
     await env.DB.prepare(`
       UPDATE mcp_api_keys SET last_used_at = datetime('now') WHERE id = ?
     `).bind(keyRecord.id).run();

     return {
       workspaceId: keyRecord.workspace_id,
       apiKeyId: keyRecord.id,
       scopes: JSON.parse(keyRecord.scopes),
       env
     };
   }

   export function requireScope(context: MCPContext, scope: string): boolean {
     return context.scopes.includes(scope) || context.scopes.includes('admin');
   }
   ```

4. Add rate limiting:
   ```typescript
   // src/mcp/rate-limit.ts

   interface RateLimitResult {
     allowed: boolean;
     remaining: number;
     resetAt: number;
   }

   export async function checkRateLimit(
     apiKeyId: string,
     env: Env
   ): Promise<RateLimitResult> {
     const windowMs = 60000;  // 1 minute
     const limit = 100;  // 100 requests per minute

     const now = Date.now();
     const windowStart = now - windowMs;
     const cacheKey = `rate:${apiKeyId}:${Math.floor(now / windowMs)}`;

     // Use D1 for simplicity; could use Durable Objects for scale
     const count = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM mcp_request_log
       WHERE api_key_id = ? AND created_at > datetime(?, 'unixepoch', 'localtime')
     `).bind(apiKeyId, windowStart / 1000).first();

     const used = (count?.count as number) || 0;

     if (used >= limit) {
       return {
         allowed: false,
         remaining: 0,
         resetAt: Math.ceil(now / windowMs) * windowMs
       };
     }

     // Log this request
     await env.DB.prepare(`
       INSERT INTO mcp_request_log (api_key_id, created_at)
       VALUES (?, datetime('now'))
     `).bind(apiKeyId).run();

     return {
       allowed: true,
       remaining: limit - used - 1,
       resetAt: Math.ceil(now / windowMs) * windowMs
     };
   }
   ```

**Acceptance Criteria**:
- [ ] API keys generated with cv_mcp_ prefix
- [ ] Keys scoped to workspace with read/write permissions
- [ ] Unauthorized requests get -32000 error
- [ ] Rate limiting enforced per key

---

### 3.1.3 Tool Registration Framework (2h)
**Objective**: Create extensible framework for defining MCP tools

**Steps**:
1. Define tool interface:
   ```typescript
   // src/mcp/tools/types.ts

   import { z } from 'zod';

   export interface ToolDefinition<TInput = unknown, TOutput = unknown> {
     name: string;
     description: string;
     inputSchema: z.ZodType<TInput>;
     requiredScope: 'read' | 'write' | 'admin';
     handler: (input: TInput, context: MCPContext) => Promise<TOutput>;
   }

   export interface ToolListItem {
     name: string;
     description: string;
     inputSchema: object;
   }
   ```

2. Create tool registry:
   ```typescript
   // src/mcp/tools/registry.ts

   import { ToolDefinition, ToolListItem } from './types';
   import { zodToJsonSchema } from 'zod-to-json-schema';

   const tools: Map<string, ToolDefinition> = new Map();

   export function registerTool<TInput, TOutput>(
     tool: ToolDefinition<TInput, TOutput>
   ): void {
     tools.set(tool.name, tool as ToolDefinition);
   }

   export function getToolDefinitions(): ToolListItem[] {
     return Array.from(tools.values()).map(tool => ({
       name: tool.name,
       description: tool.description,
       inputSchema: zodToJsonSchema(tool.inputSchema)
     }));
   }

   export function getTool(name: string): ToolDefinition | undefined {
     return tools.get(name);
   }
   ```

3. Implement tool call handler:
   ```typescript
   // src/mcp/handlers.ts

   export async function handleToolsCall(
     params: { name: string; arguments: unknown },
     id: string | number,
     env: Env
   ): Promise<Response> {
     const tool = getTool(params.name);

     if (!tool) {
       return jsonRPCError(-32602, `Unknown tool: ${params.name}`, id);
     }

     // Get authenticated context from request
     const context = await authenticateMCPRequest(request, env);
     if (!context) {
       return jsonRPCError(-32000, 'Authentication required', id);
     }

     // Check scope
     if (!requireScope(context, tool.requiredScope)) {
       return jsonRPCError(-32000, `Insufficient permissions. Required: ${tool.requiredScope}`, id);
     }

     // Check rate limit
     const rateLimit = await checkRateLimit(context.apiKeyId, env);
     if (!rateLimit.allowed) {
       return jsonRPCError(-32000, 'Rate limit exceeded', id, {
         retry_after: Math.ceil((rateLimit.resetAt - Date.now()) / 1000),
         limit: 100,
         remaining: 0
       });
     }

     // Validate input
     const parseResult = tool.inputSchema.safeParse(params.arguments);
     if (!parseResult.success) {
       return jsonRPCError(-32602, 'Invalid parameters', id, {
         validation_errors: parseResult.error.errors
       });
     }

     // Execute tool
     try {
       const result = await tool.handler(parseResult.data, context);
       return jsonRPCSuccess(result, id);
     } catch (error) {
       console.error(`Tool error [${params.name}]:`, error);
       return jsonRPCError(-32603, 'Internal error', id, {
         message: error instanceof Error ? error.message : 'Unknown error'
       });
     }
   }
   ```

4. Create example tool registration:
   ```typescript
   // src/mcp/tools/index.ts

   import { registerTool } from './registry';
   import { z } from 'zod';

   // Register all tools on module load
   export function initializeTools(): void {
     // Query tools (Epic 3.2)
     registerListFeedbackTool();
     registerGetFeedbackTool();
     registerSearchFeedbackTool();
     registerGetThemesTool();
     registerGetTrendsTool();
     registerGetStatisticsTool();

     // Write tools (Epic 3.3)
     registerSubmitFeedbackTool();
     registerVoteFeedbackTool();
     registerAddCommentTool();
     registerUpdateStatusTool();
   }
   ```

**Acceptance Criteria**:
- [ ] Tools easily definable with TypeScript types
- [ ] JSON Schema auto-generated from Zod schemas
- [ ] Input validation automatic
- [ ] Scope checking per tool

---

### 3.1.4 Error Handling & Logging (2h)
**Objective**: Structured error responses and request logging

**Steps**:
1. Define MCP error codes:
   ```typescript
   // src/mcp/errors.ts

   export const MCPErrorCodes = {
     // Standard JSON-RPC errors
     PARSE_ERROR: -32700,
     INVALID_REQUEST: -32600,
     METHOD_NOT_FOUND: -32601,
     INVALID_PARAMS: -32602,
     INTERNAL_ERROR: -32603,

     // Custom MCP errors (-32000 to -32099)
     AUTHENTICATION_REQUIRED: -32000,
     INSUFFICIENT_PERMISSIONS: -32001,
     RATE_LIMIT_EXCEEDED: -32002,
     RESOURCE_NOT_FOUND: -32003,
     VALIDATION_ERROR: -32004,
     WORKSPACE_SUSPENDED: -32005,
     QUOTA_EXCEEDED: -32006
   } as const;

   export class MCPError extends Error {
     constructor(
       public code: number,
       message: string,
       public data?: unknown
     ) {
       super(message);
       this.name = 'MCPError';
     }
   }
   ```

2. Create request logging table:
   ```sql
   CREATE TABLE mcp_request_log (
     id TEXT PRIMARY KEY,
     api_key_id TEXT NOT NULL,
     method TEXT NOT NULL,
     tool_name TEXT,
     duration_ms INTEGER,
     status TEXT,  -- success, error, rate_limited
     error_code INTEGER,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (api_key_id) REFERENCES mcp_api_keys(id)
   );

   CREATE INDEX idx_mcp_log_key_time ON mcp_request_log(api_key_id, created_at);
   CREATE INDEX idx_mcp_log_status ON mcp_request_log(status, created_at);
   ```

3. Implement request logging:
   ```typescript
   // src/mcp/logging.ts

   interface RequestLog {
     apiKeyId: string;
     method: string;
     toolName?: string;
     durationMs: number;
     status: 'success' | 'error' | 'rate_limited';
     errorCode?: number;
   }

   export async function logMCPRequest(log: RequestLog, env: Env): Promise<void> {
     await env.DB.prepare(`
       INSERT INTO mcp_request_log (id, api_key_id, method, tool_name, duration_ms, status, error_code)
       VALUES (?, ?, ?, ?, ?, ?, ?)
     `).bind(
       generateId('mcplog'),
       log.apiKeyId,
       log.method,
       log.toolName ?? null,
       log.durationMs,
       log.status,
       log.errorCode ?? null
     ).run();
   }
   ```

4. Add metrics aggregation:
   ```typescript
   // src/mcp/metrics.ts

   export async function getMCPMetrics(
     workspaceId: string,
     timeframe: '1h' | '24h' | '7d',
     env: Env
   ): Promise<{
     total_requests: number;
     success_rate: number;
     avg_duration_ms: number;
     by_tool: Record<string, number>;
     by_status: Record<string, number>;
   }> {
     const since = {
       '1h': "datetime('now', '-1 hour')",
       '24h': "datetime('now', '-1 day')",
       '7d': "datetime('now', '-7 days')"
     }[timeframe];

     const stats = await env.DB.prepare(`
       SELECT
         COUNT(*) as total,
         SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as success,
         AVG(duration_ms) as avg_duration,
         tool_name,
         status
       FROM mcp_request_log mrl
       JOIN mcp_api_keys mk ON mrl.api_key_id = mk.id
       WHERE mk.workspace_id = ? AND mrl.created_at > ${since}
       GROUP BY tool_name, status
     `).bind(workspaceId).all();

     // Aggregate results
     const result = {
       total_requests: 0,
       success_rate: 0,
       avg_duration_ms: 0,
       by_tool: {} as Record<string, number>,
       by_status: {} as Record<string, number>
     };

     let successCount = 0;
     let totalDuration = 0;

     for (const row of stats.results) {
       result.total_requests += row.total as number;
       if (row.status === 'success') successCount += row.total as number;
       totalDuration += (row.avg_duration as number) * (row.total as number);

       if (row.tool_name) {
         result.by_tool[row.tool_name] = (result.by_tool[row.tool_name] || 0) + (row.total as number);
       }
       result.by_status[row.status as string] = (result.by_status[row.status as string] || 0) + (row.total as number);
     }

     result.success_rate = result.total_requests > 0 ? successCount / result.total_requests : 0;
     result.avg_duration_ms = result.total_requests > 0 ? totalDuration / result.total_requests : 0;

     return result;
   }
   ```

5. Sanitize logs to remove sensitive data:
   ```typescript
   // src/mcp/logging.ts - addition

   export function sanitizeForLogging(data: unknown): unknown {
     if (typeof data !== 'object' || data === null) return data;

     const sensitiveKeys = ['api_key', 'password', 'token', 'secret', 'authorization'];
     const sanitized: Record<string, unknown> = {};

     for (const [key, value] of Object.entries(data)) {
       if (sensitiveKeys.some(k => key.toLowerCase().includes(k))) {
         sanitized[key] = '[REDACTED]';
       } else if (typeof value === 'object') {
         sanitized[key] = sanitizeForLogging(value);
       } else {
         sanitized[key] = value;
       }
     }

     return sanitized;
   }
   ```

**Acceptance Criteria**:
- [ ] Error codes actionable for agents
- [ ] All requests logged with duration
- [ ] Sensitive data never in logs
- [ ] Metrics exportable per workspace

---

## Definition of Done
- [ ] MCP server responds to initialize, tools/list, tools/call
- [ ] API key authentication working
- [ ] Rate limiting enforced
- [ ] Tool framework extensible
- [ ] All errors properly formatted
- [ ] Request logging operational

## Technical Notes
- MCP SDK via npm @modelcontextprotocol/sdk
- JSON-RPC 2.0 over HTTP POST
- Rate limits: 100 requests/minute per API key
- Keys never logged, only hashes stored

## Related Files
- `src/mcp/server.ts` - Main MCP handler
- `src/mcp/auth.ts` - Authentication logic
- `src/mcp/tools/registry.ts` - Tool registration
- `src/mcp/errors.ts` - Error definitions
- `src/mcp/logging.ts` - Request logging
