# Epic 2.4: Sentiment + Urgency Scoring

## Methodology Guidance
**SPECTRA Phase**: Implementation/AI Feature
**Approach**: Derive priority signals from sentiment and urgency analysis
**Tools**: Claude API for sentiment, keyword detection for urgency

## Wave Context
**Wave**: 2 - AI Infrastructure + P0 Capabilities
**Priority**: P0 (enables smart prioritization)
**Dependencies**: Epic 2.1 (LLM integration), Epic 2.3 (classification)
**Estimated Duration**: 5 hours

## Quality Requirements
- Sentiment scores accurate to user perception
- Urgency detection catches blocking issues
- Combined priority score intuitive
- Scores visible and sortable in admin

---

## Tasks

### 2.4.1 Sentiment Analysis (2h)
**Objective**: Analyze emotional tone of feedback

**Steps**:
1. Extend classification to include sentiment:
   ```typescript
   // src/lib/ai/prompts/sentiment.ts

   export const SENTIMENT_PROMPT = `Analyze the sentiment of this user feedback.

   Consider:
   - Emotional tone (frustrated, happy, neutral, angry, hopeful)
   - Language intensity (strong words, caps, punctuation)
   - Overall attitude toward the product

   ## Feedback
   Title: {title}
   Description: {description}

   ## Response Format
   Return ONLY valid JSON:
   {
     "score": -1.0 to 1.0 (negative to positive),
     "label": "very_negative|negative|neutral|positive|very_positive",
     "emotions": ["frustrated", "hopeful", ...],
     "confidence": 0.0-1.0
   }`;
   ```

2. Create sentiment processor:
   ```typescript
   // src/lib/ai/processors/sentiment.ts

   interface SentimentResult {
     score: number;  // -1 to 1
     label: string;
     emotions: string[];
     confidence: number;
   }

   export async function processSentiment(
     feedbackId: string,
     env: Env
   ): Promise<void> {
     const feedback = await getFeedbackById(feedbackId, env);
     if (!feedback) throw new Error('Feedback not found');

     const prompt = SENTIMENT_PROMPT
       .replace('{title}', feedback.title)
       .replace('{description}', feedback.description || '');

     const result = await callClaudeAPI(prompt, env);

     let sentiment: SentimentResult;
     try {
       sentiment = JSON.parse(result);
     } catch (e) {
       console.error('Failed to parse sentiment:', e);
       return;
     }

     // Store sentiment score
     await env.DB.prepare(`
       UPDATE feedback_items
       SET
         sentiment_score = ?,
         sentiment_label = ?,
         sentiment_emotions = ?,
         updated_at = datetime('now')
       WHERE id = ?
     `).bind(
       sentiment.score,
       sentiment.label,
       JSON.stringify(sentiment.emotions),
       feedbackId
     ).run();

     await incrementUsage(env.DB, feedback.workspace_id, 'llm_calls');
   }
   ```

3. Add sentiment columns:
   ```sql
   ALTER TABLE feedback_items ADD COLUMN sentiment_score REAL;
   ALTER TABLE feedback_items ADD COLUMN sentiment_label TEXT;
   ALTER TABLE feedback_items ADD COLUMN sentiment_emotions TEXT;
   ```

4. Handle mixed sentiment:
   ```typescript
   // For longer feedback, analyze segments
   export async function analyzeSegmentedSentiment(
     text: string,
     env: Env
   ): Promise<{ overall: number; segments: Array<{ text: string; score: number }> }> {
     const sentences = text.split(/[.!?]+/).filter(s => s.trim());

     if (sentences.length <= 3) {
       const result = await analyzeSentiment(text, env);
       return { overall: result.score, segments: [] };
     }

     // Analyze key sentences
     const first = sentences[0];
     const last = sentences[sentences.length - 1];
     const middle = sentences[Math.floor(sentences.length / 2)];

     const results = await Promise.all([
       analyzeSentiment(first, env),
       analyzeSentiment(middle, env),
       analyzeSentiment(last, env)
     ]);

     const overall = results.reduce((sum, r) => sum + r.score, 0) / results.length;

     return {
       overall,
       segments: [
         { text: first, score: results[0].score },
         { text: middle, score: results[1].score },
         { text: last, score: results[2].score }
       ]
     };
   }
   ```

**Acceptance Criteria**:
- [ ] Sentiment score -1 to 1 range
- [ ] Labels match score (negative/neutral/positive)
- [ ] Emotions array populated
- [ ] Mixed sentiment handled appropriately

---

### 2.4.2 Urgency Detection (1.5h)
**Objective**: Identify high-priority issues from language

**Steps**:
1. Define urgency keywords:
   ```typescript
   // src/lib/ai/urgency.ts

   export const URGENCY_KEYWORDS = {
     critical: [
       'production', 'down', 'outage', 'critical', 'emergency',
       'data loss', 'security', 'breach', 'can\'t access', 'locked out'
     ],
     urgent: [
       'urgent', 'asap', 'immediately', 'blocking', 'can\'t work',
       'broken', 'stopped working', 'deadline', 'client waiting',
       'need this now', 'priority', 'showstopper'
     ],
     high: [
       'important', 'serious', 'major', 'significant',
       'affecting', 'multiple users', 'team', 'workaround'
     ]
   };

   export function detectUrgencyFromKeywords(text: string): {
     level: 'critical' | 'urgent' | 'high' | 'normal';
     matchedKeywords: string[];
     score: number;
   } {
     const lowerText = text.toLowerCase();
     const matched: string[] = [];

     // Check critical first
     for (const keyword of URGENCY_KEYWORDS.critical) {
       if (lowerText.includes(keyword)) {
         matched.push(keyword);
       }
     }
     if (matched.length > 0) {
       return { level: 'critical', matchedKeywords: matched, score: 1.0 };
     }

     // Check urgent
     for (const keyword of URGENCY_KEYWORDS.urgent) {
       if (lowerText.includes(keyword)) {
         matched.push(keyword);
       }
     }
     if (matched.length >= 2) {
       return { level: 'urgent', matchedKeywords: matched, score: 0.8 };
     }
     if (matched.length === 1) {
       return { level: 'high', matchedKeywords: matched, score: 0.6 };
     }

     // Check high
     for (const keyword of URGENCY_KEYWORDS.high) {
       if (lowerText.includes(keyword)) {
         matched.push(keyword);
       }
     }
     if (matched.length > 0) {
       return { level: 'high', matchedKeywords: matched, score: 0.4 };
     }

     return { level: 'normal', matchedKeywords: [], score: 0.0 };
   }
   ```

2. Combine with LLM urgency:
   ```typescript
   export async function processUrgency(
     feedbackId: string,
     env: Env
   ): Promise<void> {
     const feedback = await getFeedbackById(feedbackId, env);
     if (!feedback) throw new Error('Feedback not found');

     const text = `${feedback.title} ${feedback.description || ''}`;

     // Fast keyword detection
     const keywordResult = detectUrgencyFromKeywords(text);

     // Use LLM for nuanced detection if keywords suggest urgency
     let llmScore = 0;
     if (keywordResult.score > 0.3 || feedback.ai_classification) {
       const classification = JSON.parse(feedback.ai_classification || '{}');
       llmScore = classification.urgency === 'critical' ? 1.0 :
                  classification.urgency === 'urgent' ? 0.7 : 0;
     }

     // Combined score (max of both)
     const finalScore = Math.max(keywordResult.score, llmScore);

     await env.DB.prepare(`
       UPDATE feedback_items
       SET
         urgency_score = ?,
         urgency_keywords = ?,
         updated_at = datetime('now')
       WHERE id = ?
     `).bind(
       finalScore,
       JSON.stringify(keywordResult.matchedKeywords),
       feedbackId
     ).run();
   }
   ```

3. Add urgency columns:
   ```sql
   ALTER TABLE feedback_items ADD COLUMN urgency_score REAL DEFAULT 0;
   ALTER TABLE feedback_items ADD COLUMN urgency_keywords TEXT;
   ```

**Acceptance Criteria**:
- [ ] Critical keywords detected immediately
- [ ] Urgency score 0-1 scale
- [ ] Matched keywords stored for transparency
- [ ] Fast keyword check + optional LLM

---

### 2.4.3 Combined Priority Score (1h)
**Objective**: Single priority metric for sorting

**Steps**:
1. Define priority formula:
   ```typescript
   // src/lib/ai/priority.ts

   interface PriorityWeights {
     votes: number;      // Higher votes = more priority
     sentiment: number;  // Negative sentiment = more priority
     urgency: number;    // High urgency = more priority
     recency: number;    // Newer items get slight boost
   }

   const DEFAULT_WEIGHTS: PriorityWeights = {
     votes: 0.25,
     sentiment: 0.20,
     urgency: 0.45,
     recency: 0.10
   };

   export function calculatePriorityScore(
     feedback: {
       vote_count: number;
       sentiment_score: number | null;
       urgency_score: number | null;
       created_at: string;
     },
     weights: PriorityWeights = DEFAULT_WEIGHTS
   ): number {
     // Normalize votes (log scale, cap at 100)
     const voteScore = Math.min(Math.log10(feedback.vote_count + 1) / 2, 1);

     // Invert sentiment (negative = higher priority)
     const sentimentScore = feedback.sentiment_score !== null
       ? (1 - (feedback.sentiment_score + 1) / 2)  // Convert -1..1 to 1..0
       : 0.5;  // Neutral default

     // Urgency already 0-1
     const urgencyScore = feedback.urgency_score ?? 0;

     // Recency: decay over 30 days
     const ageInDays = (Date.now() - new Date(feedback.created_at).getTime()) / (1000 * 60 * 60 * 24);
     const recencyScore = Math.max(0, 1 - ageInDays / 30);

     // Weighted sum
     const raw = (
       voteScore * weights.votes +
       sentimentScore * weights.sentiment +
       urgencyScore * weights.urgency +
       recencyScore * weights.recency
     );

     // Normalize to 0-100
     return Math.round(raw * 100);
   }
   ```

2. Update priority on changes:
   ```typescript
   export async function updatePriorityScore(
     feedbackId: string,
     env: Env
   ): Promise<void> {
     const feedback = await env.DB.prepare(`
       SELECT vote_count, sentiment_score, urgency_score, created_at
       FROM feedback_items WHERE id = ?
     `).bind(feedbackId).first();

     if (!feedback) return;

     const score = calculatePriorityScore(feedback);

     await env.DB.prepare(`
       UPDATE feedback_items SET priority_score = ?, updated_at = datetime('now')
       WHERE id = ?
     `).bind(score, feedbackId).run();
   }
   ```

3. Add priority column and trigger recalculation:
   ```sql
   ALTER TABLE feedback_items ADD COLUMN priority_score INTEGER DEFAULT 0;

   CREATE INDEX idx_feedback_priority ON feedback_items(priority_score DESC)
     WHERE is_hidden = 0 AND moderation_state = 'approved';
   ```

4. Allow workspace-level weight customization:
   ```typescript
   // Store custom weights in workspace settings
   interface WorkspaceSettings {
     priority_weights?: PriorityWeights;
   }
   ```

**Acceptance Criteria**:
- [ ] Priority 0-100 scale
- [ ] Higher = more attention needed
- [ ] Weights configurable per workspace
- [ ] Score updates on vote/sentiment/urgency changes

---

### 2.4.4 Priority Sorting in Admin (0.5h)
**Objective**: Display and sort by priority

**Steps**:
1. Add priority to list endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/feedback?sort=priority

   const feedbackQuery = `
     SELECT
       fi.*,
       COALESCE(fi.priority_score, 0) as priority_score
     FROM feedback_items fi
     JOIN boards b ON fi.board_id = b.id
     WHERE b.workspace_id = ?
       AND fi.is_hidden = 0
       AND fi.moderation_state = 'approved'
     ORDER BY
       CASE WHEN ? = 'priority' THEN fi.priority_score END DESC,
       CASE WHEN ? = 'votes' THEN fi.vote_count END DESC,
       CASE WHEN ? = 'created_at' THEN fi.created_at END DESC
     LIMIT ? OFFSET ?
   `;
   ```

2. Add priority filter:
   ```typescript
   // Filter by priority range
   if (priority_min || priority_max) {
     query += ` AND fi.priority_score BETWEEN ? AND ?`;
     params.push(priority_min ?? 0, priority_max ?? 100);
   }

   // Filter for high-priority only
   if (high_priority_only) {
     query += ` AND fi.priority_score >= 70`;
   }
   ```

3. Return priority breakdown:
   ```typescript
   return jsonResponse({
     feedback: items.map(item => ({
       ...item,
       priority: {
         score: item.priority_score,
         breakdown: {
           votes_contribution: (Math.log10(item.vote_count + 1) / 2) * 25,
           sentiment_contribution: item.sentiment_score !== null
             ? (1 - (item.sentiment_score + 1) / 2) * 20
             : 10,
           urgency_contribution: (item.urgency_score ?? 0) * 45,
           recency_contribution: calculateRecencyScore(item.created_at) * 10
         }
       }
     }))
   });
   ```

**Acceptance Criteria**:
- [ ] Priority column in feedback list
- [ ] Sort by priority option
- [ ] Filter by priority range
- [ ] Visual priority indicators (color/icon)

---

## Definition of Done
- [ ] Sentiment analysis running on all feedback
- [ ] Urgency detection with keywords + LLM
- [ ] Combined priority score calculated
- [ ] Priority sortable and filterable
- [ ] Scores visible in admin UI

## Technical Notes
- Sentiment via LLM: ~$0.0005 per call
- Keyword detection is free and fast
- Priority recalculates on any score update
- Consider batch recalculation nightly

## Related Files
- `src/lib/ai/prompts/sentiment.ts` - Sentiment prompt
- `src/lib/ai/processors/sentiment.ts` - Sentiment processor
- `src/lib/ai/urgency.ts` - Urgency detection
- `src/lib/ai/priority.ts` - Priority calculation
