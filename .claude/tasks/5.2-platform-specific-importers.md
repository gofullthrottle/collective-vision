# Epic 5.2: Platform-Specific Importers

## Methodology Guidance
**SPECTRA Phase**: Implementation/Integration
**Approach**: Build importers for competitor platforms
**Tools**: External APIs, CSV parsing, field mapping

## Wave Context
**Wave**: 5 - Data Ingestion & Multi-Channel
**Priority**: P1 (migration path)
**Dependencies**: 5.1 (import infrastructure)
**Estimated Duration**: 10 hours

## Quality Requirements
- Preserve all data from source
- Map fields correctly
- Handle rate limits gracefully
- Support incremental imports

---

## Tasks

### 5.2.1 UserVoice Importer (3h)
**Objective**: Import feedback from UserVoice

**Steps**:
1. Create UserVoice API client:
   ```typescript
   // src/lib/import/uservoice.ts

   interface UserVoiceConfig {
     subdomain: string;
     api_key: string;
   }

   interface UserVoiceSuggestion {
     id: number;
     title: string;
     text: string;
     formatted_text: string;
     vote_count: number;
     comments_count: number;
     status: {
       id: number;
       name: string;
       hex_color: string;
     };
     creator: {
       id: number;
       name: string;
       email: string;
     };
     category: {
       id: number;
       name: string;
     } | null;
     created_at: string;
     updated_at: string;
     links: {
       portal: string;
     };
   }

   interface UserVoiceComment {
     id: number;
     text: string;
     creator: {
       name: string;
       email: string;
     };
     created_at: string;
     is_admin_comment: boolean;
   }

   export class UserVoiceImporter {
     private baseUrl: string;
     private headers: Headers;

     constructor(config: UserVoiceConfig) {
       this.baseUrl = `https://${config.subdomain}.uservoice.com/api/v1`;
       this.headers = new Headers({
         'Authorization': `Bearer ${config.api_key}`,
         'Content-Type': 'application/json'
       });
     }

     async fetchSuggestions(page: number = 1, perPage: number = 100): Promise<{
       suggestions: UserVoiceSuggestion[];
       totalPages: number;
     }> {
       const response = await fetch(
         `${this.baseUrl}/suggestions.json?page=${page}&per_page=${perPage}&sort=newest`,
         { headers: this.headers }
       );

       if (!response.ok) {
         throw new Error(`UserVoice API error: ${response.status}`);
       }

       const data = await response.json();
       return {
         suggestions: data.suggestions,
         totalPages: Math.ceil(data.total_records / perPage)
       };
     }

     async fetchComments(suggestionId: number): Promise<UserVoiceComment[]> {
       const response = await fetch(
         `${this.baseUrl}/suggestions/${suggestionId}/comments.json`,
         { headers: this.headers }
       );

       if (!response.ok) {
         return [];  // Comments might not exist
       }

       const data = await response.json();
       return data.comments || [];
     }

     async fetchAllSuggestions(): Promise<ImportItem[]> {
       const allSuggestions: ImportItem[] = [];
       let page = 1;
       let totalPages = 1;

       do {
         const { suggestions, totalPages: tp } = await this.fetchSuggestions(page);
         totalPages = tp;

         for (const s of suggestions) {
           // Fetch comments for each suggestion
           const comments = await this.fetchComments(s.id);

           allSuggestions.push({
             source_type: 'uservoice',
             source_id: String(s.id),
             source_url: s.links.portal,
             title: s.title,
             description: s.formatted_text || s.text,
             votes: s.vote_count,
             status: mapUserVoiceStatus(s.status?.name),
             category: s.category?.name,
             created_at: s.created_at,
             author: {
               external_id: String(s.creator.id),
               name: s.creator.name,
               email: s.creator.email
             },
             comments: comments.map(c => ({
               content: c.text,
               is_internal: c.is_admin_comment,
               created_at: c.created_at,
               author_name: c.creator.name
             })),
             source_metadata: {
               original_status: s.status,
               updated_at: s.updated_at
             }
           });

           // Rate limit: 100ms between requests
           await new Promise(r => setTimeout(r, 100));
         }

         page++;
       } while (page <= totalPages);

       return allSuggestions;
     }
   }

   function mapUserVoiceStatus(uvStatus: string | undefined): string {
     const mapping: Record<string, string> = {
       'Under Review': 'reviewing',
       'Planned': 'planned',
       'Started': 'in_progress',
       'Completed': 'completed',
       'Declined': 'declined',
       'Already Exists': 'duplicate'
     };
     return mapping[uvStatus || ''] || 'new';
   }
   ```

2. Create UserVoice import handler:
   ```typescript
   // Integration with import infrastructure
   export async function fetchUserVoiceItems(
     credentials: { api_key: string; subdomain: string }
   ): Promise<ImportItem[]> {
     const importer = new UserVoiceImporter({
       subdomain: credentials.subdomain,
       api_key: credentials.api_key
     });

     return importer.fetchAllSuggestions();
   }
   ```

**Acceptance Criteria**:
- [ ] All suggestions imported
- [ ] Vote counts preserved
- [ ] Comments included
- [ ] Status mapped correctly

---

### 5.2.2 Canny Importer (3h)
**Objective**: Import feedback from Canny

**Steps**:
1. Create Canny API client:
   ```typescript
   // src/lib/import/canny.ts

   interface CannyConfig {
     api_key: string;
   }

   interface CannyPost {
     id: string;
     title: string;
     details: string;
     score: number;
     commentCount: number;
     status: string;
     statusChangedAt: string;
     author: {
       id: string;
       name: string;
       email: string;
       avatarURL: string;
     };
     board: {
       id: string;
       name: string;
     };
     category: {
       id: string;
       name: string;
     } | null;
     tags: Array<{ id: string; name: string }>;
     url: string;
     created: string;
   }

   interface CannyComment {
     id: string;
     value: string;
     author: {
       id: string;
       name: string;
       email: string;
     };
     internal: boolean;
     created: string;
   }

   export class CannyImporter {
     private apiKey: string;

     constructor(config: CannyConfig) {
       this.apiKey = config.api_key;
     }

     private async request(endpoint: string, body: Record<string, unknown> = {}): Promise<unknown> {
       const response = await fetch(`https://canny.io/api/v1${endpoint}`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ apiKey: this.apiKey, ...body })
       });

       if (!response.ok) {
         throw new Error(`Canny API error: ${response.status}`);
       }

       return response.json();
     }

     async fetchPosts(boardId?: string, skip: number = 0): Promise<{
       posts: CannyPost[];
       hasMore: boolean;
     }> {
       const params: Record<string, unknown> = { limit: 100, skip };
       if (boardId) params.boardID = boardId;

       const data = await this.request('/posts/list', params) as {
         posts: CannyPost[];
         hasMore: boolean;
       };

       return data;
     }

     async fetchComments(postId: string): Promise<CannyComment[]> {
       const data = await this.request('/comments/list', { postID: postId }) as {
         comments: CannyComment[];
       };
       return data.comments || [];
     }

     async fetchBoards(): Promise<Array<{ id: string; name: string }>> {
       const data = await this.request('/boards/list') as {
         boards: Array<{ id: string; name: string }>;
       };
       return data.boards;
     }

     async fetchAllPosts(boardId?: string): Promise<ImportItem[]> {
       const allPosts: ImportItem[] = [];
       let skip = 0;
       let hasMore = true;

       while (hasMore) {
         const { posts, hasMore: more } = await this.fetchPosts(boardId, skip);
         hasMore = more;
         skip += posts.length;

         for (const p of posts) {
           // Fetch comments for each post
           const comments = await this.fetchComments(p.id);

           allPosts.push({
             source_type: 'canny',
             source_id: p.id,
             source_url: p.url,
             title: p.title,
             description: p.details,
             votes: p.score,
             status: mapCannyStatus(p.status),
             category: p.category?.name,
             tags: p.tags.map(t => t.name),
             created_at: p.created,
             author: {
               external_id: p.author.id,
               name: p.author.name,
               email: p.author.email,
               avatar_url: p.author.avatarURL
             },
             comments: comments.map(c => ({
               content: c.value,
               is_internal: c.internal,
               created_at: c.created,
               author_name: c.author.name
             })),
             source_metadata: {
               board: p.board,
               status_changed_at: p.statusChangedAt,
               comment_count: p.commentCount
             }
           });

           // Rate limit
           await new Promise(r => setTimeout(r, 50));
         }
       }

       return allPosts;
     }
   }

   function mapCannyStatus(cannyStatus: string): string {
     const mapping: Record<string, string> = {
       'open': 'new',
       'under review': 'reviewing',
       'planned': 'planned',
       'in progress': 'in_progress',
       'complete': 'completed',
       'closed': 'declined'
     };
     return mapping[cannyStatus.toLowerCase()] || 'new';
   }
   ```

2. Create Canny import handler:
   ```typescript
   export async function fetchCannyItems(
     credentials: { api_key: string; board_id?: string }
   ): Promise<ImportItem[]> {
     const importer = new CannyImporter({ api_key: credentials.api_key });
     return importer.fetchAllPosts(credentials.board_id);
   }
   ```

**Acceptance Criteria**:
- [ ] All posts imported
- [ ] Score (votes) preserved
- [ ] Internal comments marked
- [ ] Tags imported

---

### 5.2.3 Productboard Importer (2h)
**Objective**: Import feedback from Productboard

**Steps**:
1. Create Productboard API client:
   ```typescript
   // src/lib/import/productboard.ts

   interface ProductboardConfig {
     api_token: string;
   }

   interface ProductboardNote {
     id: string;
     title: string;
     content: string;
     createdAt: string;
     updatedAt: string;
     state: string;
     importance: number;
     user: {
       id: string;
       email: string;
       name: string;
     } | null;
     company: {
       id: string;
       name: string;
     } | null;
     tags: string[];
     features: Array<{
       id: string;
       name: string;
     }>;
   }

   export class ProductboardImporter {
     private headers: Headers;

     constructor(config: ProductboardConfig) {
       this.headers = new Headers({
         'Authorization': `Bearer ${config.api_token}`,
         'Content-Type': 'application/json',
         'X-Version': '1'
       });
     }

     async fetchNotes(cursor?: string): Promise<{
       notes: ProductboardNote[];
       nextCursor?: string;
     }> {
       const url = new URL('https://api.productboard.com/notes');
       url.searchParams.set('pageLimit', '100');
       if (cursor) url.searchParams.set('pageCursor', cursor);

       const response = await fetch(url.toString(), { headers: this.headers });

       if (!response.ok) {
         throw new Error(`Productboard API error: ${response.status}`);
       }

       const data = await response.json();
       return {
         notes: data.data,
         nextCursor: data.links?.next ? new URL(data.links.next).searchParams.get('pageCursor') || undefined : undefined
       };
     }

     async fetchAllNotes(): Promise<ImportItem[]> {
       const allNotes: ImportItem[] = [];
       let cursor: string | undefined;

       do {
         const { notes, nextCursor } = await this.fetchNotes(cursor);
         cursor = nextCursor;

         for (const n of notes) {
           allNotes.push({
             source_type: 'productboard',
             source_id: n.id,
             title: n.title || 'Untitled Note',
             description: n.content,
             status: mapProductboardState(n.state),
             priority: mapProductboardImportance(n.importance),
             tags: n.tags,
             created_at: n.createdAt,
             author: n.user ? {
               external_id: n.user.id,
               name: n.user.name,
               email: n.user.email
             } : undefined,
             source_metadata: {
               company: n.company,
               features: n.features,
               importance: n.importance,
               updated_at: n.updatedAt
             }
           });
         }

         // Rate limit: Productboard has strict limits
         await new Promise(r => setTimeout(r, 200));
       } while (cursor);

       return allNotes;
     }
   }

   function mapProductboardState(state: string): string {
     const mapping: Record<string, string> = {
       'unprocessed': 'new',
       'processed': 'reviewing',
       'archived': 'archived'
     };
     return mapping[state] || 'new';
   }

   function mapProductboardImportance(importance: number): number {
     // Productboard uses 0-3 scale, we use 0-100
     return Math.round(importance * 33.33);
   }
   ```

**Acceptance Criteria**:
- [ ] Notes imported as feedback
- [ ] Company context preserved
- [ ] Feature links stored in metadata
- [ ] Importance mapped to priority

---

### 5.2.4 Generic CSV Importer (2h)
**Objective**: Import from any CSV file

**Steps**:
1. Create CSV parser and mapper:
   ```typescript
   // src/lib/import/csv.ts

   interface CSVMapping {
     title: string;           // Column name for title
     description?: string;    // Column name for description
     votes?: string;          // Column name for vote count
     status?: string;         // Column name for status
     category?: string;       // Column name for category
     tags?: string;           // Column name for tags (comma-separated)
     author_name?: string;    // Column name for author name
     author_email?: string;   // Column name for author email
     created_at?: string;     // Column name for creation date
     source_id?: string;      // Column name for original ID
   }

   interface CSVImportConfig {
     mapping: CSVMapping;
     delimiter?: string;      // Default: ','
     has_header?: boolean;    // Default: true
     date_format?: string;    // Default: ISO 8601
     status_mapping?: Record<string, string>;
   }

   export async function parseCSVImport(
     env: Env,
     fileId: string,
     sourceType: 'csv' | 'json'
   ): Promise<ImportItem[]> {
     // Fetch file from R2
     const file = await env.R2.get(fileId);
     if (!file) {
       throw new Error(`Import file not found: ${fileId}`);
     }

     const content = await file.text();

     if (sourceType === 'json') {
       return parseJSONImport(content);
     }

     return parseCSV(content);
   }

   function parseCSV(content: string, config?: CSVImportConfig): ImportItem[] {
     const lines = content.split('\n').filter(l => l.trim());
     if (lines.length === 0) return [];

     const delimiter = config?.delimiter || ',';
     const hasHeader = config?.has_header !== false;

     // Parse header
     const header = hasHeader
       ? parseCSVLine(lines[0], delimiter)
       : null;

     const dataLines = hasHeader ? lines.slice(1) : lines;
     const mapping = config?.mapping || autoDetectMapping(header);

     return dataLines.map((line, index) => {
       const values = parseCSVLine(line, delimiter);
       const row = header
         ? Object.fromEntries(header.map((h, i) => [h, values[i] || '']))
         : Object.fromEntries(values.map((v, i) => [String(i), v]));

       return {
         source_type: 'csv',
         source_id: row[mapping.source_id] || String(index + 1),
         title: row[mapping.title] || 'Untitled',
         description: mapping.description ? row[mapping.description] : undefined,
         votes: mapping.votes ? parseInt(row[mapping.votes]) || 0 : 0,
         status: mapping.status
           ? (config?.status_mapping?.[row[mapping.status]] || row[mapping.status] || 'new')
           : 'new',
         category: mapping.category ? row[mapping.category] : undefined,
         tags: mapping.tags ? row[mapping.tags]?.split(',').map(t => t.trim()) : undefined,
         created_at: mapping.created_at ? parseDate(row[mapping.created_at]) : undefined,
         author: (mapping.author_name || mapping.author_email) ? {
           name: mapping.author_name ? row[mapping.author_name] : undefined,
           email: mapping.author_email ? row[mapping.author_email] : undefined
         } : undefined
       };
     });
   }

   function parseCSVLine(line: string, delimiter: string): string[] {
     const values: string[] = [];
     let current = '';
     let inQuotes = false;

     for (let i = 0; i < line.length; i++) {
       const char = line[i];

       if (char === '"') {
         if (inQuotes && line[i + 1] === '"') {
           current += '"';
           i++;
         } else {
           inQuotes = !inQuotes;
         }
       } else if (char === delimiter && !inQuotes) {
         values.push(current.trim());
         current = '';
       } else {
         current += char;
       }
     }

     values.push(current.trim());
     return values;
   }

   function autoDetectMapping(header: string[] | null): CSVMapping {
     if (!header) {
       return { title: '0' };
     }

     const lowerHeader = header.map(h => h.toLowerCase());

     const findColumn = (patterns: string[]): string | undefined => {
       for (const pattern of patterns) {
         const index = lowerHeader.findIndex(h =>
           h.includes(pattern) || pattern.includes(h)
         );
         if (index !== -1) return header[index];
       }
       return undefined;
     };

     return {
       title: findColumn(['title', 'name', 'subject', 'summary']) || header[0],
       description: findColumn(['description', 'body', 'content', 'details', 'text']),
       votes: findColumn(['votes', 'score', 'upvotes', 'count']),
       status: findColumn(['status', 'state']),
       category: findColumn(['category', 'type', 'area']),
       tags: findColumn(['tags', 'labels']),
       author_name: findColumn(['author', 'user', 'name', 'submitter', 'reporter']),
       author_email: findColumn(['email', 'mail']),
       created_at: findColumn(['created', 'date', 'timestamp', 'submitted']),
       source_id: findColumn(['id', 'ticket', 'number'])
     };
   }

   function parseDate(dateStr: string): string | undefined {
     if (!dateStr) return undefined;

     try {
       const date = new Date(dateStr);
       if (isNaN(date.getTime())) return undefined;
       return date.toISOString();
     } catch {
       return undefined;
     }
   }
   ```

2. Create JSON import support:
   ```typescript
   function parseJSONImport(content: string): ImportItem[] {
     const data = JSON.parse(content);
     const items = Array.isArray(data) ? data : data.items || data.feedback || [];

     return items.map((item: Record<string, unknown>, index: number) => ({
       source_type: 'json',
       source_id: String(item.id || item.source_id || index + 1),
       title: String(item.title || item.name || item.subject || 'Untitled'),
       description: item.description || item.body || item.content,
       votes: typeof item.votes === 'number' ? item.votes : 0,
       status: item.status || 'new',
       category: item.category || item.type,
       tags: Array.isArray(item.tags) ? item.tags : undefined,
       created_at: item.created_at || item.createdAt || item.date,
       author: item.author || item.user ? {
         name: (item.author || item.user)?.name,
         email: (item.author || item.user)?.email,
         external_id: (item.author || item.user)?.id
       } : undefined,
       source_metadata: item.metadata || item.extra
     }));
   }
   ```

3. Create file upload endpoint:
   ```typescript
   // POST /api/v1/workspaces/:id/imports/upload
   async function handleUploadImportFile(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);

     await requirePermission(request, env, workspaceId, 'imports:create');

     const formData = await request.formData();
     const file = formData.get('file') as File | null;

     if (!file) {
       return errorResponse('BAD_REQUEST', 'No file provided', 400);
     }

     // Validate file type
     const fileName = file.name.toLowerCase();
     if (!fileName.endsWith('.csv') && !fileName.endsWith('.json')) {
       return errorResponse('BAD_REQUEST', 'Only CSV and JSON files are supported', 400);
     }

     // Check file size (max 10MB)
     if (file.size > 10 * 1024 * 1024) {
       return errorResponse('BAD_REQUEST', 'File size exceeds 10MB limit', 400);
     }

     // Upload to R2
     const fileId = `imports/${workspaceId}/${generateId('file')}_${file.name}`;
     await env.R2.put(fileId, await file.arrayBuffer(), {
       httpMetadata: { contentType: file.type }
     });

     // Preview first 5 rows
     const content = await file.text();
     const lines = content.split('\n').slice(0, 6);
     const preview = fileName.endsWith('.csv')
       ? parseCSV(lines.join('\n')).slice(0, 5)
       : JSON.parse(content).slice?.(0, 5) || [];

     return jsonResponse({
       file_id: fileId,
       file_name: file.name,
       file_size: file.size,
       detected_type: fileName.endsWith('.csv') ? 'csv' : 'json',
       preview,
       suggested_mapping: fileName.endsWith('.csv')
         ? autoDetectMapping(parseCSVLine(lines[0], ','))
         : null
     });
   }
   ```

**Acceptance Criteria**:
- [ ] CSV parsing handles quotes and escapes
- [ ] Auto-detects column mappings
- [ ] JSON import flexible
- [ ] Preview before import

---

## Definition of Done
- [ ] UserVoice import working
- [ ] Canny import working
- [ ] Productboard import working
- [ ] CSV/JSON import working
- [ ] All importers respect rate limits
- [ ] Field mapping documented

## Technical Notes
- Rate limits vary by platform
- Preserve original IDs for dedup
- Comments imported with items
- Votes aggregated correctly

## Related Files
- `src/lib/import/uservoice.ts` - UserVoice client
- `src/lib/import/canny.ts` - Canny client
- `src/lib/import/productboard.ts` - Productboard client
- `src/lib/import/csv.ts` - CSV/JSON parser
