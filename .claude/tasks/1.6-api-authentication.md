# Epic 1.6: API Authentication

## Methodology Guidance
**SPECTRA Phase**: Implementation/API Security
**Approach**: API key management with scopes and tracking
**Tools**: Secure random key generation, SHA256 hashing

## Wave Context
**Wave**: 1 - Authentication & User Management
**Priority**: High (enables integrations and MCP)
**Dependencies**: Epic 1.1 (database), Epic 1.2 (auth)
**Estimated Duration**: 3 hours

## Quality Requirements
- API keys never stored in plain text
- Keys only shown once on creation
- Usage tracking for all API key requests
- Audit logging for security events

---

## Tasks

### 1.6.1 API Key Generation (1h)
**Objective**: Create and manage API keys for programmatic access

**Steps**:
1. Create API key generation utility:
   ```typescript
   // src/lib/auth/api-keys.ts

   export function generateApiKey(): { key: string; prefix: string; hash: string } {
     // Generate 32-byte random key
     const randomBytes = crypto.getRandomValues(new Uint8Array(32));
     const key = 'cv_live_' + base64UrlEncode(randomBytes);

     // Store only hash
     const hash = await sha256(key);

     // Prefix for identification (first 12 chars of full key)
     const prefix = key.substring(0, 12);

     return { key, prefix, hash };
   }

   export async function verifyApiKey(
     key: string,
     env: Env
   ): Promise<ApiKey | null> {
     const hash = await sha256(key);

     const apiKey = await env.DB.prepare(`
       SELECT * FROM api_keys
       WHERE key_hash = ?
         AND revoked_at IS NULL
         AND (expires_at IS NULL OR expires_at > datetime('now'))
     `).bind(hash).first();

     if (!apiKey) return null;

     // Update last used
     await env.DB.prepare(
       'UPDATE api_keys SET last_used_at = datetime(\'now\') WHERE id = ?'
     ).bind(apiKey.id).run();

     return apiKey;
   }
   ```

2. Create API key management endpoints:
   ```typescript
   // POST /api/v1/api-keys
   const createKeySchema = z.object({
     name: z.string().min(1).max(100),
     workspace_id: z.string().optional(),
     scopes: z.array(z.enum(['read', 'write', 'admin'])).optional(),
     expires_in_days: z.number().min(1).max(365).optional()
   });

   async function handleCreateApiKey(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const { name, workspace_id, scopes, expires_in_days } = await validateBody(
       request, createKeySchema
     );

     // If workspace-scoped, verify admin access
     if (workspace_id) {
       await requirePermission(request, env, workspace_id, 'api_keys:create');
     }

     // Generate key
     const { key, prefix, hash } = generateApiKey();
     const keyId = generateId('key');

     const expiresAt = expires_in_days
       ? new Date(Date.now() + expires_in_days * 24 * 60 * 60 * 1000).toISOString()
       : null;

     await env.DB.prepare(`
       INSERT INTO api_keys (id, user_id, workspace_id, name, key_prefix, key_hash, scopes, expires_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
     `).bind(
       keyId,
       user.id,
       workspace_id || null,
       name,
       prefix,
       hash,
       JSON.stringify(scopes || ['read', 'write']),
       expiresAt
     ).run();

     // Audit log
     await logAuditEvent('api_key.created', user.id, workspace_id, {
       key_id: keyId,
       key_prefix: prefix,
       scopes: scopes || ['read', 'write']
     }, env);

     return jsonResponse({
       id: keyId,
       name,
       key, // ONLY SHOWN ONCE!
       prefix,
       scopes: scopes || ['read', 'write'],
       expires_at: expiresAt,
       created_at: new Date().toISOString()
     }, 201);
   }
   ```

3. List API keys endpoint:
   ```typescript
   // GET /api/v1/api-keys
   async function handleListApiKeys(request: Request, env: Env) {
     const user = await requireAuth(request, env);
     const url = new URL(request.url);
     const workspaceId = url.searchParams.get('workspace_id');

     let query = `
       SELECT id, name, key_prefix, scopes, workspace_id, last_used_at, expires_at, created_at
       FROM api_keys
       WHERE user_id = ? AND revoked_at IS NULL
     `;
     const params = [user.id];

     if (workspaceId) {
       query += ' AND workspace_id = ?';
       params.push(workspaceId);
     }

     query += ' ORDER BY created_at DESC';

     const keys = await env.DB.prepare(query).bind(...params).all();

     return jsonResponse({
       api_keys: keys.results.map(k => ({
         ...k,
         scopes: JSON.parse(k.scopes as string)
       }))
     });
   }
   ```

4. Revoke API key endpoint:
   ```typescript
   // DELETE /api/v1/api-keys/:id
   async function handleRevokeApiKey(request: Request, env: Env) {
     const { keyId } = parseParams(request);
     const user = await requireAuth(request, env);

     // Verify ownership
     const apiKey = await env.DB.prepare(
       'SELECT * FROM api_keys WHERE id = ? AND user_id = ?'
     ).bind(keyId, user.id).first();

     if (!apiKey) {
       return errorResponse('NOT_FOUND', 'API key not found', 404);
     }

     // Soft revoke (keep for audit trail)
     await env.DB.prepare(
       'UPDATE api_keys SET revoked_at = datetime(\'now\') WHERE id = ?'
     ).bind(keyId).run();

     // Audit log
     await logAuditEvent('api_key.revoked', user.id, apiKey.workspace_id, {
       key_id: keyId,
       key_prefix: apiKey.key_prefix
     }, env);

     return jsonResponse({ message: 'API key revoked' });
   }
   ```

**Acceptance Criteria**:
- [ ] Key only shown on creation
- [ ] Keys can be scoped to workspace
- [ ] Optional expiry supported
- [ ] Revocation soft-deletes

---

### 1.6.2 API Key Authentication (1h)
**Objective**: Accept API keys for authentication alongside JWT

**Steps**:
1. Update auth middleware to support API keys:
   ```typescript
   // src/middleware/auth.ts

   export async function requireAuth(
     request: Request,
     env: Env
   ): Promise<AuthContext> {
     const authHeader = request.headers.get('Authorization');

     if (!authHeader?.startsWith('Bearer ')) {
       throw new AuthError('UNAUTHORIZED', 'Authentication required', 401);
     }

     const token = authHeader.slice(7);

     // Check if it's an API key (starts with cv_live_ or cv_test_)
     if (token.startsWith('cv_live_') || token.startsWith('cv_test_')) {
       const apiKey = await verifyApiKey(token, env);

       if (!apiKey) {
         throw new AuthError('UNAUTHORIZED', 'Invalid API key', 401);
       }

       const user = await getUserById(apiKey.user_id, env);
       if (!user) {
         throw new AuthError('UNAUTHORIZED', 'User not found', 401);
       }

       return {
         user,
         authMethod: 'api_key',
         apiKey: {
           id: apiKey.id,
           scopes: JSON.parse(apiKey.scopes as string),
           workspaceId: apiKey.workspace_id
         }
       };
     }

     // Otherwise, try JWT
     try {
       const payload = await verifyJWT(token, env.JWT_SECRET);
       const user = await getUserById(payload.sub, env);

       if (!user) {
         throw new AuthError('UNAUTHORIZED', 'User not found', 401);
       }

       return {
         user,
         authMethod: 'jwt',
         apiKey: null
       };
     } catch {
       throw new AuthError('UNAUTHORIZED', 'Invalid token', 401);
     }
   }
   ```

2. Add scope checking:
   ```typescript
   export function requireScope(
     authContext: AuthContext,
     requiredScope: 'read' | 'write' | 'admin'
   ): void {
     if (authContext.authMethod !== 'api_key') {
       return; // JWT has full access
     }

     const scopes = authContext.apiKey!.scopes;
     const scopeHierarchy = { read: 1, write: 2, admin: 3 };

     const hasScope = scopes.some(
       s => scopeHierarchy[s] >= scopeHierarchy[requiredScope]
     );

     if (!hasScope) {
       throw new AuthError(
         'INSUFFICIENT_SCOPE',
         `API key requires '${requiredScope}' scope`,
         403
       );
     }
   }
   ```

3. Add rate limiting per key:
   ```typescript
   // Rate limiting specific to API keys
   export async function checkApiKeyRateLimit(
     apiKeyId: string,
     env: Env
   ): Promise<{ allowed: boolean; remaining: number }> {
     const key = `ratelimit:apikey:${apiKeyId}`;
     const window = 60; // 1 minute
     const limit = 100; // requests per minute

     // Use KV for distributed rate limiting
     const current = await env.KV.get(key, 'json') as { count: number } | null;

     if (!current) {
       await env.KV.put(key, JSON.stringify({ count: 1 }), { expirationTtl: window });
       return { allowed: true, remaining: limit - 1 };
     }

     if (current.count >= limit) {
       return { allowed: false, remaining: 0 };
     }

     await env.KV.put(key, JSON.stringify({ count: current.count + 1 }), { expirationTtl: window });
     return { allowed: true, remaining: limit - current.count - 1 };
   }
   ```

**Acceptance Criteria**:
- [ ] API keys work alongside JWT auth
- [ ] Invalid keys return 401
- [ ] Scope enforcement working
- [ ] Rate limiting per key

---

### 1.6.3 Audit Logging (1h)
**Objective**: Log security-relevant events for compliance

**Steps**:
1. Create audit logging utility:
   ```typescript
   // src/lib/audit/logger.ts

   export type AuditAction =
     | 'user.login'
     | 'user.logout'
     | 'user.login_failed'
     | 'user.password_changed'
     | 'user.email_changed'
     | 'user.deleted'
     | 'api_key.created'
     | 'api_key.revoked'
     | 'api_key.used'
     | 'team.member_added'
     | 'team.member_removed'
     | 'team.role_changed'
     | 'workspace.created'
     | 'workspace.deleted'
     | 'workspace.settings_changed'
     | 'feedback.moderated'
     | 'feedback.deleted';

   export async function logAuditEvent(
     action: AuditAction,
     userId: string | null,
     workspaceId: string | null,
     details: Record<string, any>,
     env: Env,
     request?: Request
   ): Promise<void> {
     const id = generateId('audit');

     // Extract request metadata safely
     const ipAddress = request?.headers.get('CF-Connecting-IP') || null;
     const userAgent = request?.headers.get('User-Agent')?.substring(0, 200) || null;

     // Sanitize details (remove any sensitive data)
     const sanitizedDetails = sanitizeAuditDetails(details);

     await env.DB.prepare(`
       INSERT INTO audit_logs (id, user_id, workspace_id, action, resource_type, resource_id, ip_address, user_agent, details)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
     `).bind(
       id,
       userId,
       workspaceId,
       action,
       details.resource_type || null,
       details.resource_id || null,
       ipAddress,
       userAgent,
       JSON.stringify(sanitizedDetails)
     ).run();
   }

   function sanitizeAuditDetails(details: Record<string, any>): Record<string, any> {
     const sanitized = { ...details };

     // Remove sensitive fields
     delete sanitized.password;
     delete sanitized.token;
     delete sanitized.api_key;
     delete sanitized.secret;

     return sanitized;
   }
   ```

2. Create audit log query endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/audit-logs
   async function handleGetAuditLogs(request: Request, env: Env) {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'workspace:settings');

     const url = new URL(request.url);
     const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 100);
     const offset = parseInt(url.searchParams.get('offset') || '0');
     const action = url.searchParams.get('action');

     let query = `
       SELECT al.*, u.email as user_email, u.name as user_name
       FROM audit_logs al
       LEFT JOIN users u ON al.user_id = u.id
       WHERE al.workspace_id = ?
     `;
     const params: any[] = [workspaceId];

     if (action) {
       query += ' AND al.action = ?';
       params.push(action);
     }

     query += ' ORDER BY al.created_at DESC LIMIT ? OFFSET ?';
     params.push(limit, offset);

     const logs = await env.DB.prepare(query).bind(...params).all();

     return jsonResponse({
       logs: logs.results.map(log => ({
         ...log,
         details: JSON.parse(log.details as string)
       })),
       pagination: { limit, offset }
     });
   }
   ```

3. Add audit logging to key operations:
   - Login success/failure
   - Password change
   - API key creation/revocation
   - Team member changes
   - Permission denials

**Acceptance Criteria**:
- [ ] Security events logged
- [ ] No passwords/tokens in logs
- [ ] Logs queryable by workspace
- [ ] IP address and user agent captured

---

## Definition of Done
- [ ] API key generation and revocation working
- [ ] API key authentication alongside JWT
- [ ] Scope enforcement in place
- [ ] Rate limiting per key
- [ ] Audit logging comprehensive
- [ ] Tests cover API key flows

## Technical Notes
- Use KV for distributed rate limiting across Workers
- Consider log retention policy (90 days default)
- API keys should use test_ prefix in development
- Consider key rotation reminders before expiry

## Related Files
- `src/lib/auth/api-keys.ts` - API key utilities
- `src/lib/audit/logger.ts` - Audit logging
- `src/routes/api-keys.ts` - API key endpoints
- `src/routes/audit.ts` - Audit log endpoints
