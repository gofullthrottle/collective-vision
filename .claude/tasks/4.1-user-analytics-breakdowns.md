# Epic 4.1: User Analytics Breakdowns

## Methodology Guidance
**SPECTRA Phase**: Implementation/Analytics
**Approach**: Build privacy-respecting user analytics
**Tools**: D1 aggregations, scheduled workers

## Wave Context
**Wave**: 4 - Analytics & Integrations
**Priority**: P2 (enhances value prop)
**Dependencies**: Wave 1 (auth for user tracking)
**Estimated Duration**: 6 hours

## Quality Requirements
- Privacy-respecting aggregation (no PII exposure)
- Historical data preserved indefinitely
- Efficient queries for dashboard display
- Power users accurately identified

---

## Tasks

### 4.1.1 Voter Demographics (1.5h)
**Objective**: Track aggregated user metadata for insights

**Steps**:
1. Create analytics tables:
   ```sql
   CREATE TABLE user_analytics (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     date TEXT NOT NULL,  -- YYYY-MM-DD
     new_voters INTEGER DEFAULT 0,
     returning_voters INTEGER DEFAULT 0,
     new_submitters INTEGER DEFAULT 0,
     returning_submitters INTEGER DEFAULT 0,
     total_votes INTEGER DEFAULT 0,
     total_submissions INTEGER DEFAULT 0,
     unique_voters INTEGER DEFAULT 0,
     unique_submitters INTEGER DEFAULT 0,
     UNIQUE(workspace_id, date),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   CREATE INDEX idx_user_analytics_workspace_date ON user_analytics(workspace_id, date);
   ```

2. Create daily aggregation worker:
   ```typescript
   // src/lib/analytics/aggregator.ts

   export async function aggregateUserAnalytics(
     workspaceId: string,
     date: string,  // YYYY-MM-DD
     env: Env
   ): Promise<void> {
     // Get yesterday's date for comparison
     const yesterday = new Date(date);
     yesterday.setDate(yesterday.getDate() - 1);
     const yesterdayStr = yesterday.toISOString().split('T')[0];

     // Count new vs returning voters
     const voterStats = await env.DB.prepare(`
       WITH today_voters AS (
         SELECT DISTINCT fv.user_id
         FROM feedback_votes fv
         JOIN feedback_items fi ON fv.feedback_id = fi.id
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND DATE(fv.created_at) = ?
       ),
       previous_voters AS (
         SELECT DISTINCT fv.user_id
         FROM feedback_votes fv
         JOIN feedback_items fi ON fv.feedback_id = fi.id
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND DATE(fv.created_at) < ?
       )
       SELECT
         COUNT(CASE WHEN pv.user_id IS NULL THEN 1 END) as new_voters,
         COUNT(CASE WHEN pv.user_id IS NOT NULL THEN 1 END) as returning_voters,
         COUNT(*) as unique_voters
       FROM today_voters tv
       LEFT JOIN previous_voters pv ON tv.user_id = pv.user_id
     `).bind(workspaceId, date, workspaceId, date).first();

     // Count new vs returning submitters
     const submitterStats = await env.DB.prepare(`
       WITH today_submitters AS (
         SELECT DISTINCT fi.user_id
         FROM feedback_items fi
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND DATE(fi.created_at) = ?
       ),
       previous_submitters AS (
         SELECT DISTINCT fi.user_id
         FROM feedback_items fi
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
           AND DATE(fi.created_at) < ?
       )
       SELECT
         COUNT(CASE WHEN ps.user_id IS NULL THEN 1 END) as new_submitters,
         COUNT(CASE WHEN ps.user_id IS NOT NULL THEN 1 END) as returning_submitters,
         COUNT(*) as unique_submitters
       FROM today_submitters ts
       LEFT JOIN previous_submitters ps ON ts.user_id = ps.user_id
     `).bind(workspaceId, date, workspaceId, date).first();

     // Total activity counts
     const totals = await env.DB.prepare(`
       SELECT
         (SELECT COUNT(*) FROM feedback_votes fv
          JOIN feedback_items fi ON fv.feedback_id = fi.id
          JOIN boards b ON fi.board_id = b.id
          WHERE b.workspace_id = ? AND DATE(fv.created_at) = ?) as total_votes,
         (SELECT COUNT(*) FROM feedback_items fi
          JOIN boards b ON fi.board_id = b.id
          WHERE b.workspace_id = ? AND DATE(fi.created_at) = ?) as total_submissions
     `).bind(workspaceId, date, workspaceId, date).first();

     // Upsert analytics row
     await env.DB.prepare(`
       INSERT INTO user_analytics (
         id, workspace_id, date,
         new_voters, returning_voters,
         new_submitters, returning_submitters,
         total_votes, total_submissions,
         unique_voters, unique_submitters
       ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(workspace_id, date) DO UPDATE SET
         new_voters = excluded.new_voters,
         returning_voters = excluded.returning_voters,
         new_submitters = excluded.new_submitters,
         returning_submitters = excluded.returning_submitters,
         total_votes = excluded.total_votes,
         total_submissions = excluded.total_submissions,
         unique_voters = excluded.unique_voters,
         unique_submitters = excluded.unique_submitters
     `).bind(
       generateId('ua'),
       workspaceId,
       date,
       voterStats?.new_voters || 0,
       voterStats?.returning_voters || 0,
       submitterStats?.new_submitters || 0,
       submitterStats?.returning_submitters || 0,
       totals?.total_votes || 0,
       totals?.total_submissions || 0,
       voterStats?.unique_voters || 0,
       submitterStats?.unique_submitters || 0
     ).run();
   }
   ```

3. Create scheduled trigger:
   ```typescript
   // src/worker.ts - scheduled handler

   export default {
     async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {
       if (event.cron === '0 1 * * *') {  // 1 AM daily
         const workspaces = await env.DB.prepare(
           'SELECT id FROM workspaces'
         ).all();

         const yesterday = new Date();
         yesterday.setDate(yesterday.getDate() - 1);
         const date = yesterday.toISOString().split('T')[0];

         for (const ws of workspaces.results) {
           await aggregateUserAnalytics(ws.id as string, date, env);
         }
       }
     }
   };
   ```

**Acceptance Criteria**:
- [ ] Daily aggregates computed
- [ ] No PII exposed in analytics tables
- [ ] Historical data preserved

---

### 4.1.2 Power User Identification (1.5h)
**Objective**: Identify and track highly engaged users

**Steps**:
1. Create power user detection:
   ```typescript
   // src/lib/analytics/power-users.ts

   interface PowerUser {
     user_id: string;
     name: string | null;
     email: string | null;
     votes_30d: number;
     submissions_30d: number;
     comments_30d: number;
     first_seen: string;
     last_active: string;
     engagement_score: number;
   }

   export async function getPowerUsers(
     workspaceId: string,
     env: Env,
     options: { limit?: number; minEngagementScore?: number } = {}
   ): Promise<{ power_users: PowerUser[]; total_count: number }> {
     const { limit = 50, minEngagementScore = 10 } = options;

     // Power user criteria: engagement score based on activity
     // Score = (votes * 1) + (submissions * 5) + (comments * 2)
     const powerUsers = await env.DB.prepare(`
       WITH user_activity AS (
         SELECT
           eu.id as user_id,
           eu.name,
           eu.email,
           MIN(COALESCE(fi.created_at, fv.created_at, fc.created_at)) as first_seen,
           MAX(COALESCE(fi.created_at, fv.created_at, fc.created_at)) as last_active,
           COUNT(DISTINCT CASE
             WHEN fv.created_at > datetime('now', '-30 days') THEN fv.id
           END) as votes_30d,
           COUNT(DISTINCT CASE
             WHEN fi.created_at > datetime('now', '-30 days') THEN fi.id
           END) as submissions_30d,
           COUNT(DISTINCT CASE
             WHEN fc.created_at > datetime('now', '-30 days') THEN fc.id
           END) as comments_30d
         FROM end_users eu
         LEFT JOIN feedback_votes fv ON eu.id = fv.user_id
         LEFT JOIN feedback_items fi ON eu.id = fi.user_id
         LEFT JOIN feedback_comments fc ON eu.id = fc.user_id
         WHERE eu.workspace_id = ?
         GROUP BY eu.id
       )
       SELECT
         user_id, name, email, first_seen, last_active,
         votes_30d, submissions_30d, comments_30d,
         (votes_30d * 1 + submissions_30d * 5 + comments_30d * 2) as engagement_score
       FROM user_activity
       WHERE (votes_30d * 1 + submissions_30d * 5 + comments_30d * 2) >= ?
       ORDER BY engagement_score DESC
       LIMIT ?
     `).bind(workspaceId, minEngagementScore, limit).all();

     const totalCount = await env.DB.prepare(`
       SELECT COUNT(*) as count FROM (
         SELECT eu.id,
           (COUNT(DISTINCT CASE WHEN fv.created_at > datetime('now', '-30 days') THEN fv.id END) * 1 +
            COUNT(DISTINCT CASE WHEN fi.created_at > datetime('now', '-30 days') THEN fi.id END) * 5 +
            COUNT(DISTINCT CASE WHEN fc.created_at > datetime('now', '-30 days') THEN fc.id END) * 2) as score
         FROM end_users eu
         LEFT JOIN feedback_votes fv ON eu.id = fv.user_id
         LEFT JOIN feedback_items fi ON eu.id = fi.user_id
         LEFT JOIN feedback_comments fc ON eu.id = fc.user_id
         WHERE eu.workspace_id = ?
         GROUP BY eu.id
         HAVING score >= ?
       )
     `).bind(workspaceId, minEngagementScore).first();

     return {
       power_users: powerUsers.results as PowerUser[],
       total_count: totalCount?.count as number || 0
     };
   }
   ```

2. Create API endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/analytics/power-users
   async function handleGetPowerUsers(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     const url = new URL(request.url);
     const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 100);
     const minScore = parseInt(url.searchParams.get('min_score') || '10');

     const result = await getPowerUsers(workspaceId, env, {
       limit,
       minEngagementScore: minScore
     });

     return jsonResponse(result);
   }
   ```

**Acceptance Criteria**:
- [ ] Power users accurately identified
- [ ] Engagement score formula working
- [ ] List available to admins

---

### 4.1.3 Engagement Metrics per User (1.5h)
**Objective**: Detailed per-user activity view

**Steps**:
1. Create user detail endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/users/:userId/analytics
   async function handleGetUserAnalytics(request: Request, env: Env): Promise<Response> {
     const { workspaceId, userId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     // Get user info
     const user = await env.DB.prepare(`
       SELECT id, name, email, created_at
       FROM end_users
       WHERE id = ? AND workspace_id = ?
     `).bind(userId, workspaceId).first();

     if (!user) {
       return errorResponse('NOT_FOUND', 'User not found', 404);
     }

     // Get activity summary
     const summary = await env.DB.prepare(`
       SELECT
         (SELECT COUNT(*) FROM feedback_votes WHERE user_id = ?) as total_votes,
         (SELECT COUNT(*) FROM feedback_items WHERE user_id = ?) as total_submissions,
         (SELECT COUNT(*) FROM feedback_comments WHERE user_id = ?) as total_comments,
         (SELECT COUNT(*) FROM feedback_votes WHERE user_id = ? AND created_at > datetime('now', '-30 days')) as votes_30d,
         (SELECT COUNT(*) FROM feedback_items WHERE user_id = ? AND created_at > datetime('now', '-30 days')) as submissions_30d,
         (SELECT COUNT(*) FROM feedback_comments WHERE user_id = ? AND created_at > datetime('now', '-30 days')) as comments_30d
     `).bind(userId, userId, userId, userId, userId, userId).first();

     // Get recent activity timeline
     const timeline = await env.DB.prepare(`
       SELECT * FROM (
         SELECT 'vote' as type, fv.created_at, fi.title as item_title, fi.id as item_id
         FROM feedback_votes fv
         JOIN feedback_items fi ON fv.feedback_id = fi.id
         WHERE fv.user_id = ?
         UNION ALL
         SELECT 'submission' as type, fi.created_at, fi.title as item_title, fi.id as item_id
         FROM feedback_items fi
         WHERE fi.user_id = ?
         UNION ALL
         SELECT 'comment' as type, fc.created_at, fi.title as item_title, fi.id as item_id
         FROM feedback_comments fc
         JOIN feedback_items fi ON fc.feedback_id = fi.id
         WHERE fc.user_id = ?
       )
       ORDER BY created_at DESC
       LIMIT 50
     `).bind(userId, userId, userId).all();

     // Get submitted items with status
     const submissions = await env.DB.prepare(`
       SELECT id, title, status, vote_count, created_at
       FROM feedback_items
       WHERE user_id = ?
       ORDER BY created_at DESC
       LIMIT 20
     `).bind(userId).all();

     return jsonResponse({
       user: {
         id: user.id,
         name: user.name,
         email: user.email,  // Only for admins
         member_since: user.created_at
       },
       summary,
       activity_timeline: timeline.results,
       submissions: submissions.results
     });
   }
   ```

**Acceptance Criteria**:
- [ ] User detail view in admin
- [ ] Activity chronologically ordered
- [ ] Summary stats accurate

---

### 4.1.4 Cohort Analysis (1.5h)
**Objective**: Track user retention by cohort

**Steps**:
1. Create cohort analysis:
   ```typescript
   // src/lib/analytics/cohorts.ts

   interface CohortRow {
     cohort_week: string;  // YYYY-WXX
     cohort_size: number;
     week_0: number;  // Active in signup week
     week_1: number;  // Active 1 week later
     week_2: number;
     week_3: number;
     week_4: number;
   }

   export async function getCohortAnalysis(
     workspaceId: string,
     env: Env,
     weeks: number = 8
   ): Promise<CohortRow[]> {
     // Get cohorts for the last N weeks
     const cohorts = await env.DB.prepare(`
       WITH cohorts AS (
         SELECT
           eu.id as user_id,
           strftime('%Y-W%W', eu.created_at) as cohort_week,
           eu.created_at as cohort_date
         FROM end_users eu
         WHERE eu.workspace_id = ?
           AND eu.created_at > datetime('now', ? || ' days')
       ),
       user_activity AS (
         SELECT
           c.user_id,
           c.cohort_week,
           c.cohort_date,
           MAX(COALESCE(fv.created_at, fi.created_at, fc.created_at)) as last_activity
         FROM cohorts c
         LEFT JOIN feedback_votes fv ON c.user_id = fv.user_id
         LEFT JOIN feedback_items fi ON c.user_id = fi.user_id
         LEFT JOIN feedback_comments fc ON c.user_id = fc.user_id
         GROUP BY c.user_id
       )
       SELECT
         cohort_week,
         COUNT(DISTINCT user_id) as cohort_size,
         COUNT(DISTINCT CASE
           WHEN julianday(last_activity) - julianday(cohort_date) BETWEEN 0 AND 6 THEN user_id
         END) as week_0,
         COUNT(DISTINCT CASE
           WHEN julianday(last_activity) - julianday(cohort_date) BETWEEN 7 AND 13 THEN user_id
         END) as week_1,
         COUNT(DISTINCT CASE
           WHEN julianday(last_activity) - julianday(cohort_date) BETWEEN 14 AND 20 THEN user_id
         END) as week_2,
         COUNT(DISTINCT CASE
           WHEN julianday(last_activity) - julianday(cohort_date) BETWEEN 21 AND 27 THEN user_id
         END) as week_3,
         COUNT(DISTINCT CASE
           WHEN julianday(last_activity) - julianday(cohort_date) >= 28 THEN user_id
         END) as week_4
       FROM user_activity
       GROUP BY cohort_week
       ORDER BY cohort_week DESC
       LIMIT ?
     `).bind(workspaceId, -(weeks * 7), weeks).all();

     return cohorts.results as CohortRow[];
   }
   ```

2. Create API endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/analytics/cohorts
   async function handleGetCohorts(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'analytics:view');

     const url = new URL(request.url);
     const weeks = Math.min(parseInt(url.searchParams.get('weeks') || '8'), 12);

     const cohorts = await getCohortAnalysis(workspaceId, env, weeks);

     // Calculate retention percentages
     const cohortsWithRetention = cohorts.map(c => ({
       ...c,
       retention: {
         week_0: c.cohort_size > 0 ? Math.round((c.week_0 / c.cohort_size) * 100) : 0,
         week_1: c.cohort_size > 0 ? Math.round((c.week_1 / c.cohort_size) * 100) : 0,
         week_2: c.cohort_size > 0 ? Math.round((c.week_2 / c.cohort_size) * 100) : 0,
         week_3: c.cohort_size > 0 ? Math.round((c.week_3 / c.cohort_size) * 100) : 0,
         week_4: c.cohort_size > 0 ? Math.round((c.week_4 / c.cohort_size) * 100) : 0
       }
     }));

     return jsonResponse({ cohorts: cohortsWithRetention });
   }
   ```

**Acceptance Criteria**:
- [ ] Weekly cohorts computed
- [ ] Retention percentages calculated
- [ ] Data exportable

---

## Definition of Done
- [ ] Daily user analytics aggregation running
- [ ] Power user identification working
- [ ] Per-user analytics view functional
- [ ] Cohort analysis available
- [ ] No PII exposed in any analytics

## Technical Notes
- Scheduled worker runs at 1 AM daily
- Cohort analysis limited to 12 weeks for performance
- Power user score: votes*1 + submissions*5 + comments*2
- Consider caching power user list (1 hour TTL)

## Related Files
- `src/lib/analytics/aggregator.ts` - Daily aggregation
- `src/lib/analytics/power-users.ts` - Power user detection
- `src/lib/analytics/cohorts.ts` - Cohort analysis
- `src/routes/analytics.ts` - API endpoints
