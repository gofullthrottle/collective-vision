# Epic 6.5: Invoice Generation & Tax Handling

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Build invoice generation system with PDF creation, email delivery, and tax compliance handling.

## Wave Context
**Wave 6**: Monetization & Pricing (Stripe Integration, Billing, Invoicing)
**Dependencies**: 6.1 (Stripe Integration), 6.3 (Usage Billing)
**Unlocks**: Professional invoicing, tax compliance, billing history

## Quality Requirements
- PDF invoices match Stripe data exactly
- Tax calculations comply with Stripe Tax
- Invoices archived for 7+ years
- Email delivery with tracking

---

## Tasks

### Task 6.5.1: Invoice Data Model (1h)

Create comprehensive invoice storage with line items and tax breakdowns.

**Subtasks**:
- [ ] Design invoice schema
- [ ] Create line items table
- [ ] Add tax breakdown storage
- [ ] Implement invoice retrieval

**Schema**:
```sql
-- Invoices (synced from Stripe)
CREATE TABLE IF NOT EXISTS invoices (
  id TEXT PRIMARY KEY, -- Stripe invoice ID (in_xxx)
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  stripe_customer_id TEXT NOT NULL,
  number TEXT, -- Invoice number (e.g., "CV-0001")
  status TEXT NOT NULL, -- 'draft', 'open', 'paid', 'void', 'uncollectible'
  currency TEXT DEFAULT 'usd',
  subtotal INTEGER NOT NULL, -- Cents
  tax INTEGER DEFAULT 0, -- Total tax in cents
  total INTEGER NOT NULL, -- Cents
  amount_paid INTEGER DEFAULT 0,
  amount_remaining INTEGER DEFAULT 0,
  billing_reason TEXT, -- 'subscription_create', 'subscription_cycle', 'manual'
  period_start TEXT,
  period_end TEXT,
  due_date TEXT,
  paid_at TEXT,
  pdf_url TEXT, -- R2 URL to generated PDF
  stripe_pdf_url TEXT, -- Stripe-hosted PDF
  hosted_invoice_url TEXT, -- Stripe hosted invoice page
  metadata TEXT, -- JSON
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_invoices_workspace ON invoices(workspace_id, created_at DESC);
CREATE INDEX idx_invoices_status ON invoices(workspace_id, status);

-- Invoice line items
CREATE TABLE IF NOT EXISTS invoice_line_items (
  id TEXT PRIMARY KEY, -- Stripe line item ID (ii_xxx)
  invoice_id TEXT NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  quantity INTEGER DEFAULT 1,
  unit_amount INTEGER, -- Cents per unit
  amount INTEGER NOT NULL, -- Total cents
  currency TEXT DEFAULT 'usd',
  price_id TEXT, -- Stripe price ID
  product_id TEXT, -- Stripe product ID
  period_start TEXT,
  period_end TEXT,
  proration INTEGER DEFAULT 0, -- Boolean
  metadata TEXT
);

CREATE INDEX idx_line_items_invoice ON invoice_line_items(invoice_id);

-- Tax breakdown per invoice
CREATE TABLE IF NOT EXISTS invoice_tax_amounts (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  invoice_id TEXT NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  tax_rate_id TEXT, -- Stripe tax rate ID
  display_name TEXT NOT NULL, -- "Sales Tax", "VAT", etc.
  jurisdiction TEXT, -- "US-CA", "EU-DE"
  percentage REAL NOT NULL, -- 8.25
  amount INTEGER NOT NULL, -- Cents
  inclusive INTEGER DEFAULT 0, -- Boolean: tax included in price
  taxability_reason TEXT -- 'standard_rated', 'zero_rated', 'exempt'
);

CREATE INDEX idx_tax_invoice ON invoice_tax_amounts(invoice_id);

-- Invoice events for audit trail
CREATE TABLE IF NOT EXISTS invoice_events (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  invoice_id TEXT NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL, -- 'created', 'sent', 'paid', 'payment_failed', 'voided'
  event_data TEXT, -- JSON with details
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_invoice_events ON invoice_events(invoice_id, created_at);
```

**Implementation**:
```typescript
// src/services/invoices.ts
import Stripe from 'stripe';

interface InvoiceWithDetails {
  id: string;
  number: string;
  status: string;
  currency: string;
  subtotal: number;
  tax: number;
  total: number;
  amount_paid: number;
  period_start: string;
  period_end: string;
  due_date: string | null;
  paid_at: string | null;
  pdf_url: string | null;
  hosted_invoice_url: string;
  line_items: Array<{
    description: string;
    quantity: number;
    unit_amount: number;
    amount: number;
  }>;
  tax_amounts: Array<{
    display_name: string;
    jurisdiction: string;
    percentage: number;
    amount: number;
  }>;
}

export async function syncInvoiceFromStripe(
  env: Env,
  stripeInvoice: Stripe.Invoice
): Promise<void> {
  // Find workspace by Stripe customer
  const workspace = await env.DB.prepare(`
    SELECT id FROM workspaces WHERE stripe_customer_id = ?
  `).bind(stripeInvoice.customer).first<{ id: string }>();

  if (!workspace) {
    console.error(`No workspace found for customer ${stripeInvoice.customer}`);
    return;
  }

  // Upsert invoice
  await env.DB.prepare(`
    INSERT INTO invoices (
      id, workspace_id, stripe_customer_id, number, status, currency,
      subtotal, tax, total, amount_paid, amount_remaining, billing_reason,
      period_start, period_end, due_date, paid_at,
      stripe_pdf_url, hosted_invoice_url, metadata
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(id) DO UPDATE SET
      status = ?, amount_paid = ?, amount_remaining = ?, paid_at = ?,
      stripe_pdf_url = ?, updated_at = datetime('now')
  `).bind(
    stripeInvoice.id,
    workspace.id,
    stripeInvoice.customer,
    stripeInvoice.number,
    stripeInvoice.status,
    stripeInvoice.currency,
    stripeInvoice.subtotal,
    stripeInvoice.tax || 0,
    stripeInvoice.total,
    stripeInvoice.amount_paid,
    stripeInvoice.amount_remaining,
    stripeInvoice.billing_reason,
    stripeInvoice.period_start ? new Date(stripeInvoice.period_start * 1000).toISOString() : null,
    stripeInvoice.period_end ? new Date(stripeInvoice.period_end * 1000).toISOString() : null,
    stripeInvoice.due_date ? new Date(stripeInvoice.due_date * 1000).toISOString() : null,
    stripeInvoice.status_transitions?.paid_at
      ? new Date(stripeInvoice.status_transitions.paid_at * 1000).toISOString() : null,
    stripeInvoice.invoice_pdf,
    stripeInvoice.hosted_invoice_url,
    JSON.stringify(stripeInvoice.metadata || {}),
    // Update values
    stripeInvoice.status,
    stripeInvoice.amount_paid,
    stripeInvoice.amount_remaining,
    stripeInvoice.status_transitions?.paid_at
      ? new Date(stripeInvoice.status_transitions.paid_at * 1000).toISOString() : null,
    stripeInvoice.invoice_pdf
  ).run();

  // Sync line items
  if (stripeInvoice.lines?.data) {
    for (const line of stripeInvoice.lines.data) {
      await env.DB.prepare(`
        INSERT INTO invoice_line_items (
          id, invoice_id, description, quantity, unit_amount, amount,
          currency, price_id, product_id, period_start, period_end, proration
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          description = ?, quantity = ?, amount = ?
      `).bind(
        line.id,
        stripeInvoice.id,
        line.description,
        line.quantity,
        line.unit_amount,
        line.amount,
        line.currency,
        line.price?.id || null,
        typeof line.price?.product === 'string' ? line.price.product : line.price?.product?.id,
        line.period?.start ? new Date(line.period.start * 1000).toISOString() : null,
        line.period?.end ? new Date(line.period.end * 1000).toISOString() : null,
        line.proration ? 1 : 0,
        // Update
        line.description,
        line.quantity,
        line.amount
      ).run();
    }
  }

  // Sync tax amounts
  if (stripeInvoice.total_tax_amounts) {
    // Clear existing
    await env.DB.prepare(`DELETE FROM invoice_tax_amounts WHERE invoice_id = ?`)
      .bind(stripeInvoice.id).run();

    for (const taxAmount of stripeInvoice.total_tax_amounts) {
      const taxRate = typeof taxAmount.tax_rate === 'string'
        ? null
        : taxAmount.tax_rate;

      await env.DB.prepare(`
        INSERT INTO invoice_tax_amounts (
          invoice_id, tax_rate_id, display_name, jurisdiction,
          percentage, amount, inclusive, taxability_reason
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(
        stripeInvoice.id,
        typeof taxAmount.tax_rate === 'string' ? taxAmount.tax_rate : taxAmount.tax_rate?.id,
        taxRate?.display_name || 'Tax',
        taxRate?.jurisdiction || null,
        taxRate?.percentage || 0,
        taxAmount.amount,
        taxAmount.inclusive ? 1 : 0,
        taxRate?.tax_type || null
      ).run();
    }
  }

  // Record event
  await env.DB.prepare(`
    INSERT INTO invoice_events (invoice_id, event_type, event_data)
    VALUES (?, 'synced', ?)
  `).bind(stripeInvoice.id, JSON.stringify({ source: 'stripe_webhook' })).run();
}

export async function getInvoice(
  env: Env,
  invoiceId: string,
  workspaceId: string
): Promise<InvoiceWithDetails | null> {
  const invoice = await env.DB.prepare(`
    SELECT * FROM invoices WHERE id = ? AND workspace_id = ?
  `).bind(invoiceId, workspaceId).first();

  if (!invoice) return null;

  const lineItems = await env.DB.prepare(`
    SELECT description, quantity, unit_amount, amount
    FROM invoice_line_items WHERE invoice_id = ?
  `).bind(invoiceId).all();

  const taxAmounts = await env.DB.prepare(`
    SELECT display_name, jurisdiction, percentage, amount
    FROM invoice_tax_amounts WHERE invoice_id = ?
  `).bind(invoiceId).all();

  return {
    id: invoice.id,
    number: invoice.number,
    status: invoice.status,
    currency: invoice.currency,
    subtotal: invoice.subtotal,
    tax: invoice.tax,
    total: invoice.total,
    amount_paid: invoice.amount_paid,
    period_start: invoice.period_start,
    period_end: invoice.period_end,
    due_date: invoice.due_date,
    paid_at: invoice.paid_at,
    pdf_url: invoice.pdf_url || invoice.stripe_pdf_url,
    hosted_invoice_url: invoice.hosted_invoice_url,
    line_items: lineItems.results,
    tax_amounts: taxAmounts.results
  };
}

export async function listInvoices(
  env: Env,
  workspaceId: string,
  options: { status?: string; limit?: number; offset?: number }
): Promise<{ invoices: InvoiceWithDetails[]; total: number }> {
  let query = 'SELECT * FROM invoices WHERE workspace_id = ?';
  const params: any[] = [workspaceId];

  if (options.status) {
    query += ' AND status = ?';
    params.push(options.status);
  }

  query += ' ORDER BY created_at DESC';

  if (options.limit) {
    query += ' LIMIT ?';
    params.push(options.limit);
    if (options.offset) {
      query += ' OFFSET ?';
      params.push(options.offset);
    }
  }

  const invoices = await env.DB.prepare(query).bind(...params).all();

  const countQuery = `SELECT COUNT(*) as count FROM invoices WHERE workspace_id = ?${options.status ? ' AND status = ?' : ''}`;
  const count = await env.DB.prepare(countQuery)
    .bind(...(options.status ? [workspaceId, options.status] : [workspaceId]))
    .first<{ count: number }>();

  return {
    invoices: invoices.results as InvoiceWithDetails[],
    total: count?.count || 0
  };
}
```

**Acceptance Criteria**:
- [ ] Invoice data synced from Stripe webhooks
- [ ] Line items stored with descriptions
- [ ] Tax breakdown preserved
- [ ] Audit trail via events table

---

### Task 6.5.2: PDF Invoice Generation (1.5h)

Generate branded PDF invoices using custom templates.

**Subtasks**:
- [ ] Create PDF template with branding
- [ ] Generate PDFs on invoice finalization
- [ ] Store PDFs in R2
- [ ] Support custom invoice numbers

**Implementation**:
```typescript
// src/services/pdf-generator.ts
// Using @pdfme/generator for PDF generation

interface InvoicePDFData {
  invoice: InvoiceWithDetails;
  branding: {
    company_name: string;
    logo_url: string | null;
    address: string[];
    primary_color: string;
  };
  customer: {
    name: string;
    email: string;
    address: string[];
    tax_id?: string;
  };
}

export async function generateInvoicePDF(
  env: Env,
  data: InvoicePDFData
): Promise<ArrayBuffer> {
  const { invoice, branding, customer } = data;

  // Format currency
  const formatAmount = (cents: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: invoice.currency.toUpperCase()
    }).format(cents / 100);
  };

  // Build HTML for PDF (using Puppeteer or similar)
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 12px; color: #333; padding: 40px; }
    .header { display: flex; justify-content: space-between; margin-bottom: 40px; }
    .logo { max-height: 60px; }
    .company-name { font-size: 24px; font-weight: bold; color: ${branding.primary_color}; }
    .invoice-title { font-size: 28px; color: ${branding.primary_color}; text-align: right; }
    .invoice-number { color: #666; text-align: right; margin-top: 5px; }
    .addresses { display: flex; justify-content: space-between; margin-bottom: 30px; }
    .address-block { width: 45%; }
    .address-label { font-weight: bold; color: #666; margin-bottom: 10px; text-transform: uppercase; font-size: 10px; }
    .invoice-details { background: #f7f7f7; padding: 15px; border-radius: 5px; margin-bottom: 30px; }
    .invoice-details-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
    .invoice-details-label { color: #666; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
    th { background: ${branding.primary_color}; color: white; padding: 12px; text-align: left; }
    td { padding: 12px; border-bottom: 1px solid #eee; }
    .amount { text-align: right; }
    .totals { float: right; width: 300px; }
    .totals-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee; }
    .totals-row.total { font-weight: bold; font-size: 16px; border-top: 2px solid #333; border-bottom: none; margin-top: 10px; padding-top: 15px; }
    .footer { margin-top: 60px; text-align: center; color: #999; font-size: 10px; }
    .paid-stamp { position: absolute; top: 200px; right: 60px; transform: rotate(-15deg); font-size: 48px; color: rgba(34, 197, 94, 0.3); font-weight: bold; border: 4px solid rgba(34, 197, 94, 0.3); padding: 10px 20px; }
  </style>
</head>
<body>
  ${invoice.status === 'paid' ? '<div class="paid-stamp">PAID</div>' : ''}

  <div class="header">
    <div>
      ${branding.logo_url ? `<img src="${branding.logo_url}" class="logo">` : `<div class="company-name">${branding.company_name}</div>`}
    </div>
    <div>
      <div class="invoice-title">INVOICE</div>
      <div class="invoice-number">${invoice.number}</div>
    </div>
  </div>

  <div class="addresses">
    <div class="address-block">
      <div class="address-label">From</div>
      <div><strong>${branding.company_name}</strong></div>
      ${branding.address.map(line => `<div>${line}</div>`).join('')}
    </div>
    <div class="address-block">
      <div class="address-label">Bill To</div>
      <div><strong>${customer.name}</strong></div>
      <div>${customer.email}</div>
      ${customer.address.map(line => `<div>${line}</div>`).join('')}
      ${customer.tax_id ? `<div>Tax ID: ${customer.tax_id}</div>` : ''}
    </div>
  </div>

  <div class="invoice-details">
    <div class="invoice-details-row">
      <span class="invoice-details-label">Invoice Date:</span>
      <span>${new Date(invoice.period_start).toLocaleDateString()}</span>
    </div>
    <div class="invoice-details-row">
      <span class="invoice-details-label">Due Date:</span>
      <span>${invoice.due_date ? new Date(invoice.due_date).toLocaleDateString() : 'Upon Receipt'}</span>
    </div>
    <div class="invoice-details-row">
      <span class="invoice-details-label">Period:</span>
      <span>${new Date(invoice.period_start).toLocaleDateString()} - ${new Date(invoice.period_end).toLocaleDateString()}</span>
    </div>
  </div>

  <table>
    <thead>
      <tr>
        <th>Description</th>
        <th style="width: 80px;">Qty</th>
        <th style="width: 100px;" class="amount">Unit Price</th>
        <th style="width: 100px;" class="amount">Amount</th>
      </tr>
    </thead>
    <tbody>
      ${invoice.line_items.map(item => `
        <tr>
          <td>${item.description}</td>
          <td>${item.quantity}</td>
          <td class="amount">${formatAmount(item.unit_amount)}</td>
          <td class="amount">${formatAmount(item.amount)}</td>
        </tr>
      `).join('')}
    </tbody>
  </table>

  <div class="totals">
    <div class="totals-row">
      <span>Subtotal</span>
      <span>${formatAmount(invoice.subtotal)}</span>
    </div>
    ${invoice.tax_amounts.map(tax => `
      <div class="totals-row">
        <span>${tax.display_name} (${tax.percentage}%)</span>
        <span>${formatAmount(tax.amount)}</span>
      </div>
    `).join('')}
    <div class="totals-row total">
      <span>Total</span>
      <span>${formatAmount(invoice.total)}</span>
    </div>
    ${invoice.amount_paid > 0 ? `
      <div class="totals-row">
        <span>Amount Paid</span>
        <span>-${formatAmount(invoice.amount_paid)}</span>
      </div>
      <div class="totals-row total">
        <span>Balance Due</span>
        <span>${formatAmount(invoice.total - invoice.amount_paid)}</span>
      </div>
    ` : ''}
  </div>

  <div style="clear: both;"></div>

  <div class="footer">
    <p>Thank you for your business!</p>
    <p>Questions? Contact ${branding.company_name}</p>
  </div>
</body>
</html>
  `;

  // Use browser rendering service or PDF library
  // For Cloudflare Workers, use @pdfme/generator or external service
  const pdfResponse = await fetch('https://pdf-service.internal/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ html, options: { format: 'A4' } })
  });

  return await pdfResponse.arrayBuffer();
}

export async function storeInvoicePDF(
  env: Env,
  invoiceId: string,
  workspaceId: string,
  pdfBuffer: ArrayBuffer
): Promise<string> {
  const key = `invoices/${workspaceId}/${invoiceId}.pdf`;

  await env.R2.put(key, pdfBuffer, {
    httpMetadata: {
      contentType: 'application/pdf',
      contentDisposition: `attachment; filename="invoice-${invoiceId}.pdf"`
    }
  });

  // Update invoice record
  const pdfUrl = `${env.R2_PUBLIC_URL}/${key}`;
  await env.DB.prepare(`
    UPDATE invoices SET pdf_url = ?, updated_at = datetime('now')
    WHERE id = ?
  `).bind(pdfUrl, invoiceId).run();

  return pdfUrl;
}
```

**Acceptance Criteria**:
- [ ] PDF matches Stripe invoice data
- [ ] Branding applied (logo, colors)
- [ ] PAID stamp on paid invoices
- [ ] PDFs stored in R2 with 7+ year retention

---

### Task 6.5.3: Invoice Email Delivery (1h)

Send invoice emails with PDF attachments and tracking.

**Subtasks**:
- [ ] Create invoice email template
- [ ] Attach PDF to email
- [ ] Track email delivery status
- [ ] Handle failed deliveries

**Implementation**:
```typescript
// src/services/invoice-email.ts
interface InvoiceEmailParams {
  invoice: InvoiceWithDetails;
  recipient: {
    email: string;
    name: string;
  };
  branding: EmailBranding;
  pdf_url: string;
}

export async function sendInvoiceEmail(
  env: Env,
  params: InvoiceEmailParams
): Promise<{ success: boolean; message_id?: string; error?: string }> {
  const { invoice, recipient, branding, pdf_url } = params;

  // Fetch PDF for attachment
  const pdfResponse = await fetch(pdf_url);
  const pdfBuffer = await pdfResponse.arrayBuffer();
  const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfBuffer)));

  const formatAmount = (cents: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: invoice.currency.toUpperCase()
    }).format(cents / 100);
  };

  const isOverdue = invoice.due_date && new Date(invoice.due_date) < new Date() && invoice.status !== 'paid';

  const subject = invoice.status === 'paid'
    ? `Receipt for Invoice ${invoice.number}`
    : isOverdue
    ? `[Action Required] Invoice ${invoice.number} is overdue`
    : `Invoice ${invoice.number} from ${branding.company_name}`;

  const htmlContent = `
    <h2>Invoice ${invoice.number}</h2>

    ${invoice.status === 'paid' ? `
      <div style="background: #dcfce7; border: 1px solid #22c55e; padding: 15px; border-radius: 8px; margin: 20px 0;">
        <strong style="color: #16a34a;">Payment Received</strong>
        <p style="margin: 5px 0 0 0; color: #15803d;">
          Thank you! Your payment of ${formatAmount(invoice.amount_paid)} was received on ${new Date(invoice.paid_at!).toLocaleDateString()}.
        </p>
      </div>
    ` : isOverdue ? `
      <div style="background: #fef2f2; border: 1px solid #ef4444; padding: 15px; border-radius: 8px; margin: 20px 0;">
        <strong style="color: #dc2626;">Payment Overdue</strong>
        <p style="margin: 5px 0 0 0; color: #b91c1c;">
          This invoice was due on ${new Date(invoice.due_date!).toLocaleDateString()}. Please submit payment as soon as possible.
        </p>
      </div>
    ` : ''}

    <table style="width: 100%; margin: 20px 0;">
      <tr>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee;"><strong>Invoice Number</strong></td>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee; text-align: right;">${invoice.number}</td>
      </tr>
      <tr>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee;"><strong>Invoice Date</strong></td>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee; text-align: right;">${new Date(invoice.period_start).toLocaleDateString()}</td>
      </tr>
      ${invoice.due_date ? `
      <tr>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee;"><strong>Due Date</strong></td>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee; text-align: right;">${new Date(invoice.due_date).toLocaleDateString()}</td>
      </tr>
      ` : ''}
      <tr>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee;"><strong>Amount ${invoice.status === 'paid' ? 'Paid' : 'Due'}</strong></td>
        <td style="padding: 8px 0; border-bottom: 1px solid #eee; text-align: right; font-weight: bold; font-size: 16px;">
          ${formatAmount(invoice.status === 'paid' ? invoice.amount_paid : invoice.total - invoice.amount_paid)}
        </td>
      </tr>
    </table>

    ${invoice.status !== 'paid' ? `
      <p style="margin-top: 30px;">
        <a href="${invoice.hosted_invoice_url}" class="button">Pay Now</a>
      </p>
    ` : ''}

    <p style="margin-top: 20px; color: #666;">
      A PDF copy of this invoice is attached to this email.
    </p>
  `;

  // Send via email service (Resend, SendGrid, etc.)
  try {
    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.RESEND_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        from: `${branding.company_name} <billing@${env.EMAIL_DOMAIN}>`,
        to: recipient.email,
        subject,
        html: renderEmailTemplate({
          type: 'invoice',
          subject,
          html: htmlContent,
          text: ''
        }, branding, {}),
        attachments: [{
          filename: `invoice-${invoice.number}.pdf`,
          content: pdfBase64,
          type: 'application/pdf'
        }]
      })
    });

    const result = await response.json();

    if (!response.ok) {
      await recordEmailEvent(env, invoice.id, 'send_failed', { error: result });
      return { success: false, error: result.message || 'Failed to send email' };
    }

    await recordEmailEvent(env, invoice.id, 'sent', { message_id: result.id });
    return { success: true, message_id: result.id };
  } catch (error) {
    await recordEmailEvent(env, invoice.id, 'send_error', { error: String(error) });
    return { success: false, error: String(error) };
  }
}

async function recordEmailEvent(
  env: Env,
  invoiceId: string,
  eventType: string,
  data: Record<string, unknown>
): Promise<void> {
  await env.DB.prepare(`
    INSERT INTO invoice_events (invoice_id, event_type, event_data)
    VALUES (?, ?, ?)
  `).bind(invoiceId, eventType, JSON.stringify(data)).run();
}

// Webhook handler for email delivery status
export async function handleEmailWebhook(
  env: Env,
  event: {
    type: 'delivered' | 'bounced' | 'opened' | 'clicked';
    message_id: string;
    timestamp: string;
  }
): Promise<void> {
  // Find invoice by message ID in events
  const invoiceEvent = await env.DB.prepare(`
    SELECT invoice_id FROM invoice_events
    WHERE json_extract(event_data, '$.message_id') = ?
  `).bind(event.message_id).first<{ invoice_id: string }>();

  if (invoiceEvent) {
    await recordEmailEvent(env, invoiceEvent.invoice_id, `email_${event.type}`, {
      timestamp: event.timestamp
    });
  }
}
```

**Acceptance Criteria**:
- [ ] Invoice emails sent on finalization
- [ ] PDF attached to email
- [ ] Delivery tracking via webhooks
- [ ] Overdue notices for unpaid invoices

---

### Task 6.5.4: Tax Handling & Compliance (0.5h)

Handle tax calculations, exemptions, and reporting requirements.

**Subtasks**:
- [ ] Integrate with Stripe Tax
- [ ] Store tax exemption certificates
- [ ] Generate tax reports
- [ ] Handle B2B reverse charge

**Implementation**:
```typescript
// src/services/tax-handling.ts
interface TaxExemption {
  workspace_id: string;
  exemption_type: 'resale' | 'nonprofit' | 'government' | 'other';
  certificate_url: string;
  jurisdiction: string;
  valid_from: string;
  valid_until: string | null;
}

export async function addTaxExemption(
  env: Env,
  exemption: TaxExemption
): Promise<void> {
  // Store in database
  await env.DB.prepare(`
    INSERT INTO tax_exemptions (
      workspace_id, exemption_type, certificate_url, jurisdiction,
      valid_from, valid_until, status
    ) VALUES (?, ?, ?, ?, ?, ?, 'pending_review')
  `).bind(
    exemption.workspace_id,
    exemption.exemption_type,
    exemption.certificate_url,
    exemption.jurisdiction,
    exemption.valid_from,
    exemption.valid_until
  ).run();

  // Update Stripe customer tax exemption
  const workspace = await env.DB.prepare(`
    SELECT stripe_customer_id FROM workspaces WHERE id = ?
  `).bind(exemption.workspace_id).first<{ stripe_customer_id: string }>();

  if (workspace?.stripe_customer_id) {
    const stripe = new Stripe(env.STRIPE_SECRET_KEY);

    await stripe.customers.update(workspace.stripe_customer_id, {
      tax_exempt: 'exempt', // or 'reverse' for B2B
      metadata: {
        tax_exemption_type: exemption.exemption_type,
        tax_exemption_jurisdiction: exemption.jurisdiction
      }
    });
  }
}

// Generate tax report for a period
export async function generateTaxReport(
  env: Env,
  workspaceId: string,
  startDate: string,
  endDate: string
): Promise<{
  total_revenue: number;
  total_tax_collected: number;
  by_jurisdiction: Record<string, { revenue: number; tax: number }>;
  invoices: Array<{ id: string; number: string; total: number; tax: number; jurisdiction: string }>;
}> {
  const invoices = await env.DB.prepare(`
    SELECT i.*, GROUP_CONCAT(t.jurisdiction) as jurisdictions,
           SUM(t.amount) as tax_breakdown
    FROM invoices i
    LEFT JOIN invoice_tax_amounts t ON t.invoice_id = i.id
    WHERE i.workspace_id = ?
      AND i.status = 'paid'
      AND i.paid_at >= ? AND i.paid_at < ?
    GROUP BY i.id
  `).bind(workspaceId, startDate, endDate).all();

  let totalRevenue = 0;
  let totalTax = 0;
  const byJurisdiction: Record<string, { revenue: number; tax: number }> = {};

  for (const inv of invoices.results) {
    totalRevenue += inv.subtotal;
    totalTax += inv.tax;

    const jurisdiction = inv.jurisdictions?.split(',')[0] || 'Unknown';
    if (!byJurisdiction[jurisdiction]) {
      byJurisdiction[jurisdiction] = { revenue: 0, tax: 0 };
    }
    byJurisdiction[jurisdiction].revenue += inv.subtotal;
    byJurisdiction[jurisdiction].tax += inv.tax;
  }

  return {
    total_revenue: totalRevenue,
    total_tax_collected: totalTax,
    by_jurisdiction: byJurisdiction,
    invoices: invoices.results.map(i => ({
      id: i.id,
      number: i.number,
      total: i.total,
      tax: i.tax,
      jurisdiction: i.jurisdictions?.split(',')[0] || 'Unknown'
    }))
  };
}
```

**Schema Addition**:
```sql
CREATE TABLE IF NOT EXISTS tax_exemptions (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  exemption_type TEXT NOT NULL, -- 'resale', 'nonprofit', 'government', 'other'
  certificate_url TEXT NOT NULL, -- R2 URL to certificate
  jurisdiction TEXT NOT NULL, -- 'US-CA', 'EU-DE'
  valid_from TEXT NOT NULL,
  valid_until TEXT,
  status TEXT DEFAULT 'pending_review', -- 'pending_review', 'approved', 'rejected', 'expired'
  reviewed_by TEXT,
  reviewed_at TEXT,
  notes TEXT,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_tax_exemptions ON tax_exemptions(workspace_id, status);
```

**Acceptance Criteria**:
- [ ] Tax exemptions stored and synced to Stripe
- [ ] Tax reports by jurisdiction
- [ ] B2B reverse charge supported
- [ ] Certificate upload and review workflow

---

## Definition of Done
- [ ] Invoices synced from Stripe in real-time
- [ ] PDF generation with branding
- [ ] Email delivery with tracking
- [ ] Tax exemptions and reporting
- [ ] 7-year invoice archival in R2

## Technical Notes
- Use Stripe as source of truth for invoice data
- PDFs generated on-demand or cached in R2
- Email delivery via Resend with webhook tracking
- Stripe Tax handles automatic tax calculation

## Related Files
- `src/services/invoices.ts` - Invoice data management
- `src/services/pdf-generator.ts` - PDF generation
- `src/services/invoice-email.ts` - Email delivery
- `src/services/tax-handling.ts` - Tax compliance
- `src/routes/webhooks/stripe.ts` - Invoice webhook handling
