# Epic 6.1: Stripe Integration

## Methodology Guidance
**SPECTRA Phase**: Implementation/Monetization
**Approach**: Full Stripe integration for payments
**Tools**: Stripe API, webhooks, Customer Portal

## Wave Context
**Wave**: 6 - Monetization & Scaling
**Priority**: P0 (enables revenue)
**Dependencies**: Wave 1 (auth for billing)
**Estimated Duration**: 8 hours

## Quality Requirements
- Secure payment handling
- Idempotent webhook processing
- Clear error messages
- PCI compliance via Stripe

---

## Tasks

### 6.1.1 Stripe Account Setup (1h)
**Objective**: Configure Stripe products and secrets

**Steps**:
1. Create Stripe products and prices:
   ```typescript
   // Stripe Dashboard Configuration
   // Products:
   const PRODUCTS = {
     free: {
       name: 'Free',
       price: 0,
       interval: null
     },
     pro: {
       name: 'Pro',
       price: 4900,  // $49.00 in cents
       interval: 'month',
       stripe_price_id: 'price_xxx'  // From Stripe
     },
     enterprise: {
       name: 'Enterprise',
       price: 19900,  // $199.00 in cents
       interval: 'month',
       stripe_price_id: 'price_yyy'
     }
   };
   ```

2. Configure environment secrets:
   ```bash
   # Store in Cloudflare secrets
   wrangler secret put STRIPE_SECRET_KEY
   wrangler secret put STRIPE_PUBLISHABLE_KEY
   wrangler secret put STRIPE_WEBHOOK_SECRET
   ```

3. Create subscriptions table:
   ```sql
   CREATE TABLE subscriptions (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL REFERENCES workspaces(id),
     stripe_customer_id TEXT UNIQUE,
     stripe_subscription_id TEXT UNIQUE,
     plan_tier TEXT NOT NULL DEFAULT 'free',
     status TEXT DEFAULT 'active',  -- active, past_due, canceled, trialing
     current_period_start TEXT,
     current_period_end TEXT,
     cancel_at_period_end INTEGER DEFAULT 0,
     created_at TEXT DEFAULT (datetime('now')),
     updated_at TEXT DEFAULT (datetime('now'))
   );

   CREATE INDEX idx_subscriptions_workspace ON subscriptions(workspace_id);
   CREATE INDEX idx_subscriptions_stripe ON subscriptions(stripe_customer_id);
   ```

**Acceptance Criteria**:
- [ ] Stripe account configured
- [ ] Products created
- [ ] Keys stored securely

---

### 6.1.2 Checkout Flow (2h)
**Objective**: Implement Stripe Checkout

**Steps**:
1. Create checkout session endpoint:
   ```typescript
   // POST /api/v1/billing/checkout
   import Stripe from 'stripe';

   interface CheckoutRequest {
     price_id: string;
     success_url: string;
     cancel_url: string;
   }

   async function handleCreateCheckout(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, z.object({
       price_id: z.string(),
       success_url: z.string().url(),
       cancel_url: z.string().url()
     }));

     const { user } = await requirePermission(request, env, workspaceId, 'billing:manage');

     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });

     // Get or create Stripe customer
     let subscription = await env.DB.prepare(`
       SELECT * FROM subscriptions WHERE workspace_id = ?
     `).bind(workspaceId).first();

     let customerId = subscription?.stripe_customer_id;

     if (!customerId) {
       // Get workspace details
       const workspace = await env.DB.prepare(`
         SELECT name FROM workspaces WHERE id = ?
       `).bind(workspaceId).first();

       // Create Stripe customer
       const customer = await stripe.customers.create({
         email: user.email,
         name: workspace?.name as string,
         metadata: {
           workspace_id: workspaceId,
           user_id: user.id
         }
       });

       customerId = customer.id;

       // Create subscription record
       await env.DB.prepare(`
         INSERT INTO subscriptions (id, workspace_id, stripe_customer_id, plan_tier)
         VALUES (?, ?, ?, 'free')
       `).bind(generateId('sub'), workspaceId, customerId).run();
     }

     // Create checkout session
     const session = await stripe.checkout.sessions.create({
       customer: customerId,
       payment_method_types: ['card'],
       mode: 'subscription',
       line_items: [
         {
           price: input.price_id,
           quantity: 1
         }
       ],
       success_url: `${input.success_url}?session_id={CHECKOUT_SESSION_ID}`,
       cancel_url: input.cancel_url,
       metadata: {
         workspace_id: workspaceId
       },
       subscription_data: {
         metadata: {
           workspace_id: workspaceId
         }
       }
     });

     return jsonResponse({
       checkout_url: session.url,
       session_id: session.id
     });
   }
   ```

2. Create checkout success handler:
   ```typescript
   // GET /api/v1/billing/checkout/success
   async function handleCheckoutSuccess(request: Request, env: Env): Promise<Response> {
     const url = new URL(request.url);
     const sessionId = url.searchParams.get('session_id');

     if (!sessionId) {
       return errorResponse('BAD_REQUEST', 'Missing session_id', 400);
     }

     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });
     const session = await stripe.checkout.sessions.retrieve(sessionId);

     if (session.status !== 'complete') {
       return errorResponse('BAD_REQUEST', 'Checkout not complete', 400);
     }

     // Subscription will be activated via webhook
     return jsonResponse({
       status: 'success',
       subscription_id: session.subscription
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Checkout flow complete
- [ ] Subscription created on success
- [ ] Errors handled gracefully

---

### 6.1.3 Webhook Handling (2.5h)
**Objective**: Process Stripe events

**Steps**:
1. Create webhook endpoint:
   ```typescript
   // POST /api/v1/billing/webhook
   async function handleStripeWebhook(request: Request, env: Env): Promise<Response> {
     const signature = request.headers.get('stripe-signature');
     if (!signature) {
       return new Response('Missing signature', { status: 400 });
     }

     const body = await request.text();
     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });

     let event: Stripe.Event;
     try {
       event = stripe.webhooks.constructEvent(
         body,
         signature,
         env.STRIPE_WEBHOOK_SECRET
       );
     } catch (err) {
       console.error('Webhook signature verification failed:', err);
       return new Response('Invalid signature', { status: 400 });
     }

     // Idempotency check
     const eventId = event.id;
     const existing = await env.DB.prepare(`
       SELECT id FROM stripe_events WHERE stripe_event_id = ?
     `).bind(eventId).first();

     if (existing) {
       return jsonResponse({ received: true, duplicate: true });
     }

     // Store event for idempotency
     await env.DB.prepare(`
       INSERT INTO stripe_events (id, stripe_event_id, event_type, processed_at)
       VALUES (?, ?, ?, datetime('now'))
     `).bind(generateId('evt'), eventId, event.type).run();

     // Handle event
     try {
       await processStripeEvent(env, event);
     } catch (err) {
       console.error('Error processing webhook:', err);
       // Return 200 to prevent retry, log for investigation
     }

     return jsonResponse({ received: true });
   }
   ```

2. Implement event handlers:
   ```typescript
   // src/lib/billing/stripe-events.ts

   async function processStripeEvent(env: Env, event: Stripe.Event): Promise<void> {
     switch (event.type) {
       case 'checkout.session.completed':
         await handleCheckoutComplete(env, event.data.object as Stripe.Checkout.Session);
         break;

       case 'customer.subscription.created':
       case 'customer.subscription.updated':
         await handleSubscriptionUpdate(env, event.data.object as Stripe.Subscription);
         break;

       case 'customer.subscription.deleted':
         await handleSubscriptionDeleted(env, event.data.object as Stripe.Subscription);
         break;

       case 'invoice.payment_failed':
         await handlePaymentFailed(env, event.data.object as Stripe.Invoice);
         break;

       case 'invoice.paid':
         await handleInvoicePaid(env, event.data.object as Stripe.Invoice);
         break;

       default:
         console.log(`Unhandled event type: ${event.type}`);
     }
   }

   async function handleCheckoutComplete(env: Env, session: Stripe.Checkout.Session): Promise<void> {
     const workspaceId = session.metadata?.workspace_id;
     if (!workspaceId) return;

     // Subscription details will come via subscription.created event
     console.log(`Checkout complete for workspace ${workspaceId}`);
   }

   async function handleSubscriptionUpdate(env: Env, subscription: Stripe.Subscription): Promise<void> {
     const workspaceId = subscription.metadata?.workspace_id;
     if (!workspaceId) return;

     // Determine plan tier from price
     const priceId = subscription.items.data[0]?.price.id;
     const planTier = getPlanTierFromPrice(priceId);

     await env.DB.prepare(`
       UPDATE subscriptions
       SET stripe_subscription_id = ?,
           plan_tier = ?,
           status = ?,
           current_period_start = ?,
           current_period_end = ?,
           cancel_at_period_end = ?,
           updated_at = datetime('now')
       WHERE workspace_id = ?
     `).bind(
       subscription.id,
       planTier,
       subscription.status,
       new Date(subscription.current_period_start * 1000).toISOString(),
       new Date(subscription.current_period_end * 1000).toISOString(),
       subscription.cancel_at_period_end ? 1 : 0,
       workspaceId
     ).run();

     // Update workspace plan
     await env.DB.prepare(`
       UPDATE workspaces SET plan_tier = ?, updated_at = datetime('now')
       WHERE id = ?
     `).bind(planTier, workspaceId).run();
   }

   async function handleSubscriptionDeleted(env: Env, subscription: Stripe.Subscription): Promise<void> {
     const workspaceId = subscription.metadata?.workspace_id;
     if (!workspaceId) return;

     await env.DB.prepare(`
       UPDATE subscriptions
       SET status = 'canceled', plan_tier = 'free', updated_at = datetime('now')
       WHERE workspace_id = ?
     `).bind(workspaceId).run();

     await env.DB.prepare(`
       UPDATE workspaces SET plan_tier = 'free', updated_at = datetime('now')
       WHERE id = ?
     `).bind(workspaceId).run();
   }

   async function handlePaymentFailed(env: Env, invoice: Stripe.Invoice): Promise<void> {
     const customerId = invoice.customer as string;

     // Get workspace
     const subscription = await env.DB.prepare(`
       SELECT workspace_id FROM subscriptions WHERE stripe_customer_id = ?
     `).bind(customerId).first();

     if (!subscription) return;

     // Update status
     await env.DB.prepare(`
       UPDATE subscriptions SET status = 'past_due', updated_at = datetime('now')
       WHERE workspace_id = ?
     `).bind(subscription.workspace_id).run();

     // TODO: Send notification email
   }

   async function handleInvoicePaid(env: Env, invoice: Stripe.Invoice): Promise<void> {
     const customerId = invoice.customer as string;

     // Create invoice record
     await env.DB.prepare(`
       INSERT OR REPLACE INTO invoices (
         id, workspace_id, stripe_invoice_id, amount_cents, currency, status,
         period_start, period_end, paid_at
       )
       SELECT
         ?,
         s.workspace_id,
         ?,
         ?,
         ?,
         'paid',
         ?,
         ?,
         datetime('now')
       FROM subscriptions s
       WHERE s.stripe_customer_id = ?
     `).bind(
       generateId('inv'),
       invoice.id,
       invoice.amount_paid,
       invoice.currency,
       invoice.period_start ? new Date(invoice.period_start * 1000).toISOString() : null,
       invoice.period_end ? new Date(invoice.period_end * 1000).toISOString() : null,
       customerId
     ).run();
   }

   function getPlanTierFromPrice(priceId: string): string {
     const priceMapping: Record<string, string> = {
       'price_pro_monthly': 'pro',
       'price_enterprise_monthly': 'enterprise'
     };
     return priceMapping[priceId] || 'pro';
   }
   ```

3. Create stripe_events table:
   ```sql
   CREATE TABLE stripe_events (
     id TEXT PRIMARY KEY,
     stripe_event_id TEXT UNIQUE NOT NULL,
     event_type TEXT NOT NULL,
     processed_at TEXT DEFAULT (datetime('now'))
   );
   ```

**Acceptance Criteria**:
- [ ] All events handled
- [ ] Signature verified
- [ ] Idempotent handling

---

### 6.1.4 Customer Portal Integration (1.5h)
**Objective**: Enable self-service billing management

**Steps**:
1. Create portal session endpoint:
   ```typescript
   // POST /api/v1/billing/portal
   async function handleCreatePortalSession(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, z.object({
       return_url: z.string().url()
     }));

     await requirePermission(request, env, workspaceId, 'billing:manage');

     const subscription = await env.DB.prepare(`
       SELECT stripe_customer_id FROM subscriptions WHERE workspace_id = ?
     `).bind(workspaceId).first();

     if (!subscription?.stripe_customer_id) {
       return errorResponse('NOT_FOUND', 'No billing account found', 404);
     }

     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });

     const session = await stripe.billingPortal.sessions.create({
       customer: subscription.stripe_customer_id as string,
       return_url: input.return_url
     });

     return jsonResponse({ portal_url: session.url });
   }
   ```

2. Configure Stripe Customer Portal:
   - Enable subscription cancellation
   - Enable payment method updates
   - Enable invoice history
   - Configure branding

**Acceptance Criteria**:
- [ ] Portal accessible
- [ ] Users can self-manage
- [ ] Changes reflected in app

---

### 6.1.5 Billing History UI (1h)
**Objective**: Display billing information

**Steps**:
1. Create billing history endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/billing
   async function handleGetBilling(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);

     await requirePermission(request, env, workspaceId, 'billing:read');

     // Get subscription
     const subscription = await env.DB.prepare(`
       SELECT * FROM subscriptions WHERE workspace_id = ?
     `).bind(workspaceId).first();

     // Get invoices
     const invoices = await env.DB.prepare(`
       SELECT * FROM invoices WHERE workspace_id = ?
       ORDER BY created_at DESC LIMIT 12
     `).bind(workspaceId).all();

     // Get next invoice from Stripe
     let upcomingInvoice = null;
     if (subscription?.stripe_subscription_id) {
       const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });
       try {
         upcomingInvoice = await stripe.invoices.retrieveUpcoming({
           subscription: subscription.stripe_subscription_id as string
         });
       } catch {
         // No upcoming invoice
       }
     }

     return jsonResponse({
       subscription: subscription ? {
         plan_tier: subscription.plan_tier,
         status: subscription.status,
         current_period_end: subscription.current_period_end,
         cancel_at_period_end: subscription.cancel_at_period_end === 1
       } : null,
       invoices: invoices.results.map(inv => ({
         id: inv.id,
         amount: inv.amount_cents,
         currency: inv.currency,
         status: inv.status,
         period_start: inv.period_start,
         period_end: inv.period_end,
         paid_at: inv.paid_at
       })),
       upcoming: upcomingInvoice ? {
         amount: upcomingInvoice.amount_due,
         due_date: new Date(upcomingInvoice.due_date! * 1000).toISOString()
       } : null
     });
   }
   ```

2. Create invoice download endpoint:
   ```typescript
   // GET /api/v1/invoices/:id/pdf
   async function handleDownloadInvoice(request: Request, env: Env): Promise<Response> {
     const { invoiceId } = parseParams(request);

     const invoice = await env.DB.prepare(`
       SELECT i.*, s.stripe_customer_id
       FROM invoices i
       JOIN subscriptions s ON i.workspace_id = s.workspace_id
       WHERE i.id = ?
     `).bind(invoiceId).first();

     if (!invoice) {
       return errorResponse('NOT_FOUND', 'Invoice not found', 404);
     }

     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2023-10-16' });
     const stripeInvoice = await stripe.invoices.retrieve(invoice.stripe_invoice_id as string);

     if (stripeInvoice.invoice_pdf) {
       return Response.redirect(stripeInvoice.invoice_pdf, 302);
     }

     return errorResponse('NOT_FOUND', 'PDF not available', 404);
   }
   ```

**Acceptance Criteria**:
- [ ] History visible
- [ ] Invoices downloadable
- [ ] Current status clear

---

## Definition of Done
- [ ] Stripe checkout working
- [ ] Webhooks handling all events
- [ ] Customer portal accessible
- [ ] Billing history visible
- [ ] Invoices downloadable

## Technical Notes
- Use Stripe.js for frontend (PCI compliance)
- Webhook signature verification required
- Idempotency via event ID tracking
- Store prices in Stripe, not code

## Related Files
- `src/lib/billing/stripe.ts` - Stripe client
- `src/lib/billing/stripe-events.ts` - Event handlers
- `src/routes/billing.ts` - Billing API
- `wrangler.toml` - Stripe secrets
