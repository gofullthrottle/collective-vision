# Epic 8.5: DevOps & Infrastructure

**Wave**: 8 - Enterprise Polish
**Epic**: DevOps & Infrastructure
**Estimated Hours**: 5h
**Priority**: P0 (Launch Critical)
**Dependencies**: All previous waves

---

## Overview

Establish production-grade CI/CD pipeline, staging environment, blue-green deployment capability, and comprehensive monitoring for reliable operations.

---

## Methodology Guidance

### SPECTRA Phase: Assure
This epic focuses on operational excellence:
- Automated deployment pipeline
- Environment parity
- Observability and alerting

### Quality Bar
- Zero-downtime deployments
- < 5 minute rollback capability
- 99.9% uptime monitoring
- Automated testing in pipeline

---

## Wave Context

Wave 8 ensures production readiness. DevOps infrastructure establishes:
- Reliable deployment process
- Environment management
- Incident detection and response
- Operational visibility

---

## Tasks

### Task 8.5.1: CI/CD Pipeline (2h)

Set up GitHub Actions for automated testing and deployment.

#### Subtask 8.5.1.1: Test Workflow (0.5h)

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: TypeScript check
        run: bun run typecheck

      - name: ESLint
        run: bun run lint

      - name: Prettier check
        run: bun run format:check

  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run unit tests
        run: bun test:unit

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/coverage-final.json
          fail_ci_if_error: true

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run integration tests
        run: bun test:integration
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Install Playwright
        run: bunx playwright install --with-deps chromium

      - name: Run E2E tests
        run: bun test:e2e
        env:
          E2E_BASE_URL: http://localhost:8787

      - name: Upload test artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results
          path: playwright-report/

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run npm audit
        run: bun run audit
        continue-on-error: true

      - name: Run Snyk scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

#### Subtask 8.5.1.2: Deploy Workflow (1h)

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  test:
    uses: ./.github/workflows/test.yml

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build
        run: bun run build

      - name: Generate version
        id: version
        run: echo "version=$(git rev-parse --short HEAD)-$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ steps.version.outputs.version }}
          path: dist/

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    environment: staging
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.build.outputs.version }}
          path: dist/

      - name: Deploy to Cloudflare Workers (Staging)
        run: bunx wrangler deploy --env staging
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

      - name: Run smoke tests
        run: |
          curl -sf https://staging-feedback.example.com/health || exit 1
          echo "Smoke tests passed"

      - name: Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Staging deploy ${{ job.status }}: ${{ needs.build.outputs.version }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    environment: production
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production'
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.build.outputs.version }}
          path: dist/

      - name: Deploy to Cloudflare Workers (Production)
        run: bunx wrangler deploy --env production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

      - name: Verify deployment
        run: |
          sleep 10
          curl -sf https://feedback.example.com/health || exit 1
          echo "Production deployment verified"

      - name: Create release tag
        run: |
          git tag v${{ needs.build.outputs.version }}
          git push origin v${{ needs.build.outputs.version }}

      - name: Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Production deploy ${{ job.status }}: ${{ needs.build.outputs.version }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

#### Subtask 8.5.1.3: Release Workflow (0.5h)

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        uses: orhun/git-cliff-action@v3
        with:
          config: cliff.toml
          args: --latest --strip header

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body: ${{ steps.changelog.outputs.content }}
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Acceptance Criteria**:
- [ ] All tests run on PR
- [ ] Automatic staging deploy on main merge
- [ ] Manual production deploy with approval
- [ ] Slack notifications for deploy status

---

### Task 8.5.2: Environment Management (1h)

Configure staging and production environments.

#### Subtask 8.5.2.1: Wrangler Environment Config (0.5h)

```toml
# wrangler.toml

name = "collective-vision"
main = "src/worker.ts"
compatibility_date = "2024-01-01"

# Shared configuration
[vars]
APP_NAME = "Collective Vision"

# Development (local)
[env.dev]
name = "collective-vision-dev"

[[env.dev.d1_databases]]
binding = "DB"
database_name = "collective-vision-dev"
database_id = "local"

[[env.dev.kv_namespaces]]
binding = "KV"
id = "local"

# Staging
[env.staging]
name = "collective-vision-staging"
route = "staging-feedback.example.com/*"

[env.staging.vars]
ENVIRONMENT = "staging"
LOG_LEVEL = "debug"
STRIPE_LIVE = "false"

[[env.staging.d1_databases]]
binding = "DB"
database_name = "collective-vision-staging"
database_id = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"  # Replace with actual ID

[[env.staging.kv_namespaces]]
binding = "KV"
id = "yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy"  # Replace with actual ID

[[env.staging.r2_buckets]]
binding = "ATTACHMENTS"
bucket_name = "cv-attachments-staging"

[[env.staging.queues.producers]]
queue = "cv-queue-staging"
binding = "QUEUE"

# Production
[env.production]
name = "collective-vision-production"
route = "feedback.example.com/*"

[env.production.vars]
ENVIRONMENT = "production"
LOG_LEVEL = "info"
STRIPE_LIVE = "true"

[[env.production.d1_databases]]
binding = "DB"
database_name = "collective-vision-production"
database_id = "zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz"  # Replace with actual ID

[[env.production.kv_namespaces]]
binding = "KV"
id = "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"  # Replace with actual ID

[[env.production.r2_buckets]]
binding = "ATTACHMENTS"
bucket_name = "cv-attachments-production"

[[env.production.queues.producers]]
queue = "cv-queue-production"
binding = "QUEUE"

# Vectorize for AI features
[[env.production.vectorize]]
binding = "VECTORIZE"
index_name = "cv-feedback-embeddings"
```

#### Subtask 8.5.2.2: Environment Setup Script (0.5h)

```bash
#!/bin/bash
# scripts/setup-env.sh

set -e

ENV=${1:-staging}

echo "Setting up $ENV environment..."

# Create D1 database
echo "Creating D1 database..."
wrangler d1 create collective-vision-$ENV || true

# Apply schema
echo "Applying database schema..."
wrangler d1 execute collective-vision-$ENV --file=schema.sql --env=$ENV

# Create KV namespace
echo "Creating KV namespace..."
wrangler kv:namespace create CV_$ENV || true

# Create R2 bucket
echo "Creating R2 bucket..."
wrangler r2 bucket create cv-attachments-$ENV || true

# Create Queue
echo "Creating Queue..."
wrangler queues create cv-queue-$ENV || true

# Create Vectorize index
echo "Creating Vectorize index..."
wrangler vectorize create cv-feedback-embeddings-$ENV --dimensions=768 --metric=cosine || true

echo "Environment $ENV setup complete!"
echo ""
echo "Next steps:"
echo "1. Update wrangler.toml with the generated IDs"
echo "2. Set secrets: wrangler secret put STRIPE_SECRET_KEY --env=$ENV"
echo "3. Deploy: wrangler deploy --env=$ENV"
```

**Acceptance Criteria**:
- [ ] Staging environment configured
- [ ] Production environment configured
- [ ] Environment variables properly isolated
- [ ] Setup script functional

---

### Task 8.5.3: Blue-Green Deployment (1h)

Implement zero-downtime deployment with instant rollback.

#### Subtask 8.5.3.1: Deployment Strategy (0.5h)

```typescript
// scripts/deploy.ts
#!/usr/bin/env -S bun run

import { $ } from 'bun';

interface DeployConfig {
  environment: 'staging' | 'production';
  version: string;
  dryRun: boolean;
}

async function deploy(config: DeployConfig): Promise<void> {
  console.log(`Deploying version ${config.version} to ${config.environment}...`);

  const currentVersion = await getCurrentVersion(config.environment);
  console.log(`Current version: ${currentVersion}`);

  // Deploy new version
  console.log('Deploying new version...');
  if (!config.dryRun) {
    await $`wrangler deploy --env=${config.environment}`;
  }

  // Wait for propagation
  console.log('Waiting for deployment propagation...');
  await new Promise(resolve => setTimeout(resolve, 5000));

  // Verify new deployment
  console.log('Verifying deployment...');
  const healthCheck = await verifyDeployment(config.environment);

  if (!healthCheck.success) {
    console.error('Health check failed, rolling back...');
    await rollback(config.environment, currentVersion);
    throw new Error('Deployment failed health check');
  }

  console.log(`Deployment successful! Version: ${config.version}`);

  // Store rollback information
  await storeRollbackInfo(config.environment, {
    previousVersion: currentVersion,
    newVersion: config.version,
    deployedAt: new Date().toISOString(),
  });
}

async function getCurrentVersion(env: string): Promise<string> {
  const response = await fetch(`https://${env === 'production' ? '' : 'staging-'}feedback.example.com/health`);
  const data = await response.json() as { version?: string };
  return data.version || 'unknown';
}

async function verifyDeployment(env: string): Promise<{ success: boolean; error?: string }> {
  const baseUrl = env === 'production'
    ? 'https://feedback.example.com'
    : 'https://staging-feedback.example.com';

  try {
    // Health check
    const health = await fetch(`${baseUrl}/health`);
    if (!health.ok) {
      return { success: false, error: 'Health check failed' };
    }

    // Widget loads
    const widget = await fetch(`${baseUrl}/widget.js`);
    if (!widget.ok) {
      return { success: false, error: 'Widget failed to load' };
    }

    // API responds
    const api = await fetch(`${baseUrl}/api/v1/test/main/feedback`);
    if (!api.ok && api.status !== 404) {
      return { success: false, error: 'API failed to respond' };
    }

    return { success: true };
  } catch (error) {
    return { success: false, error: String(error) };
  }
}

async function rollback(env: string, version: string): Promise<void> {
  console.log(`Rolling back to version ${version}...`);
  // Cloudflare Workers automatically keeps previous versions
  // Use wrangler rollback command
  await $`wrangler rollback --env=${env}`;
  console.log('Rollback complete');
}

async function storeRollbackInfo(
  env: string,
  info: { previousVersion: string; newVersion: string; deployedAt: string }
): Promise<void> {
  // Store in KV for audit trail
  await $`wrangler kv:key put --env=${env} --namespace-id=ROLLBACK_INFO "last_deploy" '${JSON.stringify(info)}'`;
}

// CLI
const args = process.argv.slice(2);
const config: DeployConfig = {
  environment: (args.find(a => a.startsWith('--env='))?.split('=')[1] as any) || 'staging',
  version: args.find(a => a.startsWith('--version='))?.split('=')[1] || 'latest',
  dryRun: args.includes('--dry-run'),
};

deploy(config).catch(console.error);
```

#### Subtask 8.5.3.2: Rollback Procedure (0.5h)

```yaml
# .github/workflows/rollback.yml
name: Rollback

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        type: choice
        options:
          - staging
          - production
      confirm:
        description: 'Type ROLLBACK to confirm'
        required: true

jobs:
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    if: github.event.inputs.confirm == 'ROLLBACK'
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1

      - name: Rollback
        run: bunx wrangler rollback --env=${{ github.event.inputs.environment }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

      - name: Verify rollback
        run: |
          sleep 10
          if [ "${{ github.event.inputs.environment }}" == "production" ]; then
            curl -sf https://feedback.example.com/health || exit 1
          else
            curl -sf https://staging-feedback.example.com/health || exit 1
          fi
          echo "Rollback verified"

      - name: Notify Slack
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "üîô Rollback completed for ${{ github.event.inputs.environment }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

**Acceptance Criteria**:
- [ ] Zero-downtime deployment working
- [ ] Health checks before traffic switch
- [ ] Rollback within 5 minutes
- [ ] Rollback workflow documented

---

### Task 8.5.4: Monitoring & Alerting (1h)

Set up observability for production operations.

#### Subtask 8.5.4.1: Cloudflare Analytics Integration (0.5h)

```typescript
// src/lib/observability.ts

interface LogEvent {
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  context?: Record<string, any>;
  error?: Error;
}

class Logger {
  private env: string;

  constructor(env: string) {
    this.env = env;
  }

  private log(event: LogEvent): void {
    const entry = {
      timestamp: new Date().toISOString(),
      environment: this.env,
      level: event.level,
      message: event.message,
      ...event.context,
      ...(event.error && {
        error: {
          name: event.error.name,
          message: event.error.message,
          stack: event.error.stack,
        },
      }),
    };

    // In Cloudflare Workers, console.log goes to Workers Logs
    console.log(JSON.stringify(entry));
  }

  debug(message: string, context?: Record<string, any>): void {
    if (this.env !== 'production') {
      this.log({ level: 'debug', message, context });
    }
  }

  info(message: string, context?: Record<string, any>): void {
    this.log({ level: 'info', message, context });
  }

  warn(message: string, context?: Record<string, any>): void {
    this.log({ level: 'warn', message, context });
  }

  error(message: string, error?: Error, context?: Record<string, any>): void {
    this.log({ level: 'error', message, context, error });
  }
}

export function createLogger(env: Env): Logger {
  return new Logger(env.ENVIRONMENT || 'development');
}

// Request tracing
export function createRequestContext(request: Request): Record<string, any> {
  return {
    requestId: crypto.randomUUID(),
    method: request.method,
    url: new URL(request.url).pathname,
    userAgent: request.headers.get('User-Agent'),
    ip: request.headers.get('CF-Connecting-IP'),
    country: request.cf?.country,
    colo: request.cf?.colo,
  };
}

// Middleware for request logging
export function withLogging(
  handler: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>
) {
  return async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {
    const logger = createLogger(env);
    const reqContext = createRequestContext(request);
    const start = Date.now();

    logger.info('Request started', reqContext);

    try {
      const response = await handler(request, env, ctx);

      logger.info('Request completed', {
        ...reqContext,
        status: response.status,
        duration: Date.now() - start,
      });

      return response;
    } catch (error) {
      logger.error('Request failed', error as Error, {
        ...reqContext,
        duration: Date.now() - start,
      });
      throw error;
    }
  };
}
```

#### Subtask 8.5.4.2: Alert Configuration (0.5h)

```typescript
// src/lib/alerts.ts

interface AlertConfig {
  name: string;
  condition: string;
  threshold: number;
  window: string;
  severity: 'info' | 'warning' | 'critical';
  channels: ('slack' | 'email' | 'pagerduty')[];
}

const ALERT_CONFIGS: AlertConfig[] = [
  {
    name: 'High Error Rate',
    condition: 'error_rate',
    threshold: 5, // 5% error rate
    window: '5m',
    severity: 'critical',
    channels: ['slack', 'pagerduty'],
  },
  {
    name: 'High Latency P95',
    condition: 'latency_p95',
    threshold: 1000, // 1 second
    window: '5m',
    severity: 'warning',
    channels: ['slack'],
  },
  {
    name: 'Low Request Volume',
    condition: 'request_count',
    threshold: 10, // Less than 10 requests in window
    window: '15m',
    severity: 'info',
    channels: ['slack'],
  },
  {
    name: 'Database Errors',
    condition: 'db_error_count',
    threshold: 5,
    window: '5m',
    severity: 'critical',
    channels: ['slack', 'pagerduty'],
  },
  {
    name: 'Rate Limit Exceeded',
    condition: 'rate_limit_hits',
    threshold: 100,
    window: '1m',
    severity: 'warning',
    channels: ['slack'],
  },
];

// Cloudflare Notifications API integration
interface NotificationPayload {
  alertName: string;
  severity: string;
  value: number;
  threshold: number;
  timestamp: string;
  environment: string;
}

export async function sendAlert(
  payload: NotificationPayload,
  channels: string[],
  env: Env
): Promise<void> {
  const message = formatAlertMessage(payload);

  for (const channel of channels) {
    switch (channel) {
      case 'slack':
        await sendSlackAlert(message, env.SLACK_WEBHOOK_URL);
        break;
      case 'pagerduty':
        await sendPagerDutyAlert(payload, env.PAGERDUTY_ROUTING_KEY);
        break;
      case 'email':
        // Use Cloudflare Email Routing or SendGrid
        break;
    }
  }
}

function formatAlertMessage(payload: NotificationPayload): string {
  const emoji = payload.severity === 'critical' ? 'üö®' :
                payload.severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';

  return `${emoji} *${payload.alertName}*
Environment: ${payload.environment}
Value: ${payload.value} (threshold: ${payload.threshold})
Time: ${payload.timestamp}`;
}

async function sendSlackAlert(message: string, webhookUrl: string): Promise<void> {
  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text: message,
      mrkdwn: true,
    }),
  });
}

async function sendPagerDutyAlert(
  payload: NotificationPayload,
  routingKey: string
): Promise<void> {
  await fetch('https://events.pagerduty.com/v2/enqueue', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      routing_key: routingKey,
      event_action: 'trigger',
      payload: {
        summary: `[${payload.environment}] ${payload.alertName}`,
        severity: payload.severity === 'critical' ? 'critical' : 'warning',
        source: 'collective-vision',
        custom_details: payload,
      },
    }),
  });
}

// Scheduled health check (can be run as Cron Trigger)
export async function runHealthChecks(env: Env): Promise<void> {
  const checks = [
    { name: 'API Health', url: '/health' },
    { name: 'Widget', url: '/widget.js' },
    { name: 'Database', check: () => checkDatabase(env.DB) },
  ];

  const baseUrl = env.ENVIRONMENT === 'production'
    ? 'https://feedback.example.com'
    : 'https://staging-feedback.example.com';

  for (const check of checks) {
    try {
      if (check.url) {
        const response = await fetch(`${baseUrl}${check.url}`);
        if (!response.ok) {
          await sendAlert({
            alertName: `Health Check Failed: ${check.name}`,
            severity: 'critical',
            value: response.status,
            threshold: 200,
            timestamp: new Date().toISOString(),
            environment: env.ENVIRONMENT || 'unknown',
          }, ['slack', 'pagerduty'], env);
        }
      } else if (check.check) {
        await check.check();
      }
    } catch (error) {
      await sendAlert({
        alertName: `Health Check Error: ${check.name}`,
        severity: 'critical',
        value: 0,
        threshold: 1,
        timestamp: new Date().toISOString(),
        environment: env.ENVIRONMENT || 'unknown',
      }, ['slack', 'pagerduty'], env);
    }
  }
}

async function checkDatabase(db: D1Database): Promise<void> {
  await db.prepare('SELECT 1').first();
}
```

**Acceptance Criteria**:
- [ ] Structured logging implemented
- [ ] Request tracing with IDs
- [ ] Alert rules configured
- [ ] Slack/PagerDuty integration working

---

## Definition of Done

- [ ] CI/CD pipeline running all tests
- [ ] Staging environment fully functional
- [ ] Blue-green deployment with health checks
- [ ] Rollback capability tested
- [ ] Monitoring and alerting operational
- [ ] Runbook documentation complete

---

## Technical Notes

### Cloudflare Workers Deployment
- Workers automatically keep 10 previous versions
- Use `wrangler rollback` for instant rollback
- Cron Triggers for scheduled health checks

### Environment Secrets
Set secrets using Wrangler:
```bash
wrangler secret put STRIPE_SECRET_KEY --env=production
wrangler secret put SLACK_WEBHOOK_URL --env=production
wrangler secret put PAGERDUTY_ROUTING_KEY --env=production
```

### Monitoring Best Practices
- Use structured JSON logging for easy parsing
- Include request IDs for tracing
- Set up dashboards in Cloudflare Analytics

---

## Related Files

- `.github/workflows/` - CI/CD workflows
- `wrangler.toml` - Environment configuration
- `scripts/deploy.ts` - Deployment script
- `scripts/setup-env.sh` - Environment setup
- `src/lib/observability.ts` - Logging utilities
- `src/lib/alerts.ts` - Alerting functions
