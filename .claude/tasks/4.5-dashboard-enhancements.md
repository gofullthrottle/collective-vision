# Epic 4.5: Dashboard Enhancements

## Methodology Guidance
**SPECTRA Phase**: Implementation/UX
**Approach**: Enhance admin dashboard usability
**Tools**: Polling, widgets, saved views

## Wave Context
**Wave**: 4 - Analytics & Integrations
**Priority**: P3 (quality of life)
**Dependencies**: Wave 1 (admin UI), Wave 4.1-4.2 (analytics)
**Estimated Duration**: 2 hours

## Quality Requirements
- Real-time updates without page refresh
- Responsive on mobile
- Views persist across sessions
- No performance degradation

---

## Tasks

### 4.5.1 Real-Time Updates (1h)
**Objective**: Auto-refresh dashboard data

**Steps**:
1. Create polling infrastructure:
   ```typescript
   // src/lib/realtime/polling.ts

   interface PollingConfig {
     endpoint: string;
     interval: number;  // milliseconds
     enabled: boolean;
     onUpdate: (data: unknown) => void;
   }

   class DashboardPoller {
     private polls: Map<string, NodeJS.Timer> = new Map();
     private lastData: Map<string, string> = new Map();

     start(id: string, config: PollingConfig): void {
       if (!config.enabled) return;

       const poll = async () => {
         try {
           const response = await fetch(config.endpoint);
           const data = await response.json();
           const dataHash = JSON.stringify(data);

           // Only trigger update if data changed
           if (this.lastData.get(id) !== dataHash) {
             this.lastData.set(id, dataHash);
             config.onUpdate(data);
           }
         } catch (error) {
           console.error(`Polling error for ${id}:`, error);
         }
       };

       // Initial fetch
       poll();

       // Start interval
       const timer = setInterval(poll, config.interval);
       this.polls.set(id, timer);
     }

     stop(id: string): void {
       const timer = this.polls.get(id);
       if (timer) {
         clearInterval(timer);
         this.polls.delete(id);
       }
     }

     stopAll(): void {
       for (const [id] of this.polls) {
         this.stop(id);
       }
     }

     setEnabled(id: string, enabled: boolean): void {
       // Implementation to pause/resume polling
     }
   }

   export const dashboardPoller = new DashboardPoller();
   ```

2. Create real-time update endpoint:
   ```typescript
   // GET /api/v1/workspaces/:id/realtime/updates
   async function handleRealtimeUpdates(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const url = new URL(request.url);
     const since = url.searchParams.get('since');  // ISO timestamp

     await requirePermission(request, env, workspaceId, 'dashboard:view');

     // Get recent changes
     const updates: {
       new_feedback: number;
       new_votes: number;
       new_comments: number;
       status_changes: Array<{ id: string; title: string; new_status: string }>;
     } = {
       new_feedback: 0,
       new_votes: 0,
       new_comments: 0,
       status_changes: []
     };

     if (since) {
       const counts = await env.DB.prepare(`
         SELECT
           (SELECT COUNT(*) FROM feedback_items fi
            JOIN boards b ON fi.board_id = b.id
            WHERE b.workspace_id = ? AND fi.created_at > ?) as new_feedback,
           (SELECT COUNT(*) FROM feedback_votes fv
            JOIN feedback_items fi ON fv.feedback_id = fi.id
            JOIN boards b ON fi.board_id = b.id
            WHERE b.workspace_id = ? AND fv.created_at > ?) as new_votes,
           (SELECT COUNT(*) FROM feedback_comments fc
            JOIN feedback_items fi ON fc.feedback_id = fi.id
            JOIN boards b ON fi.board_id = b.id
            WHERE b.workspace_id = ? AND fc.created_at > ?) as new_comments
       `).bind(workspaceId, since, workspaceId, since, workspaceId, since).first();

       updates.new_feedback = counts?.new_feedback as number || 0;
       updates.new_votes = counts?.new_votes as number || 0;
       updates.new_comments = counts?.new_comments as number || 0;

       // Get status changes
       const changes = await env.DB.prepare(`
         SELECT fi.id, fi.title, fsh.new_status
         FROM feedback_status_history fsh
         JOIN feedback_items fi ON fsh.feedback_id = fi.id
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ? AND fsh.changed_at > ?
         ORDER BY fsh.changed_at DESC
         LIMIT 10
       `).bind(workspaceId, since).all();

       updates.status_changes = changes.results as typeof updates.status_changes;
     }

     return jsonResponse({
       updates,
       timestamp: new Date().toISOString()
     });
   }
   ```

3. Create notification indicator:
   ```typescript
   // Client-side notification badge
   interface NotificationBadge {
     count: number;
     types: {
       feedback: number;
       votes: number;
       comments: number;
     };
   }

   function updateNotificationBadge(updates: NotificationBadge): void {
     const badge = document.getElementById('notification-badge');
     if (!badge) return;

     const total = updates.count;
     if (total > 0) {
       badge.textContent = total > 99 ? '99+' : String(total);
       badge.classList.remove('hidden');
     } else {
       badge.classList.add('hidden');
     }
   }
   ```

**Acceptance Criteria**:
- [ ] Dashboard updates without refresh
- [ ] New items highlighted
- [ ] Can disable auto-refresh
- [ ] Efficient polling (only changes)

---

### 4.5.2 Customizable Widgets (0.5h)
**Objective**: Widget-based dashboard layout

**Steps**:
1. Create widget configuration:
   ```typescript
   // src/lib/dashboard/widgets.ts

   interface DashboardWidget {
     id: string;
     type: 'metrics' | 'recent_feedback' | 'themes' | 'trends' | 'activity';
     title: string;
     position: { row: number; col: number };
     size: { width: number; height: number };  // Grid units
     config: Record<string, unknown>;
   }

   interface DashboardLayout {
     widgets: DashboardWidget[];
     columns: number;  // Grid columns (default 12)
   }

   const DEFAULT_LAYOUT: DashboardLayout = {
     columns: 12,
     widgets: [
       {
         id: 'metrics',
         type: 'metrics',
         title: 'Key Metrics',
         position: { row: 0, col: 0 },
         size: { width: 12, height: 1 },
         config: {}
       },
       {
         id: 'recent',
         type: 'recent_feedback',
         title: 'Recent Feedback',
         position: { row: 1, col: 0 },
         size: { width: 6, height: 2 },
         config: { limit: 10 }
       },
       {
         id: 'themes',
         type: 'themes',
         title: 'Top Themes',
         position: { row: 1, col: 6 },
         size: { width: 6, height: 2 },
         config: { limit: 5 }
       },
       {
         id: 'trends',
         type: 'trends',
         title: 'Activity Trend',
         position: { row: 3, col: 0 },
         size: { width: 12, height: 1 },
         config: { days: 30 }
       }
     ]
   };

   // Widget type definitions
   const WIDGET_TYPES = {
     metrics: {
       name: 'Key Metrics',
       description: 'Summary of feedback, votes, and sentiment',
       minWidth: 6,
       minHeight: 1
     },
     recent_feedback: {
       name: 'Recent Feedback',
       description: 'Latest submitted feedback items',
       minWidth: 4,
       minHeight: 2
     },
     themes: {
       name: 'Top Themes',
       description: 'Most active feedback themes',
       minWidth: 4,
       minHeight: 2
     },
     trends: {
       name: 'Activity Trend',
       description: 'Feedback activity over time',
       minWidth: 6,
       minHeight: 1
     },
     activity: {
       name: 'Recent Activity',
       description: 'Recent votes and comments',
       minWidth: 4,
       minHeight: 2
     }
   };
   ```

2. Create layout persistence:
   ```typescript
   // PATCH /api/v1/users/:id/preferences/dashboard
   async function handleUpdateDashboardLayout(request: Request, env: Env): Promise<Response> {
     const { user } = await requireAuth(request, env);
     const input = await validateBody(request, z.object({
       layout: z.object({
         columns: z.number().min(6).max(16),
         widgets: z.array(z.object({
           id: z.string(),
           type: z.string(),
           title: z.string(),
           position: z.object({ row: z.number(), col: z.number() }),
           size: z.object({ width: z.number(), height: z.number() }),
           config: z.record(z.unknown())
         }))
       })
     }));

     await env.DB.prepare(`
       UPDATE users SET dashboard_layout = ?, updated_at = datetime('now')
       WHERE id = ?
     `).bind(JSON.stringify(input.layout), user.id).run();

     return jsonResponse({ saved: true });
   }
   ```

**Acceptance Criteria**:
- [ ] Widgets configurable
- [ ] Layout persisted
- [ ] Responsive on mobile

---

### 4.5.3 Saved Filters and Views (0.5h)
**Objective**: Save and share filter configurations

**Steps**:
1. Create saved views table:
   ```sql
   CREATE TABLE saved_views (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     filters TEXT NOT NULL,  -- JSON
     sort TEXT,
     is_default INTEGER DEFAULT 0,
     is_shared INTEGER DEFAULT 0,
     created_by TEXT NOT NULL,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   CREATE INDEX idx_saved_views_workspace ON saved_views(workspace_id, created_by);
   ```

2. Create views API:
   ```typescript
   // POST /api/v1/workspaces/:id/views
   async function handleCreateView(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, z.object({
       name: z.string().min(1).max(50),
       filters: z.object({
         status: z.array(z.string()).optional(),
         tags: z.array(z.string()).optional(),
         board_id: z.string().optional(),
         sentiment_range: z.object({ min: z.number(), max: z.number() }).optional(),
         priority_min: z.number().optional(),
         date_range: z.object({ start: z.string(), end: z.string() }).optional()
       }),
       sort: z.object({
         field: z.string(),
         order: z.enum(['asc', 'desc'])
       }).optional(),
       is_shared: z.boolean().default(false)
     }));

     const { user } = await requirePermission(request, env, workspaceId, 'views:create');

     const id = generateId('view');
     await env.DB.prepare(`
       INSERT INTO saved_views (id, workspace_id, name, filters, sort, is_shared, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?)
     `).bind(
       id,
       workspaceId,
       input.name,
       JSON.stringify(input.filters),
       input.sort ? JSON.stringify(input.sort) : null,
       input.is_shared ? 1 : 0,
       user.id
     ).run();

     return jsonResponse({
       id,
       name: input.name,
       share_url: input.is_shared ? `/views/${id}` : null
     }, 201);
   }

   // GET /api/v1/workspaces/:id/views
   async function handleListViews(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const { user } = await requirePermission(request, env, workspaceId, 'views:read');

     const views = await env.DB.prepare(`
       SELECT * FROM saved_views
       WHERE workspace_id = ?
         AND (created_by = ? OR is_shared = 1)
       ORDER BY name ASC
     `).bind(workspaceId, user.id).all();

     return jsonResponse({
       views: views.results.map(v => ({
         id: v.id,
         name: v.name,
         filters: JSON.parse(v.filters as string),
         sort: v.sort ? JSON.parse(v.sort as string) : null,
         is_shared: v.is_shared === 1,
         is_mine: v.created_by === user.id,
         share_url: v.is_shared === 1 ? `/views/${v.id}` : null
       }))
     });
   }

   // GET /api/v1/views/:id
   async function handleGetView(request: Request, env: Env): Promise<Response> {
     const { viewId } = parseParams(request);

     const view = await env.DB.prepare(`
       SELECT * FROM saved_views WHERE id = ?
     `).bind(viewId).first();

     if (!view) {
       return errorResponse('NOT_FOUND', 'View not found', 404);
     }

     // Shared views accessible without auth
     if (view.is_shared !== 1) {
       const { user } = await requireAuth(request, env);
       if (view.created_by !== user.id) {
         return errorResponse('FORBIDDEN', 'Access denied', 403);
       }
     }

     return jsonResponse({
       id: view.id,
       name: view.name,
       filters: JSON.parse(view.filters as string),
       sort: view.sort ? JSON.parse(view.sort as string) : null,
       workspace_id: view.workspace_id
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Filters saveable with name
- [ ] Views listed in sidebar
- [ ] Shared views accessible via link
- [ ] Can set default view

---

## Definition of Done
- [ ] Real-time updates working
- [ ] Widgets configurable
- [ ] Saved views functional
- [ ] Mobile responsive
- [ ] No performance degradation

## Technical Notes
- Polling interval: 5 seconds (configurable)
- Dashboard layout uses CSS Grid
- Views stored per-user
- Shared views use public URLs

## Related Files
- `src/lib/realtime/polling.ts` - Polling infrastructure
- `src/lib/dashboard/widgets.ts` - Widget definitions
- `src/routes/views.ts` - Saved views API
- `src/routes/realtime.ts` - Real-time updates
