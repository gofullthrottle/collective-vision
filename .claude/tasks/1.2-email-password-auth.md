# Epic 1.2: Email/Password Authentication

## Methodology Guidance
**SPECTRA Phase**: Implementation/Core Auth
**Approach**: Security-first with proper password hashing, token management
**Tools**: bcrypt/argon2, JWT, Resend for email

## Wave Context
**Wave**: 1 - Authentication & User Management
**Priority**: Critical (foundational auth flow)
**Dependencies**: Epic 1.1 (database schema)
**Estimated Duration**: 8 hours

## Quality Requirements
- Passwords hashed with bcrypt (work factor 10+) or argon2
- JWTs signed with HS256 minimum
- No user enumeration via error messages
- All security tokens are cryptographically random

---

## Tasks

### 1.2.1 Password Hashing Utility (1h)
**Objective**: Secure password hashing and verification

**Steps**:
1. Install Workers-compatible hashing library:
   ```bash
   npm install bcryptjs
   # OR for better security if Workers supports it:
   npm install @node-rs/argon2
   ```

2. Create password utility module:
   ```typescript
   // src/lib/auth/password.ts
   import bcrypt from 'bcryptjs';

   const WORK_FACTOR = 10;
   const MIN_PASSWORD_LENGTH = 8;

   export async function hashPassword(password: string): Promise<string> {
     validatePasswordStrength(password);
     return bcrypt.hash(password, WORK_FACTOR);
   }

   export async function verifyPassword(
     password: string,
     hash: string
   ): Promise<boolean> {
     // Timing-safe comparison built into bcrypt.compare
     return bcrypt.compare(password, hash);
   }

   export function validatePasswordStrength(password: string): void {
     if (password.length < MIN_PASSWORD_LENGTH) {
       throw new ValidationError('Password must be at least 8 characters');
     }
     // Add more rules as needed (uppercase, number, special char)
   }
   ```

3. Document password requirements in API docs

**Acceptance Criteria**:
- [ ] Passwords hashed with work factor 10+
- [ ] Verification is timing-safe
- [ ] Password min 8 chars enforced
- [ ] Clear error messages for invalid passwords

---

### 1.2.2 Sign-Up Endpoint (2h)
**Objective**: User registration with email verification

**Steps**:
1. Create signup endpoint:
   ```typescript
   // POST /api/v1/auth/signup
   const signupSchema = z.object({
     email: z.string().email(),
     password: z.string().min(8),
     name: z.string().min(1).max(100).optional()
   });

   async function handleSignup(request: Request, env: Env) {
     const { email, password, name } = await validateBody(request, signupSchema);

     // Check email uniqueness
     const existing = await env.DB.prepare(
       'SELECT id FROM users WHERE email = ?'
     ).bind(email.toLowerCase()).first();

     if (existing) {
       return errorResponse('EMAIL_EXISTS', 'Email already registered', 409);
     }

     // Create user
     const userId = generateId('user');
     const passwordHash = await hashPassword(password);

     await env.DB.prepare(`
       INSERT INTO users (id, email, password_hash, name)
       VALUES (?, ?, ?, ?)
     `).bind(userId, email.toLowerCase(), passwordHash, name || null).run();

     // Generate verification token
     const verifyToken = generateSecureToken();
     await storeVerificationToken(userId, verifyToken, env);

     // Send verification email
     await sendVerificationEmail(email, verifyToken, env);

     return jsonResponse({
       user: { id: userId, email, name, email_verified: false },
       message: 'Verification email sent'
     }, 201);
   }
   ```

2. Implement verification email sending via Resend:
   ```typescript
   async function sendVerificationEmail(
     email: string,
     token: string,
     env: Env
   ) {
     const verifyUrl = `${env.APP_URL}/verify-email?token=${token}`;

     await fetch('https://api.resend.com/emails', {
       method: 'POST',
       headers: {
         'Authorization': `Bearer ${env.RESEND_API_KEY}`,
         'Content-Type': 'application/json'
       },
       body: JSON.stringify({
         from: 'noreply@collectivevision.app',
         to: email,
         subject: 'Verify your email',
         html: `<a href="${verifyUrl}">Click to verify</a>`
       })
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Duplicate email returns 409
- [ ] Weak password returns 400
- [ ] Email sent on success
- [ ] User created with `email_verified = false`

---

### 1.2.3 Email Verification (1h)
**Objective**: Verify user email addresses

**Steps**:
1. Create verification endpoint:
   ```typescript
   // POST /api/v1/auth/verify-email
   const verifyEmailSchema = z.object({
     token: z.string().min(32)
   });

   async function handleVerifyEmail(request: Request, env: Env) {
     const { token } = await validateBody(request, verifyEmailSchema);
     const tokenHash = hashToken(token);

     // Find and validate token
     const tokenRecord = await env.DB.prepare(`
       SELECT user_id, expires_at FROM email_verification_tokens
       WHERE token_hash = ?
     `).bind(tokenHash).first();

     if (!tokenRecord || new Date(tokenRecord.expires_at) < new Date()) {
       return errorResponse('INVALID_TOKEN', 'Invalid or expired token', 400);
     }

     // Mark user as verified
     await env.DB.batch([
       env.DB.prepare('UPDATE users SET email_verified = 1 WHERE id = ?')
         .bind(tokenRecord.user_id),
       env.DB.prepare('DELETE FROM email_verification_tokens WHERE token_hash = ?')
         .bind(tokenHash)
     ]);

     return jsonResponse({ message: 'Email verified successfully' });
   }
   ```

**Acceptance Criteria**:
- [ ] Valid token verifies user
- [ ] Expired token returns 400
- [ ] Token is single-use (deleted after use)
- [ ] Invalid token returns same error as expired (no enumeration)

---

### 1.2.4 Login Endpoint (1.5h)
**Objective**: Authenticate users and issue tokens

**Steps**:
1. Create login endpoint:
   ```typescript
   // POST /api/v1/auth/login
   async function handleLogin(request: Request, env: Env) {
     const { email, password } = await validateBody(request, loginSchema);

     // Find user
     const user = await env.DB.prepare(
       'SELECT * FROM users WHERE email = ?'
     ).bind(email.toLowerCase()).first();

     // Generic error to prevent enumeration
     const authError = () => errorResponse(
       'INVALID_CREDENTIALS',
       'Invalid email or password',
       401
     );

     if (!user || !user.password_hash) {
       return authError();
     }

     // Verify password
     const valid = await verifyPassword(password, user.password_hash);
     if (!valid) {
       return authError();
     }

     // Check email verified
     if (!user.email_verified) {
       return errorResponse(
         'EMAIL_NOT_VERIFIED',
         'Please verify your email first',
         403,
         { resend_available: true }
       );
     }

     // Generate tokens
     const accessToken = await generateAccessToken(user, env);
     const refreshToken = await generateRefreshToken(user, env);

     // Create session
     await createSession(user.id, refreshToken, env);

     return jsonResponse({
       user: sanitizeUser(user),
       access_token: accessToken,
       expires_in: 900  // 15 minutes
     });
   }
   ```

2. Implement JWT generation:
   ```typescript
   async function generateAccessToken(user: User, env: Env): Promise<string> {
     const payload = {
       sub: user.id,
       email: user.email,
       iat: Math.floor(Date.now() / 1000),
       exp: Math.floor(Date.now() / 1000) + 900  // 15 minutes
     };
     return jwt.sign(payload, env.JWT_SECRET);
   }
   ```

**Acceptance Criteria**:
- [ ] Invalid credentials return 401
- [ ] Unverified email returns 403 with resend option
- [ ] Tokens properly signed with secret
- [ ] Refresh token stored as session

---

### 1.2.5 Token Refresh (1h)
**Objective**: Rotate refresh tokens and issue new access tokens

**Steps**:
1. Create refresh endpoint:
   ```typescript
   // POST /api/v1/auth/refresh
   async function handleRefresh(request: Request, env: Env) {
     const { refresh_token } = await validateBody(request, refreshSchema);
     const tokenHash = hashToken(refresh_token);

     // Find session
     const session = await env.DB.prepare(`
       SELECT s.*, u.* FROM sessions s
       JOIN users u ON s.user_id = u.id
       WHERE s.token_hash = ? AND s.expires_at > datetime('now')
     `).bind(tokenHash).first();

     if (!session) {
       return errorResponse('INVALID_TOKEN', 'Invalid or expired refresh token', 401);
     }

     // Rotate refresh token (invalidate old, create new)
     const newRefreshToken = generateSecureToken();
     const newTokenHash = hashToken(newRefreshToken);

     await env.DB.batch([
       env.DB.prepare('DELETE FROM sessions WHERE token_hash = ?').bind(tokenHash),
       env.DB.prepare(`
         INSERT INTO sessions (id, user_id, token_hash, expires_at)
         VALUES (?, ?, ?, datetime('now', '+7 days'))
       `).bind(generateId('sess'), session.user_id, newTokenHash)
     ]);

     // Generate new access token
     const accessToken = await generateAccessToken(session, env);

     return jsonResponse({
       access_token: accessToken,
       refresh_token: newRefreshToken,
       expires_in: 900
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Expired refresh token returns 401
- [ ] Used refresh token returns 401 (rotation)
- [ ] New tokens issued on success
- [ ] Old session invalidated

---

### 1.2.6 Password Reset Flow (1.5h)
**Objective**: Secure password reset via email

**Steps**:
1. Request reset endpoint:
   ```typescript
   // POST /api/v1/auth/forgot-password
   async function handleForgotPassword(request: Request, env: Env) {
     const { email } = await validateBody(request, forgotPasswordSchema);

     // Always return same response (prevent enumeration)
     const successResponse = jsonResponse({
       message: 'If an account exists, a reset email has been sent'
     });

     const user = await env.DB.prepare(
       'SELECT id FROM users WHERE email = ?'
     ).bind(email.toLowerCase()).first();

     if (!user) {
       return successResponse;  // Same response
     }

     // Generate reset token (1 hour expiry)
     const resetToken = generateSecureToken();
     await storeResetToken(user.id, resetToken, env);
     await sendResetEmail(email, resetToken, env);

     return successResponse;
   }
   ```

2. Complete reset endpoint:
   ```typescript
   // POST /api/v1/auth/reset-password
   async function handleResetPassword(request: Request, env: Env) {
     const { token, new_password } = await validateBody(request, resetPasswordSchema);
     const tokenHash = hashToken(token);

     const tokenRecord = await env.DB.prepare(`
       SELECT user_id, expires_at, used FROM password_reset_tokens
       WHERE token_hash = ?
     `).bind(tokenHash).first();

     if (!tokenRecord || tokenRecord.used || new Date(tokenRecord.expires_at) < new Date()) {
       return errorResponse('INVALID_TOKEN', 'Invalid or expired reset token', 400);
     }

     // Update password and invalidate all sessions
     const passwordHash = await hashPassword(new_password);

     await env.DB.batch([
       env.DB.prepare('UPDATE users SET password_hash = ? WHERE id = ?')
         .bind(passwordHash, tokenRecord.user_id),
       env.DB.prepare('UPDATE password_reset_tokens SET used = 1 WHERE token_hash = ?')
         .bind(tokenHash),
       env.DB.prepare('DELETE FROM sessions WHERE user_id = ?')
         .bind(tokenRecord.user_id)
     ]);

     return jsonResponse({ message: 'Password reset successfully' });
   }
   ```

**Acceptance Criteria**:
- [ ] Reset email sent to valid users
- [ ] Same response for invalid email (no enumeration)
- [ ] Old sessions invalidated on password reset
- [ ] Reset token expires after 1 hour

---

## Definition of Done
- [ ] Complete signup → verify → login flow working
- [ ] Password reset flow complete
- [ ] All tokens properly secured
- [ ] No user enumeration vulnerabilities
- [ ] Tests cover all auth flows

## Technical Notes
- Use `crypto.randomBytes(32)` for secure token generation in Workers
- Store only token hashes (SHA256) in database
- Consider rate limiting on auth endpoints (5/min)
- Log all auth events to audit log

## Related Files
- `src/lib/auth/password.ts` - Password hashing
- `src/lib/auth/tokens.ts` - Token generation
- `src/lib/auth/jwt.ts` - JWT utilities
- `src/routes/auth.ts` - Auth endpoints
