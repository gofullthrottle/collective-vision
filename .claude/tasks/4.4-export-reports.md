# Epic 4.4: Export Reports

## Methodology Guidance
**SPECTRA Phase**: Implementation/Reporting
**Approach**: Build export functionality for data portability
**Tools**: CSV streaming, PDF generation, scheduled jobs

## Wave Context
**Wave**: 4 - Analytics & Integrations
**Priority**: P2 (enhances value prop)
**Dependencies**: Wave 4.1-4.2 (analytics data)
**Estimated Duration**: 4 hours

## Quality Requirements
- Large exports don't timeout
- PDF reports professional quality
- Scheduled reports delivered reliably
- Filters respected in exports

---

## Tasks

### 4.4.1 CSV Export (1h)
**Objective**: Export feedback data to CSV

**Steps**:
1. Create streaming CSV export:
   ```typescript
   // src/routes/exports.ts

   // GET /api/v1/workspaces/:id/export/csv
   async function handleCSVExport(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     await requirePermission(request, env, workspaceId, 'export:create');

     const url = new URL(request.url);
     const boardId = url.searchParams.get('board_id');
     const status = url.searchParams.getAll('status');
     const createdAfter = url.searchParams.get('created_after');
     const createdBefore = url.searchParams.get('created_before');
     const includeComments = url.searchParams.get('include_comments') === 'true';

     // Build query with filters
     let query = `
       SELECT
         fi.id,
         fi.title,
         fi.description,
         fi.status,
         fi.source,
         fi.vote_count,
         fi.sentiment_score,
         fi.priority_score,
         fi.created_at,
         fi.updated_at,
         b.name as board_name,
         eu.email as submitter_email,
         GROUP_CONCAT(DISTINCT ft.name) as tags
       FROM feedback_items fi
       JOIN boards b ON fi.board_id = b.id
       LEFT JOIN end_users eu ON fi.user_id = eu.id
       LEFT JOIN feedback_item_tags fit ON fi.id = fit.feedback_id
       LEFT JOIN feedback_tags ft ON fit.tag_id = ft.id
       WHERE b.workspace_id = ?
     `;
     const params: unknown[] = [workspaceId];

     if (boardId) {
       query += ` AND fi.board_id = ?`;
       params.push(boardId);
     }

     if (status.length > 0) {
       query += ` AND fi.status IN (${status.map(() => '?').join(',')})`;
       params.push(...status);
     }

     if (createdAfter) {
       query += ` AND fi.created_at >= ?`;
       params.push(createdAfter);
     }

     if (createdBefore) {
       query += ` AND fi.created_at <= ?`;
       params.push(createdBefore);
     }

     query += ` GROUP BY fi.id ORDER BY fi.created_at DESC`;

     const items = await env.DB.prepare(query).bind(...params).all();

     // Build CSV
     const headers = [
       'ID', 'Title', 'Description', 'Status', 'Source', 'Votes',
       'Sentiment', 'Priority', 'Board', 'Submitter', 'Tags',
       'Created', 'Updated'
     ];

     let csv = headers.join(',') + '\n';

     for (const item of items.results) {
       const row = [
         item.id,
         escapeCSV(item.title as string),
         escapeCSV(item.description as string || ''),
         item.status,
         item.source,
         item.vote_count,
         item.sentiment_score,
         item.priority_score,
         escapeCSV(item.board_name as string),
         item.submitter_email || '',
         item.tags || '',
         item.created_at,
         item.updated_at
       ];
       csv += row.join(',') + '\n';
     }

     // Include comments if requested
     if (includeComments) {
       csv += '\n\n--- Comments ---\n';
       csv += 'Feedback ID,Comment,Author,Created\n';

       const comments = await env.DB.prepare(`
         SELECT fc.feedback_id, fc.body, eu.name as author, fc.created_at
         FROM feedback_comments fc
         LEFT JOIN end_users eu ON fc.user_id = eu.id
         JOIN feedback_items fi ON fc.feedback_id = fi.id
         JOIN boards b ON fi.board_id = b.id
         WHERE b.workspace_id = ?
         ORDER BY fc.feedback_id, fc.created_at
       `).bind(workspaceId).all();

       for (const comment of comments.results) {
         const row = [
           comment.feedback_id,
           escapeCSV(comment.body as string),
           escapeCSV(comment.author as string || 'Anonymous'),
           comment.created_at
         ];
         csv += row.join(',') + '\n';
       }
     }

     const filename = `feedback-export-${new Date().toISOString().split('T')[0]}.csv`;

     return new Response(csv, {
       headers: {
         'Content-Type': 'text/csv',
         'Content-Disposition': `attachment; filename="${filename}"`
       }
     });
   }

   function escapeCSV(value: string): string {
     if (value.includes(',') || value.includes('"') || value.includes('\n')) {
       return `"${value.replace(/"/g, '""')}"`;
     }
     return value;
   }
   ```

**Acceptance Criteria**:
- [ ] All data exportable
- [ ] Filters respected
- [ ] Comments optional
- [ ] Large exports work

---

### 4.4.2 PDF Report Generation (1.5h)
**Objective**: Generate professional PDF reports

**Steps**:
1. Create report generation endpoint:
   ```typescript
   // POST /api/v1/workspaces/:id/reports
   async function handleGenerateReport(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, z.object({
       type: z.enum(['summary', 'detailed', 'themes']),
       date_range: z.object({
         start: z.string(),
         end: z.string()
       }),
       format: z.enum(['pdf', 'html']).default('pdf'),
       board_id: z.string().optional()
     }));

     const { user } = await requirePermission(request, env, workspaceId, 'export:create');

     // Create report job
     const reportId = generateId('rpt');
     await env.DB.prepare(`
       INSERT INTO reports (id, workspace_id, type, config, status, created_by, created_at)
       VALUES (?, ?, ?, ?, 'generating', ?, datetime('now'))
     `).bind(
       reportId,
       workspaceId,
       input.type,
       JSON.stringify(input),
       user.id
     ).run();

     // Queue report generation
     await env.REPORT_QUEUE.send({
       reportId,
       workspaceId,
       config: input
     });

     return jsonResponse({
       report_id: reportId,
       status: 'generating',
       estimated_seconds: 30
     }, 202);
   }
   ```

2. Create report worker:
   ```typescript
   // src/lib/reports/generator.ts

   import { jsPDF } from 'jspdf';
   import 'jspdf-autotable';

   export async function generatePDFReport(
     reportId: string,
     workspaceId: string,
     config: ReportConfig,
     env: Env
   ): Promise<void> {
     try {
       const workspace = await env.DB.prepare(
         'SELECT name, logo_url FROM workspaces WHERE id = ?'
       ).bind(workspaceId).first();

       const pdf = new jsPDF();

       // Header with branding
       pdf.setFontSize(24);
       pdf.text(workspace?.name as string || 'Feedback Report', 20, 30);

       pdf.setFontSize(12);
       pdf.text(`Report Period: ${config.date_range.start} to ${config.date_range.end}`, 20, 45);
       pdf.text(`Generated: ${new Date().toISOString()}`, 20, 52);

       // Executive Summary
       const summary = await getReportSummary(workspaceId, config, env);

       pdf.setFontSize(16);
       pdf.text('Executive Summary', 20, 70);

       pdf.setFontSize(11);
       pdf.text(`Total Feedback: ${summary.total_feedback}`, 25, 82);
       pdf.text(`Total Votes: ${summary.total_votes}`, 25, 89);
       pdf.text(`New This Period: ${summary.new_feedback}`, 25, 96);
       pdf.text(`Completed: ${summary.completed}`, 25, 103);
       pdf.text(`Average Sentiment: ${summary.avg_sentiment.toFixed(2)}`, 25, 110);

       // Key Metrics Table
       pdf.autoTable({
         startY: 125,
         head: [['Metric', 'Current Period', 'Previous', 'Change']],
         body: [
           ['Submissions', summary.new_feedback, summary.prev_feedback, summary.feedback_change],
           ['Votes', summary.votes_period, summary.prev_votes, summary.votes_change],
           ['Resolution Rate', summary.resolution_rate + '%', summary.prev_resolution + '%', summary.resolution_change]
         ],
         theme: 'striped',
         headStyles: { fillColor: [66, 133, 244] }
       });

       // Top Feedback
       pdf.setFontSize(16);
       pdf.text('Top Feedback by Votes', 20, pdf.lastAutoTable.finalY + 20);

       const topFeedback = await getTopFeedback(workspaceId, config, env);

       pdf.autoTable({
         startY: pdf.lastAutoTable.finalY + 30,
         head: [['Title', 'Votes', 'Status', 'Sentiment']],
         body: topFeedback.map(f => [
           f.title.substring(0, 50),
           f.vote_count,
           f.status,
           f.sentiment_score?.toFixed(2) || 'N/A'
         ]),
         theme: 'striped'
       });

       // Theme Analysis
       if (config.type !== 'summary') {
         pdf.addPage();
         pdf.setFontSize(16);
         pdf.text('Theme Analysis', 20, 30);

         const themes = await getThemeAnalysis(workspaceId, config, env);

         pdf.autoTable({
           startY: 40,
           head: [['Theme', 'Items', 'Trend', 'Top Issue']],
           body: themes.map(t => [
             t.name,
             t.item_count,
             t.trend,
             t.top_issue?.substring(0, 40) || ''
           ]),
           theme: 'striped'
         });
       }

       // Save to R2
       const pdfBuffer = pdf.output('arraybuffer');
       const filename = `reports/${workspaceId}/${reportId}.pdf`;

       await env.R2.put(filename, pdfBuffer, {
         httpMetadata: { contentType: 'application/pdf' }
       });

       // Update report status
       const downloadUrl = await env.R2.get(filename);
       await env.DB.prepare(`
         UPDATE reports
         SET status = 'completed', download_url = ?, completed_at = datetime('now')
         WHERE id = ?
       `).bind(`/api/v1/reports/${reportId}/download`, reportId).run();

     } catch (error) {
       await env.DB.prepare(`
         UPDATE reports SET status = 'failed', error = ? WHERE id = ?
       `).bind(error instanceof Error ? error.message : 'Unknown error', reportId).run();
     }
   }
   ```

3. Create reports table:
   ```sql
   CREATE TABLE reports (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     type TEXT NOT NULL,
     config TEXT NOT NULL,
     status TEXT DEFAULT 'pending',  -- pending, generating, completed, failed
     download_url TEXT,
     error TEXT,
     created_by TEXT NOT NULL,
     created_at TEXT DEFAULT (datetime('now')),
     completed_at TEXT,
     expires_at TEXT,
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   CREATE INDEX idx_reports_workspace ON reports(workspace_id, created_at);
   ```

**Acceptance Criteria**:
- [ ] Professional PDF output
- [ ] Charts and tables included
- [ ] Branding applied
- [ ] Downloadable

---

### 4.4.3 Scheduled Reports (1h)
**Objective**: Automatically generate and deliver reports

**Steps**:
1. Create scheduled reports table:
   ```sql
   CREATE TABLE scheduled_reports (
     id TEXT PRIMARY KEY,
     workspace_id TEXT NOT NULL,
     name TEXT NOT NULL,
     type TEXT NOT NULL,
     config TEXT NOT NULL,
     frequency TEXT NOT NULL,  -- daily, weekly, monthly
     day_of_week INTEGER,  -- 0-6 for weekly
     day_of_month INTEGER,  -- 1-31 for monthly
     time_utc TEXT DEFAULT '06:00',
     recipients TEXT NOT NULL,  -- JSON array of emails
     is_active INTEGER DEFAULT 1,
     last_run_at TEXT,
     next_run_at TEXT,
     created_at TEXT DEFAULT (datetime('now')),
     FOREIGN KEY (workspace_id) REFERENCES workspaces(id)
   );

   CREATE INDEX idx_scheduled_reports_next ON scheduled_reports(next_run_at, is_active);
   ```

2. Create scheduled report API:
   ```typescript
   // POST /api/v1/workspaces/:id/scheduled-reports
   async function handleCreateScheduledReport(request: Request, env: Env): Promise<Response> {
     const { workspaceId } = parseParams(request);
     const input = await validateBody(request, z.object({
       name: z.string(),
       type: z.enum(['summary', 'detailed', 'themes']),
       frequency: z.enum(['daily', 'weekly', 'monthly']),
       day_of_week: z.number().min(0).max(6).optional(),
       day_of_month: z.number().min(1).max(31).optional(),
       time_utc: z.string().regex(/^\d{2}:\d{2}$/),
       recipients: z.array(z.string().email()).min(1),
       board_id: z.string().optional()
     }));

     await requirePermission(request, env, workspaceId, 'export:create');

     const id = generateId('sr');
     const nextRun = calculateNextRun(input.frequency, input.day_of_week, input.day_of_month, input.time_utc);

     await env.DB.prepare(`
       INSERT INTO scheduled_reports (
         id, workspace_id, name, type, config, frequency,
         day_of_week, day_of_month, time_utc, recipients, next_run_at
       ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
     `).bind(
       id,
       workspaceId,
       input.name,
       input.type,
       JSON.stringify({ board_id: input.board_id }),
       input.frequency,
       input.day_of_week ?? null,
       input.day_of_month ?? null,
       input.time_utc,
       JSON.stringify(input.recipients),
       nextRun
     ).run();

     return jsonResponse({ id, next_run_at: nextRun }, 201);
   }
   ```

3. Create scheduled report worker:
   ```typescript
   // src/workers/scheduled-reports.ts

   export async function processScheduledReports(env: Env): Promise<void> {
     const now = new Date().toISOString();

     const dueReports = await env.DB.prepare(`
       SELECT * FROM scheduled_reports
       WHERE is_active = 1 AND next_run_at <= ?
       LIMIT 10
     `).bind(now).all();

     for (const schedule of dueReports.results) {
       try {
         // Determine date range
         const dateRange = getDateRangeForFrequency(schedule.frequency as string);

         // Generate report
         const reportId = generateId('rpt');
         await generatePDFReport(reportId, schedule.workspace_id as string, {
           type: schedule.type as string,
           date_range: dateRange,
           format: 'pdf'
         }, env);

         // Wait for completion
         let report = await waitForReport(reportId, env);

         // Send emails
         const recipients = JSON.parse(schedule.recipients as string);
         for (const email of recipients) {
           await sendReportEmail(email, report, env);
         }

         // Update schedule
         const nextRun = calculateNextRun(
           schedule.frequency as string,
           schedule.day_of_week as number | null,
           schedule.day_of_month as number | null,
           schedule.time_utc as string
         );

         await env.DB.prepare(`
           UPDATE scheduled_reports
           SET last_run_at = datetime('now'), next_run_at = ?
           WHERE id = ?
         `).bind(nextRun, schedule.id).run();

       } catch (error) {
         console.error(`Failed to process scheduled report ${schedule.id}:`, error);
       }
     }
   }
   ```

**Acceptance Criteria**:
- [ ] Reports generated on schedule
- [ ] Emails delivered
- [ ] Can pause/cancel

---

### 4.4.4 Report API Endpoint (0.5h)
**Objective**: Programmatic report generation

**Steps**:
1. Add report status and download endpoints:
   ```typescript
   // GET /api/v1/reports/:id
   async function handleGetReport(request: Request, env: Env): Promise<Response> {
     const { reportId } = parseParams(request);

     const report = await env.DB.prepare(`
       SELECT r.*, w.id as workspace_id
       FROM reports r
       JOIN workspaces w ON r.workspace_id = w.id
       WHERE r.id = ?
     `).bind(reportId).first();

     if (!report) {
       return errorResponse('NOT_FOUND', 'Report not found', 404);
     }

     await requirePermission(request, env, report.workspace_id as string, 'export:view');

     return jsonResponse({
       id: report.id,
       type: report.type,
       status: report.status,
       download_url: report.status === 'completed' ? report.download_url : null,
       error: report.error,
       created_at: report.created_at,
       completed_at: report.completed_at
     });
   }

   // GET /api/v1/reports/:id/download
   async function handleDownloadReport(request: Request, env: Env): Promise<Response> {
     const { reportId } = parseParams(request);

     const report = await env.DB.prepare(`
       SELECT * FROM reports WHERE id = ? AND status = 'completed'
     `).bind(reportId).first();

     if (!report) {
       return errorResponse('NOT_FOUND', 'Report not found or not ready', 404);
     }

     await requirePermission(request, env, report.workspace_id as string, 'export:view');

     const file = await env.R2.get(`reports/${report.workspace_id}/${reportId}.pdf`);
     if (!file) {
       return errorResponse('NOT_FOUND', 'Report file not found', 404);
     }

     return new Response(file.body, {
       headers: {
         'Content-Type': 'application/pdf',
         'Content-Disposition': `attachment; filename="report-${reportId}.pdf"`
       }
     });
   }
   ```

**Acceptance Criteria**:
- [ ] Report status queryable
- [ ] Download works
- [ ] Webhook on completion (optional)

---

## Definition of Done
- [ ] CSV export working with filters
- [ ] PDF reports generating
- [ ] Scheduled reports delivering
- [ ] API for programmatic access
- [ ] Reports stored in R2

## Technical Notes
- PDF generation with jsPDF
- Reports stored in R2 with 30-day expiry
- Queue for async generation
- Email delivery via Resend or similar

## Related Files
- `src/routes/exports.ts` - Export endpoints
- `src/lib/reports/generator.ts` - PDF generation
- `src/workers/scheduled-reports.ts` - Scheduler
