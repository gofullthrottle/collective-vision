# Epic 6.3: Usage-Based Billing

## Methodology Guidance
**SPECTRA Phase**: Codify + Test
**Approach**: Build comprehensive usage tracking and metering system for AI credits, API calls, and storage consumption with real-time enforcement.

## Wave Context
**Wave 6**: Monetization & Pricing (Stripe Integration, Subscription Tiers, Usage Billing)
**Dependencies**: 6.1 (Stripe Integration), 6.2 (Tier Management)
**Unlocks**: Overage billing, usage dashboards, enterprise metering

## Quality Requirements
- Usage tracking with <100ms latency impact
- Real-time limit enforcement
- Accurate metering for billing reconciliation
- Usage data retention for 13 months (billing disputes)

---

## Tasks

### Task 6.3.1: AI Credits Tracking System (1.5h)

Track AI credit consumption per operation type with workspace-level quotas.

**Subtasks**:
- [ ] Create AI credits ledger table
- [ ] Implement credit deduction on AI operations
- [ ] Add credit balance caching in KV
- [ ] Build low-credit warning system

**Schema**:
```sql
-- AI Credits Ledger
CREATE TABLE IF NOT EXISTS ai_credits_ledger (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  operation_type TEXT NOT NULL, -- 'embedding', 'classification', 'summarization', 'dedup_check', 'theme_cluster'
  credits_used INTEGER NOT NULL,
  credits_balance_after INTEGER NOT NULL,
  reference_type TEXT, -- 'feedback_item', 'import_job', 'theme_report'
  reference_id TEXT,
  metadata TEXT, -- JSON: model, tokens_in, tokens_out
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_credits_workspace ON ai_credits_ledger(workspace_id, created_at DESC);
CREATE INDEX idx_credits_operation ON ai_credits_ledger(workspace_id, operation_type);

-- Monthly usage aggregates (materialized for billing)
CREATE TABLE IF NOT EXISTS usage_aggregates (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  billing_period TEXT NOT NULL, -- '2025-01'
  metric_type TEXT NOT NULL, -- 'ai_credits', 'api_calls', 'storage_bytes', 'feedback_items'
  usage_count INTEGER DEFAULT 0,
  usage_limit INTEGER, -- NULL = unlimited
  overage_count INTEGER DEFAULT 0,
  updated_at TEXT DEFAULT (datetime('now')),
  UNIQUE(workspace_id, billing_period, metric_type)
);
```

**Implementation**:
```typescript
// src/services/ai-credits.ts
import { TierLimits, getTierLimits } from './tier-management';

interface CreditCost {
  embedding: number;
  classification: number;
  summarization: number;
  dedup_check: number;
  theme_cluster: number;
}

const CREDIT_COSTS: CreditCost = {
  embedding: 1,
  classification: 5,
  summarization: 10,
  dedup_check: 2,
  theme_cluster: 20
};

interface CreditDeduction {
  workspace_id: string;
  operation_type: keyof CreditCost;
  reference_type?: string;
  reference_id?: string;
  metadata?: Record<string, unknown>;
}

export async function deductCredits(
  env: Env,
  deduction: CreditDeduction
): Promise<{ success: boolean; remaining: number; error?: string }> {
  const cost = CREDIT_COSTS[deduction.operation_type];

  // Get current balance from KV cache
  const cacheKey = `credits:${deduction.workspace_id}`;
  const cached = await env.USAGE_KV.get(cacheKey, 'json') as { balance: number; period: string } | null;

  const currentPeriod = new Date().toISOString().slice(0, 7); // '2025-01'

  // If new period, reset from tier limits
  if (!cached || cached.period !== currentPeriod) {
    const workspace = await env.DB.prepare(
      'SELECT subscription_tier FROM workspaces WHERE id = ?'
    ).bind(deduction.workspace_id).first<{ subscription_tier: string }>();

    const limits = getTierLimits(workspace?.subscription_tier || 'free');
    const newBalance = limits.ai_credits_monthly;

    await env.USAGE_KV.put(cacheKey, JSON.stringify({
      balance: newBalance,
      period: currentPeriod
    }), { expirationTtl: 86400 * 35 }); // 35 days

    cached.balance = newBalance;
    cached.period = currentPeriod;
  }

  // Check if enough credits
  if (cached.balance < cost) {
    return {
      success: false,
      remaining: cached.balance,
      error: `Insufficient AI credits. Need ${cost}, have ${cached.balance}`
    };
  }

  const newBalance = cached.balance - cost;

  // Atomic update with optimistic locking
  await env.DB.prepare(`
    INSERT INTO ai_credits_ledger (
      workspace_id, operation_type, credits_used, credits_balance_after,
      reference_type, reference_id, metadata
    ) VALUES (?, ?, ?, ?, ?, ?, ?)
  `).bind(
    deduction.workspace_id,
    deduction.operation_type,
    cost,
    newBalance,
    deduction.reference_type || null,
    deduction.reference_id || null,
    deduction.metadata ? JSON.stringify(deduction.metadata) : null
  ).run();

  // Update aggregate
  await env.DB.prepare(`
    INSERT INTO usage_aggregates (workspace_id, billing_period, metric_type, usage_count)
    VALUES (?, ?, 'ai_credits', ?)
    ON CONFLICT(workspace_id, billing_period, metric_type)
    DO UPDATE SET usage_count = usage_count + ?, updated_at = datetime('now')
  `).bind(deduction.workspace_id, currentPeriod, cost, cost).run();

  // Update cache
  await env.USAGE_KV.put(cacheKey, JSON.stringify({
    balance: newBalance,
    period: currentPeriod
  }), { expirationTtl: 86400 * 35 });

  // Low credit warning (20% threshold)
  const limits = getTierLimits('pro'); // Get from workspace
  if (newBalance < limits.ai_credits_monthly * 0.2) {
    await env.QUEUES.send({
      type: 'low_credits_warning',
      workspace_id: deduction.workspace_id,
      remaining: newBalance,
      threshold: 0.2
    });
  }

  return { success: true, remaining: newBalance };
}

export async function getCreditsBalance(
  env: Env,
  workspaceId: string
): Promise<{ balance: number; used: number; limit: number; period: string }> {
  const currentPeriod = new Date().toISOString().slice(0, 7);

  const aggregate = await env.DB.prepare(`
    SELECT usage_count, usage_limit FROM usage_aggregates
    WHERE workspace_id = ? AND billing_period = ? AND metric_type = 'ai_credits'
  `).bind(workspaceId, currentPeriod).first<{ usage_count: number; usage_limit: number }>();

  const workspace = await env.DB.prepare(
    'SELECT subscription_tier FROM workspaces WHERE id = ?'
  ).bind(workspaceId).first<{ subscription_tier: string }>();

  const limits = getTierLimits(workspace?.subscription_tier || 'free');
  const used = aggregate?.usage_count || 0;
  const limit = limits.ai_credits_monthly;

  return {
    balance: Math.max(0, limit - used),
    used,
    limit,
    period: currentPeriod
  };
}
```

**Acceptance Criteria**:
- [ ] Credits deducted atomically on AI operations
- [ ] Balance cached in KV for fast checks
- [ ] Monthly reset on new billing period
- [ ] Low credit warnings at 20% threshold

---

### Task 6.3.2: API Call Metering (1h)

Track API requests per workspace with rate limiting and usage quotas.

**Subtasks**:
- [ ] Implement request counter in KV
- [ ] Add rate limiting middleware
- [ ] Track by endpoint category
- [ ] Build usage breakdown reports

**Implementation**:
```typescript
// src/middleware/api-metering.ts
interface RateLimitConfig {
  requests_per_minute: number;
  requests_per_day: number;
}

const RATE_LIMITS: Record<string, RateLimitConfig> = {
  free: { requests_per_minute: 60, requests_per_day: 1000 },
  pro: { requests_per_minute: 300, requests_per_day: 10000 },
  enterprise: { requests_per_minute: 1000, requests_per_day: 100000 }
};

interface MeterResult {
  allowed: boolean;
  remaining: number;
  reset_at: number;
  error?: string;
}

export async function meterApiCall(
  env: Env,
  workspaceId: string,
  tier: string,
  endpoint: string
): Promise<MeterResult> {
  const limits = RATE_LIMITS[tier] || RATE_LIMITS.free;
  const now = Date.now();
  const minuteWindow = Math.floor(now / 60000);
  const dayWindow = Math.floor(now / 86400000);

  // Check minute rate limit
  const minuteKey = `ratelimit:${workspaceId}:minute:${minuteWindow}`;
  const minuteCount = parseInt(await env.USAGE_KV.get(minuteKey) || '0');

  if (minuteCount >= limits.requests_per_minute) {
    return {
      allowed: false,
      remaining: 0,
      reset_at: (minuteWindow + 1) * 60000,
      error: 'Rate limit exceeded. Try again in a minute.'
    };
  }

  // Check daily quota
  const dayKey = `ratelimit:${workspaceId}:day:${dayWindow}`;
  const dayCount = parseInt(await env.USAGE_KV.get(dayKey) || '0');

  if (dayCount >= limits.requests_per_day) {
    return {
      allowed: false,
      remaining: 0,
      reset_at: (dayWindow + 1) * 86400000,
      error: 'Daily API quota exceeded. Upgrade your plan for more requests.'
    };
  }

  // Increment counters
  await Promise.all([
    env.USAGE_KV.put(minuteKey, String(minuteCount + 1), { expirationTtl: 120 }),
    env.USAGE_KV.put(dayKey, String(dayCount + 1), { expirationTtl: 90000 })
  ]);

  // Track by endpoint for analytics (async, don't await)
  trackEndpointUsage(env, workspaceId, endpoint);

  return {
    allowed: true,
    remaining: limits.requests_per_day - dayCount - 1,
    reset_at: (dayWindow + 1) * 86400000
  };
}

async function trackEndpointUsage(
  env: Env,
  workspaceId: string,
  endpoint: string
): Promise<void> {
  const period = new Date().toISOString().slice(0, 7);
  const category = categorizeEndpoint(endpoint);

  await env.DB.prepare(`
    INSERT INTO api_usage_by_endpoint (workspace_id, billing_period, endpoint_category, request_count)
    VALUES (?, ?, ?, 1)
    ON CONFLICT(workspace_id, billing_period, endpoint_category)
    DO UPDATE SET request_count = request_count + 1, updated_at = datetime('now')
  `).bind(workspaceId, period, category).run();
}

function categorizeEndpoint(endpoint: string): string {
  if (endpoint.includes('/feedback')) return 'feedback';
  if (endpoint.includes('/votes')) return 'votes';
  if (endpoint.includes('/comments')) return 'comments';
  if (endpoint.includes('/analytics')) return 'analytics';
  if (endpoint.includes('/ai/')) return 'ai';
  if (endpoint.includes('/mcp')) return 'mcp';
  return 'other';
}

// Middleware wrapper
export function withApiMetering(
  handler: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>
) {
  return async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {
    const workspaceId = extractWorkspaceId(request);
    if (!workspaceId) return handler(request, env, ctx);

    const workspace = await env.DB.prepare(
      'SELECT subscription_tier FROM workspaces WHERE id = ?'
    ).bind(workspaceId).first<{ subscription_tier: string }>();

    const result = await meterApiCall(
      env,
      workspaceId,
      workspace?.subscription_tier || 'free',
      new URL(request.url).pathname
    );

    if (!result.allowed) {
      return new Response(JSON.stringify({ error: result.error }), {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': String(result.reset_at),
          'Retry-After': String(Math.ceil((result.reset_at - Date.now()) / 1000))
        }
      });
    }

    const response = await handler(request, env, ctx);

    // Add rate limit headers
    const headers = new Headers(response.headers);
    headers.set('X-RateLimit-Remaining', String(result.remaining));
    headers.set('X-RateLimit-Reset', String(result.reset_at));

    return new Response(response.body, {
      status: response.status,
      headers
    });
  };
}
```

**Acceptance Criteria**:
- [ ] Per-minute and per-day rate limiting
- [ ] Tier-based limits enforced
- [ ] Usage tracked by endpoint category
- [ ] Rate limit headers in responses

---

### Task 6.3.3: Storage Usage Tracking (1h)

Monitor storage consumption for feedback attachments, avatars, and exports.

**Subtasks**:
- [ ] Track R2 object sizes on upload
- [ ] Calculate workspace storage totals
- [ ] Enforce storage limits
- [ ] Build storage cleanup utilities

**Implementation**:
```typescript
// src/services/storage-tracking.ts
interface StorageEntry {
  workspace_id: string;
  object_type: 'attachment' | 'avatar' | 'export' | 'import_backup';
  object_key: string;
  size_bytes: number;
  reference_id?: string;
}

export async function trackStorageUpload(
  env: Env,
  entry: StorageEntry
): Promise<{ allowed: boolean; usage: number; limit: number }> {
  const workspace = await env.DB.prepare(
    'SELECT subscription_tier FROM workspaces WHERE id = ?'
  ).bind(entry.workspace_id).first<{ subscription_tier: string }>();

  const limits = getTierLimits(workspace?.subscription_tier || 'free');

  // Get current storage usage
  const current = await env.DB.prepare(`
    SELECT COALESCE(SUM(size_bytes), 0) as total
    FROM storage_objects WHERE workspace_id = ?
  `).bind(entry.workspace_id).first<{ total: number }>();

  const currentUsage = current?.total || 0;
  const newTotal = currentUsage + entry.size_bytes;

  if (newTotal > limits.storage_bytes) {
    return {
      allowed: false,
      usage: currentUsage,
      limit: limits.storage_bytes
    };
  }

  // Record storage object
  await env.DB.prepare(`
    INSERT INTO storage_objects (
      workspace_id, object_type, object_key, size_bytes, reference_id
    ) VALUES (?, ?, ?, ?, ?)
  `).bind(
    entry.workspace_id,
    entry.object_type,
    entry.object_key,
    entry.size_bytes,
    entry.reference_id || null
  ).run();

  // Update monthly aggregate
  const period = new Date().toISOString().slice(0, 7);
  await env.DB.prepare(`
    INSERT INTO usage_aggregates (workspace_id, billing_period, metric_type, usage_count)
    VALUES (?, ?, 'storage_bytes', ?)
    ON CONFLICT(workspace_id, billing_period, metric_type)
    DO UPDATE SET usage_count = ?, updated_at = datetime('now')
  `).bind(entry.workspace_id, period, newTotal, newTotal).run();

  return {
    allowed: true,
    usage: newTotal,
    limit: limits.storage_bytes
  };
}

export async function trackStorageDelete(
  env: Env,
  workspaceId: string,
  objectKey: string
): Promise<void> {
  await env.DB.prepare(`
    DELETE FROM storage_objects WHERE workspace_id = ? AND object_key = ?
  `).bind(workspaceId, objectKey).run();

  // Recalculate total
  const current = await env.DB.prepare(`
    SELECT COALESCE(SUM(size_bytes), 0) as total
    FROM storage_objects WHERE workspace_id = ?
  `).bind(workspaceId).first<{ total: number }>();

  const period = new Date().toISOString().slice(0, 7);
  await env.DB.prepare(`
    UPDATE usage_aggregates SET usage_count = ?, updated_at = datetime('now')
    WHERE workspace_id = ? AND billing_period = ? AND metric_type = 'storage_bytes'
  `).bind(current?.total || 0, workspaceId, period).run();
}

export async function getStorageBreakdown(
  env: Env,
  workspaceId: string
): Promise<Record<string, { count: number; bytes: number }>> {
  const results = await env.DB.prepare(`
    SELECT object_type, COUNT(*) as count, SUM(size_bytes) as bytes
    FROM storage_objects WHERE workspace_id = ?
    GROUP BY object_type
  `).bind(workspaceId).all<{ object_type: string; count: number; bytes: number }>();

  const breakdown: Record<string, { count: number; bytes: number }> = {};
  for (const row of results.results) {
    breakdown[row.object_type] = { count: row.count, bytes: row.bytes };
  }
  return breakdown;
}
```

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS storage_objects (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  workspace_id TEXT NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  object_type TEXT NOT NULL, -- 'attachment', 'avatar', 'export', 'import_backup'
  object_key TEXT NOT NULL UNIQUE, -- R2 key
  size_bytes INTEGER NOT NULL,
  reference_id TEXT, -- feedback_id, user_id, export_id
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_storage_workspace ON storage_objects(workspace_id);
CREATE INDEX idx_storage_type ON storage_objects(workspace_id, object_type);
```

**Acceptance Criteria**:
- [ ] Storage tracked on upload/delete
- [ ] Limits enforced before upload
- [ ] Usage breakdown by object type
- [ ] Cleanup utilities for orphaned objects

---

### Task 6.3.4: Usage Dashboard API (0.5h)

Provide comprehensive usage data for admin dashboard visualization.

**Subtasks**:
- [ ] Build usage summary endpoint
- [ ] Add historical usage trends
- [ ] Include tier comparison data
- [ ] Support CSV export

**Implementation**:
```typescript
// GET /api/v1/admin/usage
interface UsageSummary {
  period: string;
  ai_credits: { used: number; limit: number; remaining: number };
  api_calls: { used: number; limit: number; by_category: Record<string, number> };
  storage: { used_bytes: number; limit_bytes: number; by_type: Record<string, number> };
  feedback_items: { count: number; limit: number };
  team_members: { count: number; limit: number };
  boards: { count: number; limit: number };
  trends: {
    period: string;
    ai_credits: number;
    api_calls: number;
    feedback_items: number;
  }[];
}

export async function getUsageSummary(
  env: Env,
  workspaceId: string,
  includeHistory = true
): Promise<UsageSummary> {
  const currentPeriod = new Date().toISOString().slice(0, 7);

  const workspace = await env.DB.prepare(`
    SELECT subscription_tier FROM workspaces WHERE id = ?
  `).bind(workspaceId).first<{ subscription_tier: string }>();

  const limits = getTierLimits(workspace?.subscription_tier || 'free');

  // Current usage
  const [credits, apiCalls, storage, feedbackCount, memberCount, boardCount] = await Promise.all([
    getCreditsBalance(env, workspaceId),
    getApiUsageByCategory(env, workspaceId, currentPeriod),
    getStorageBreakdown(env, workspaceId),
    env.DB.prepare('SELECT COUNT(*) as count FROM feedback_items WHERE workspace_id = ?')
      .bind(workspaceId).first<{ count: number }>(),
    env.DB.prepare('SELECT COUNT(*) as count FROM team_members WHERE workspace_id = ?')
      .bind(workspaceId).first<{ count: number }>(),
    env.DB.prepare('SELECT COUNT(*) as count FROM boards WHERE workspace_id = ?')
      .bind(workspaceId).first<{ count: number }>()
  ]);

  const storageTotal = Object.values(storage).reduce((sum, s) => sum + s.bytes, 0);
  const apiTotal = Object.values(apiCalls).reduce((sum, c) => sum + c, 0);

  let trends: UsageSummary['trends'] = [];
  if (includeHistory) {
    const history = await env.DB.prepare(`
      SELECT billing_period, metric_type, usage_count
      FROM usage_aggregates
      WHERE workspace_id = ? AND billing_period >= date('now', '-6 months')
      ORDER BY billing_period
    `).bind(workspaceId).all();

    // Group by period
    const periodMap = new Map<string, { ai_credits: number; api_calls: number; feedback_items: number }>();
    for (const row of history.results) {
      if (!periodMap.has(row.billing_period)) {
        periodMap.set(row.billing_period, { ai_credits: 0, api_calls: 0, feedback_items: 0 });
      }
      const p = periodMap.get(row.billing_period)!;
      if (row.metric_type === 'ai_credits') p.ai_credits = row.usage_count;
      if (row.metric_type === 'api_calls') p.api_calls = row.usage_count;
      if (row.metric_type === 'feedback_items') p.feedback_items = row.usage_count;
    }

    trends = Array.from(periodMap.entries()).map(([period, data]) => ({
      period,
      ...data
    }));
  }

  return {
    period: currentPeriod,
    ai_credits: {
      used: credits.used,
      limit: credits.limit,
      remaining: credits.balance
    },
    api_calls: {
      used: apiTotal,
      limit: limits.api_requests_per_day * 30,
      by_category: apiCalls
    },
    storage: {
      used_bytes: storageTotal,
      limit_bytes: limits.storage_bytes,
      by_type: Object.fromEntries(
        Object.entries(storage).map(([k, v]) => [k, v.bytes])
      )
    },
    feedback_items: {
      count: feedbackCount?.count || 0,
      limit: limits.feedback_per_month
    },
    team_members: {
      count: memberCount?.count || 0,
      limit: limits.team_members
    },
    boards: {
      count: boardCount?.count || 0,
      limit: limits.boards
    },
    trends
  };
}
```

**Acceptance Criteria**:
- [ ] Complete usage summary with all metrics
- [ ] 6-month historical trends
- [ ] Breakdown by category/type
- [ ] CSV export option

---

## Definition of Done
- [ ] All usage metrics tracked in real-time
- [ ] KV caching for sub-100ms latency
- [ ] Rate limiting with proper headers
- [ ] Monthly aggregates for billing
- [ ] Usage dashboard API complete
- [ ] Integration tests for limit enforcement

## Technical Notes
- Use KV for hot data (current period balances, rate limits)
- Use D1 for historical data and auditing
- Aggregates updated on every operation for billing accuracy
- 13-month retention for billing dispute resolution

## Related Files
- `src/services/ai-credits.ts` - Credit tracking
- `src/middleware/api-metering.ts` - Rate limiting
- `src/services/storage-tracking.ts` - Storage usage
- `src/routes/admin/usage.ts` - Dashboard API
