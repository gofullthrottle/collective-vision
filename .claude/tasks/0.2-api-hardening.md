# Epic 0.2: API Hardening

## Methodology Guidance
**SPECTRA Phase**: Foundation/Hardening
**Approach**: Defense-in-depth with validation, rate limiting, error standardization
**Tools**: Zod for validation, Cloudflare rate limiting, structured error responses

## Wave Context
**Wave**: 0 - Foundation Hardening
**Priority**: Critical (security foundation for all features)
**Dependencies**: None
**Estimated Duration**: 4 hours

## Quality Requirements
- All endpoints validate input before processing
- Rate limiting prevents abuse
- Error responses follow consistent format
- No SQL injection possible via any parameter
- CORS properly configured for production

---

## Tasks

### 0.2.1 Request Validation (1.5h)
**Objective**: Add comprehensive input validation to all API endpoints

**Steps**:
1. Install and configure Zod:
   ```bash
   npm install zod
   ```
2. Create validation schemas for all endpoints:
   ```typescript
   // src/lib/validation/schemas.ts
   const createFeedbackSchema = z.object({
     title: z.string().min(1).max(500),
     description: z.string().max(5000).optional(),
     externalUserId: z.string().min(1).max(100).optional()
   });
   ```
3. Create validation middleware:
   ```typescript
   async function validateBody<T>(request: Request, schema: z.Schema<T>): Promise<T> {
     const body = await request.json();
     return schema.parse(body);
   }
   ```
4. Apply validation to POST/PUT endpoints
5. Validate URL parameters (workspace slug, board slug, feedback ID)
6. Return structured validation errors

**Acceptance Criteria**:
- [ ] All endpoints validate input before database access
- [ ] Invalid requests return 400 with detailed error messages
- [ ] No SQL injection possible via parameters
- [ ] Validation schemas documented

---

### 0.2.2 Rate Limiting (1.5h)
**Objective**: Implement rate limiting to prevent abuse

**Steps**:
1. Choose implementation approach:
   - Option A: Cloudflare Rate Limiting Rules (preferred)
   - Option B: D1-based rate limiting (custom)
2. Configure limits per endpoint type:
   - Public reads: 100 requests/minute
   - Writes (submit, vote): 20 requests/minute
   - Auth endpoints: 5 requests/minute
3. Implement rate limit checking middleware:
   ```typescript
   async function checkRateLimit(
     request: Request,
     identifier: string,
     limit: number,
     window: number
   ): Promise<{ allowed: boolean; remaining: number; resetAt: number }>
   ```
4. Return 429 Too Many Requests with Retry-After header

**Response Format**:
```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests",
    "retry_after": 45
  }
}
```

**Acceptance Criteria**:
- [ ] Rate limits enforced on all endpoints
- [ ] 429 responses include Retry-After header
- [ ] Limits configurable (for future tier-based limits)
- [ ] Rate limit status visible in response headers

---

### 0.2.3 Error Handling Standardization (0.5h)
**Objective**: Consistent error response format across all endpoints

**Steps**:
1. Create standard error response format:
   ```typescript
   interface APIError {
     error: {
       code: string;
       message: string;
       details?: Record<string, unknown>;
     };
   }
   ```
2. Define error codes:
   - `VALIDATION_ERROR` - Invalid input
   - `NOT_FOUND` - Resource not found
   - `UNAUTHORIZED` - Authentication required
   - `FORBIDDEN` - Permission denied
   - `RATE_LIMIT_EXCEEDED` - Too many requests
   - `INTERNAL_ERROR` - Server error
3. Create error helper:
   ```typescript
   function errorResponse(code: string, message: string, status: number, details?: object): Response
   ```
4. Log errors with request context (no PII)
5. Ensure no stack traces in production responses

**Acceptance Criteria**:
- [ ] All errors follow standard format
- [ ] Consistent HTTP status codes
- [ ] No stack traces exposed to clients
- [ ] Error logging includes request ID

---

### 0.2.4 CORS Production Configuration (0.5h)
**Objective**: Properly configure CORS for production security

**Steps**:
1. Configure allowed origins per environment:
   ```typescript
   const ALLOWED_ORIGINS = {
     production: ['https://yoursite.com', 'https://app.yoursite.com'],
     development: ['http://localhost:*', '*']
   };
   ```
2. Widget endpoints: Allow any origin (widget can be embedded anywhere)
3. Admin API endpoints: Restrict to known origins
4. Ensure credentials handling correct (`Access-Control-Allow-Credentials`)
5. Document CORS policy in API docs

**Acceptance Criteria**:
- [ ] Widget works when embedded from any origin
- [ ] Admin API appropriately restricted
- [ ] Preflight requests handled correctly
- [ ] CORS policy documented

---

## Definition of Done
- [ ] All API endpoints validate input
- [ ] Rate limiting active on all endpoints
- [ ] Error responses follow consistent format
- [ ] CORS properly configured for production
- [ ] Security review passed

## Technical Notes
- Use Cloudflare's built-in rate limiting if available in plan
- Consider IP-based rate limiting for anonymous endpoints
- User-based rate limiting for authenticated endpoints
- Store rate limit state in KV for distributed counting

## Related Files
- `src/worker.ts` - Main API routes
- `src/lib/validation/` - Validation schemas (to create)
- `src/lib/errors.ts` - Error helpers (to create)
